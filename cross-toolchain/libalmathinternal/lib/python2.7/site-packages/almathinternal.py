# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_almathinternal', [dirname(__file__)])
        except ImportError:
            import _almathinternal
            return _almathinternal
        if fp is not None:
            try:
                _mod = imp.load_module('_almathinternal', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _almathinternal = swig_import_helper()
    del swig_import_helper
else:
    import _almathinternal
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


import almathswig
class Segment(_object):
    """Proxy of C++ AL::Math::Segment class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Segment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Segment, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _almathinternal.Segment_start_set
    __swig_getmethods__["start"] = _almathinternal.Segment_start_get
    if _newclass:start = _swig_property(_almathinternal.Segment_start_get, _almathinternal.Segment_start_set)
    __swig_setmethods__["end"] = _almathinternal.Segment_end_set
    __swig_getmethods__["end"] = _almathinternal.Segment_end_get
    if _newclass:end = _swig_property(_almathinternal.Segment_end_get, _almathinternal.Segment_end_set)
    def __init__(self, *args): 
        """
        __init__(AL::Math::Segment self) -> Segment
        __init__(AL::Math::Segment self, Position2D pStart, Position2D pEnd) -> Segment
        """
        this = _almathinternal.new_Segment(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_Segment
    __del__ = lambda self : None;
Segment_swigregister = _almathinternal.Segment_swigregister
Segment_swigregister(Segment)


def isIndexInList(*args):
  """isIndexInList(unsigned short pk, std::vector< unsigned short,std::allocator< unsigned short > > pList) -> bool"""
  return _almathinternal.isIndexInList(*args)

def sortPredicate(*args):
  """sortPredicate(Position2D p1, Position2D p2) -> bool"""
  return _almathinternal.sortPredicate(*args)

def removeAlignedPoint(*args):
  """removeAlignedPoint(vectorPosition2D pPoints, vectorPosition2D pOut)"""
  return _almathinternal.removeAlignedPoint(*args)

def deleteDupesInUnsortedVector(*args):
  """
    deleteDupesInUnsortedVector(vectorPosition2D pPoints, float const pEps=0.0001)
    deleteDupesInUnsortedVector(vectorPosition2D pPoints)
    """
  return _almathinternal.deleteDupesInUnsortedVector(*args)

def deleteDupesInSortedVector(*args):
  """
    deleteDupesInSortedVector(vectorPosition2D pPoints, float const pEps=0.0001)
    deleteDupesInSortedVector(vectorPosition2D pPoints)
    """
  return _almathinternal.deleteDupesInSortedVector(*args)

def isLeft(*args):
  """
    isLeft(Position2D pA, Position2D pB, Position2D pC, float const & pEps=0.00001) -> int
    isLeft(Position2D pA, Position2D pB, Position2D pC) -> int
    isLeft(Position3D pDirection, Position3D pA, Position3D pB, Position3D pC, float const & pEps=0.00001) -> int
    isLeft(Position3D pDirection, Position3D pA, Position3D pB, Position3D pC) -> int
    """
  return _almathinternal.isLeft(*args)

def isLeftBest(*args):
  """isLeftBest(Position2D pA, Position2D pB, Position2D pC) -> int"""
  return _almathinternal.isLeftBest(*args)

def isLeftOld(*args):
  """
    isLeftOld(Position2D pA, Position2D pB, Position2D pC, float const & pEps=0.000001) -> int
    isLeftOld(Position2D pA, Position2D pB, Position2D pC) -> int
    """
  return _almathinternal.isLeftOld(*args)

def simplifyConvexHull(*args):
  """simplifyConvexHull(vectorPosition2D pConvexHull)"""
  return _almathinternal.simplifyConvexHull(*args)

def getConvexHull(*args):
  """getConvexHull(vectorPosition2D pPoints) -> vectorPosition2D"""
  return _almathinternal.getConvexHull(*args)

def getConvexHullGraham(*args):
  """
    getConvexHullGraham(vectorPosition2D pPoints, float pEpsSinus=1e-4, float pEpsDistance=1e-6) -> vectorPosition2D
    getConvexHullGraham(vectorPosition2D pPoints, float pEpsSinus=1e-4) -> vectorPosition2D
    getConvexHullGraham(vectorPosition2D pPoints) -> vectorPosition2D
    """
  return _almathinternal.getConvexHullGraham(*args)

def getConvexHullGrahamInPlace(*args):
  """
    getConvexHullGrahamInPlace(vectorPosition2D pResult, float pEpsSinus=1e-4, float pEpsDistance=1e-6)
    getConvexHullGrahamInPlace(vectorPosition2D pResult, float pEpsSinus=1e-4)
    getConvexHullGrahamInPlace(vectorPosition2D pResult)
    """
  return _almathinternal.getConvexHullGrahamInPlace(*args)

def xCompareX(*args):
  """xCompareX(Position2D p0, Position2D p1) -> bool"""
  return _almathinternal.xCompareX(*args)

def xCompareY(*args):
  """xCompareY(Position2D p0, Position2D p1) -> bool"""
  return _almathinternal.xCompareY(*args)

def computePointProjectionOnEdge(*args):
  """
    computePointProjectionOnEdge(Position2D pPoint, Position2D pSegmentOrigin, Position2D pSegmentEnd, float & pProportion, 
        Position2D pProjection)
    """
  return _almathinternal.computePointProjectionOnEdge(*args)

def computePointProjectionOnConvexHull(*args):
  """computePointProjectionOnConvexHull(Position2D pPoint, vectorPosition2D pConvexHull) -> Position2D"""
  return _almathinternal.computePointProjectionOnConvexHull(*args)

def scaleConvexHullInPlace(*args):
  """scaleConvexHullInPlace(vectorPosition2D pConvexHull, float pScaleFactor)"""
  return _almathinternal.scaleConvexHullInPlace(*args)

def scaleConvexHull(*args):
  """scaleConvexHull(vectorPosition2D pConvexHull, float pScaleFactor, vectorPosition2D pConvexHullScaled)"""
  return _almathinternal.scaleConvexHull(*args)
class VelocitySaturationProfile(_object):
    """Proxy of C++ AL::Math::VelocitySaturationProfile class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VelocitySaturationProfile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VelocitySaturationProfile, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::VelocitySaturationProfile self) -> VelocitySaturationProfile"""
        this = _almathinternal.new_VelocitySaturationProfile()
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """init(VelocitySaturationProfile self, float pX0, float pX1, float pX2, float pX3, float pY0, float pY1, float pY2)"""
        return _almathinternal.VelocitySaturationProfile_init(self, *args)

    def __call__(self, *args):
        """__call__(VelocitySaturationProfile self, float pX) -> float"""
        return _almathinternal.VelocitySaturationProfile___call__(self, *args)

    __swig_destroy__ = _almathinternal.delete_VelocitySaturationProfile
    __del__ = lambda self : None;
VelocitySaturationProfile_swigregister = _almathinternal.VelocitySaturationProfile_swigregister
VelocitySaturationProfile_swigregister(VelocitySaturationProfile)

class VelocitySaturationProfile2D(_object):
    """Proxy of C++ AL::Math::VelocitySaturationProfile2D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VelocitySaturationProfile2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VelocitySaturationProfile2D, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::VelocitySaturationProfile2D self) -> VelocitySaturationProfile2D"""
        this = _almathinternal.new_VelocitySaturationProfile2D()
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """
        init(VelocitySaturationProfile2D self, float pR0, float pR1, float pR2, float pR3, float pTheta0, float pTheta1, float pY0, 
            float pY1, float pY2)
        """
        return _almathinternal.VelocitySaturationProfile2D_init(self, *args)

    def __call__(self, *args):
        """__call__(VelocitySaturationProfile2D self, Position2D pPos) -> float"""
        return _almathinternal.VelocitySaturationProfile2D___call__(self, *args)

    __swig_destroy__ = _almathinternal.delete_VelocitySaturationProfile2D
    __del__ = lambda self : None;
VelocitySaturationProfile2D_swigregister = _almathinternal.VelocitySaturationProfile2D_swigregister
VelocitySaturationProfile2D_swigregister(VelocitySaturationProfile2D)

TRACKER_BASIC = _almathinternal.TRACKER_BASIC
TRACKER_TYPEIV = _almathinternal.TRACKER_TYPEIV
TRACKER_QUINTICSPLINE = _almathinternal.TRACKER_QUINTICSPLINE
TRACKER_ERRORCOMPENSATION = _almathinternal.TRACKER_ERRORCOMPENSATION
TRACKER_PREVIEWTRAJECTORY = _almathinternal.TRACKER_PREVIEWTRAJECTORY
TRACKER_ALL = _almathinternal.TRACKER_ALL
TRACKER_BANG = _almathinternal.TRACKER_BANG
TRACKER_NUMBER_OF_TYPE = _almathinternal.TRACKER_NUMBER_OF_TYPE
class AnticipationTracker(_object):
    """Proxy of C++ AL::Math::AnticipationTracker class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnticipationTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AnticipationTracker, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::AnticipationTracker self) -> AnticipationTracker
        __init__(AL::Math::AnticipationTracker self, AL::Math::TRACKER_TYPE const & pTrackerState, float const & pPeriod, float const & pVelocityMaxAbs, 
            float const & pAccelerationMaxAbs, float const & pJerkMaxAbs, 
            unsigned int const & pPolynomDegree, unsigned int const & pNbSample, 
            float const & pTimeDamping) -> AnticipationTracker
        """
        this = _almathinternal.new_AnticipationTracker(*args)
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """init(AnticipationTracker self, float const & pCurrentAngle)"""
        return _almathinternal.AnticipationTracker_init(self, *args)

    def update(self, *args):
        """
        update(AnticipationTracker self, float const & pTargetTime, float const & pTargetAngle)
        update(AnticipationTracker self, float const & pTargetTime, float const & pTargetAngle, Limits pLimits)
        """
        return _almathinternal.AnticipationTracker_update(self, *args)

    def getResultInterpolation(self, *args):
        """getResultInterpolation(AnticipationTracker self, float const & pTime, PositionAndVelocity pOut)"""
        return _almathinternal.AnticipationTracker_getResultInterpolation(self, *args)

    def getResultPosition(self, *args):
        """getResultPosition(AnticipationTracker self, float const & pTime) -> float"""
        return _almathinternal.AnticipationTracker_getResultPosition(self, *args)

    def getResultVelocity(self, *args):
        """getResultVelocity(AnticipationTracker self, float const & pTime) -> float"""
        return _almathinternal.AnticipationTracker_getResultVelocity(self, *args)

    def getResultAcceleration(self, *args):
        """getResultAcceleration(AnticipationTracker self, float const & pTime) -> float"""
        return _almathinternal.AnticipationTracker_getResultAcceleration(self, *args)

    def printInfo(self):
        """printInfo(AnticipationTracker self) -> std::string"""
        return _almathinternal.AnticipationTracker_printInfo(self)

    def isFinished(self, *args):
        """isFinished(AnticipationTracker self, float pTime) -> bool"""
        return _almathinternal.AnticipationTracker_isFinished(self, *args)

    __swig_destroy__ = _almathinternal.delete_AnticipationTracker
    __del__ = lambda self : None;
AnticipationTracker_swigregister = _almathinternal.AnticipationTracker_swigregister
AnticipationTracker_swigregister(AnticipationTracker)

class OpenLoopFeedBack(_object):
    """Proxy of C++ AL::Math::OpenLoopFeedBack class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OpenLoopFeedBack, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OpenLoopFeedBack, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::OpenLoopFeedBack self) -> OpenLoopFeedBack
        __init__(AL::Math::OpenLoopFeedBack self, float const & pPeriod, float const & pVelocityMaxAbs) -> OpenLoopFeedBack
        """
        this = _almathinternal.new_OpenLoopFeedBack(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args):
        """update(OpenLoopFeedBack self, float const & pTargetTime, float const & pTargetAngle)"""
        return _almathinternal.OpenLoopFeedBack_update(self, *args)

    def getResultInterpolation(self, *args):
        """getResultInterpolation(OpenLoopFeedBack self, float const & pTime, PositionAndVelocity pOut)"""
        return _almathinternal.OpenLoopFeedBack_getResultInterpolation(self, *args)

    def getResultPosition(self, *args):
        """getResultPosition(OpenLoopFeedBack self, float const & pTime) -> float"""
        return _almathinternal.OpenLoopFeedBack_getResultPosition(self, *args)

    def getResultVelocity(self, *args):
        """getResultVelocity(OpenLoopFeedBack self, float const & pTime) -> float"""
        return _almathinternal.OpenLoopFeedBack_getResultVelocity(self, *args)

    def isFinished(self, *args):
        """isFinished(OpenLoopFeedBack self, float pTime) -> bool"""
        return _almathinternal.OpenLoopFeedBack_isFinished(self, *args)

    __swig_destroy__ = _almathinternal.delete_OpenLoopFeedBack
    __del__ = lambda self : None;
OpenLoopFeedBack_swigregister = _almathinternal.OpenLoopFeedBack_swigregister
OpenLoopFeedBack_swigregister(OpenLoopFeedBack)

class ALNormalizeData(_object):
    """Proxy of C++ AL::Math::ALNormalizeData class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALNormalizeData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALNormalizeData, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::ALNormalizeData self) -> ALNormalizeData
        __init__(AL::Math::ALNormalizeData self, unsigned int const & pNbSample) -> ALNormalizeData
        """
        this = _almathinternal.new_ALNormalizeData(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args):
        """update(ALNormalizeData self, float const & pData)"""
        return _almathinternal.ALNormalizeData_update(self, *args)

    def getDataBasic(self, *args):
        """getDataBasic(ALNormalizeData self, unsigned int const & pIdx) -> float"""
        return _almathinternal.ALNormalizeData_getDataBasic(self, *args)

    def getDataNormalized(self, *args):
        """getDataNormalized(ALNormalizeData self, unsigned int const & pIdx) -> float"""
        return _almathinternal.ALNormalizeData_getDataNormalized(self, *args)

    def printData(self):
        """printData(ALNormalizeData self) -> std::string"""
        return _almathinternal.ALNormalizeData_printData(self)

    __swig_destroy__ = _almathinternal.delete_ALNormalizeData
    __del__ = lambda self : None;
ALNormalizeData_swigregister = _almathinternal.ALNormalizeData_swigregister
ALNormalizeData_swigregister(ALNormalizeData)

class PreviewTrajectory(_object):
    """Proxy of C++ AL::Math::PreviewTrajectory class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreviewTrajectory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PreviewTrajectory, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::PreviewTrajectory self) -> PreviewTrajectory
        __init__(AL::Math::PreviewTrajectory self, unsigned int const & pPolynomDegree, unsigned int const & pNbSample, float const & pTimeDamping) -> PreviewTrajectory
        """
        this = _almathinternal.new_PreviewTrajectory(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args):
        """update(PreviewTrajectory self, float const & pTargetTime, float const & pTargetAngle)"""
        return _almathinternal.PreviewTrajectory_update(self, *args)

    def getResultInterpolation(self, *args):
        """getResultInterpolation(PreviewTrajectory self, float const & pTime, bool pUseDamping, PositionAndVelocity pOut)"""
        return _almathinternal.PreviewTrajectory_getResultInterpolation(self, *args)

    def getResultPosVelAcc(self, *args):
        """getResultPosVelAcc(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> PosVelAcc"""
        return _almathinternal.PreviewTrajectory_getResultPosVelAcc(self, *args)

    def getResultPosition(self, *args):
        """getResultPosition(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> float"""
        return _almathinternal.PreviewTrajectory_getResultPosition(self, *args)

    def getResultVelocity(self, *args):
        """getResultVelocity(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> float"""
        return _almathinternal.PreviewTrajectory_getResultVelocity(self, *args)

    def getResultAcceleration(self, *args):
        """getResultAcceleration(PreviewTrajectory self, float const & pTime, bool pUseDamping) -> float"""
        return _almathinternal.PreviewTrajectory_getResultAcceleration(self, *args)

    def getFinalTime(self):
        """getFinalTime(PreviewTrajectory self) -> float"""
        return _almathinternal.PreviewTrajectory_getFinalTime(self)

    def getInfo(self, *args):
        """getInfo(PreviewTrajectory self, unsigned int const & pIdx) -> PositionAndVelocity"""
        return _almathinternal.PreviewTrajectory_getInfo(self, *args)

    def printSolution(self):
        """printSolution(PreviewTrajectory self) -> std::string"""
        return _almathinternal.PreviewTrajectory_printSolution(self)

    def printInfo(self):
        """printInfo(PreviewTrajectory self) -> std::string"""
        return _almathinternal.PreviewTrajectory_printInfo(self)

    __swig_destroy__ = _almathinternal.delete_PreviewTrajectory
    __del__ = lambda self : None;
PreviewTrajectory_swigregister = _almathinternal.PreviewTrajectory_swigregister
PreviewTrajectory_swigregister(PreviewTrajectory)

class LowPassFilter(_object):
    """Proxy of C++ AL::Math::LowPassFilter class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LowPassFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LowPassFilter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::LowPassFilter self) -> LowPassFilter
        __init__(AL::Math::LowPassFilter self, float const & pPeriodSample, float const & pFrequency) -> LowPassFilter
        """
        this = _almathinternal.new_LowPassFilter(*args)
        try: self.this.append(this)
        except: self.this = this
    def update(self, *args):
        """update(LowPassFilter self, float const & pTargetAngle)"""
        return _almathinternal.LowPassFilter_update(self, *args)

    def getResult(self):
        """getResult(LowPassFilter self) -> float"""
        return _almathinternal.LowPassFilter_getResult(self)

    __swig_destroy__ = _almathinternal.delete_LowPassFilter
    __del__ = lambda self : None;
LowPassFilter_swigregister = _almathinternal.LowPassFilter_swigregister
LowPassFilter_swigregister(LowPassFilter)

class ThetaOdometryFusion(_object):
    """Proxy of C++ AL::Math::ThetaOdometryFusion class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThetaOdometryFusion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ThetaOdometryFusion, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(AL::Math::ThetaOdometryFusion self, float covariantFactor, float period) -> ThetaOdometryFusion"""
        this = _almathinternal.new_ThetaOdometryFusion(*args)
        try: self.this.append(this)
        except: self.this = this
    def computeOdometryFusion(self, *args):
        """
        computeOdometryFusion(ThetaOdometryFusion self, float pThetaVelGyr, float pThetaVelMre, float pWheelFLSensor, float pWheelFRSensor, 
            float pWheelBSensor)
        """
        return _almathinternal.ThetaOdometryFusion_computeOdometryFusion(self, *args)

    def getFilteredTheta(self):
        """getFilteredTheta(ThetaOdometryFusion self) -> float"""
        return _almathinternal.ThetaOdometryFusion_getFilteredTheta(self)

    def getFilteredThetaVel(self):
        """getFilteredThetaVel(ThetaOdometryFusion self) -> float"""
        return _almathinternal.ThetaOdometryFusion_getFilteredThetaVel(self)

    def useGyroAndKalman(self, *args):
        """useGyroAndKalman(ThetaOdometryFusion self, bool isEnabled)"""
        return _almathinternal.ThetaOdometryFusion_useGyroAndKalman(self, *args)

    def setConfig(self, *args):
        """setConfig(ThetaOdometryFusion self, AL::Math::ThetaOdometryFusion::Config const & config)"""
        return _almathinternal.ThetaOdometryFusion_setConfig(self, *args)

    __swig_destroy__ = _almathinternal.delete_ThetaOdometryFusion
    __del__ = lambda self : None;
ThetaOdometryFusion_swigregister = _almathinternal.ThetaOdometryFusion_swigregister
ThetaOdometryFusion_swigregister(ThetaOdometryFusion)

CONSTANT = _almathinternal.CONSTANT
LINEAR = _almathinternal.LINEAR
BEZIER = _almathinternal.BEZIER
BEZIER_AUTO = _almathinternal.BEZIER_AUTO
class Tangent(_object):
    """Proxy of C++ AL::Math::Interpolation::Tangent class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tangent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tangent, name)
    __swig_setmethods__["fType"] = _almathinternal.Tangent_fType_set
    __swig_getmethods__["fType"] = _almathinternal.Tangent_fType_get
    if _newclass:fType = _swig_property(_almathinternal.Tangent_fType_get, _almathinternal.Tangent_fType_set)
    __swig_setmethods__["fOffset"] = _almathinternal.Tangent_fOffset_set
    __swig_getmethods__["fOffset"] = _almathinternal.Tangent_fOffset_get
    if _newclass:fOffset = _swig_property(_almathinternal.Tangent_fOffset_get, _almathinternal.Tangent_fOffset_set)
    def __init__(self, *args): 
        """
        __init__(AL::Math::Interpolation::Tangent self) -> Tangent
        __init__(AL::Math::Interpolation::Tangent self, AL::Math::Interpolation::InterpolationType pType, Position2D pOffset) -> Tangent
        """
        this = _almathinternal.new_Tangent(*args)
        try: self.this.append(this)
        except: self.this = this
    def isNear(self, *args):
        """
        isNear(Tangent self, Tangent pTan2, float const & pEpsilon=0.0001) -> bool
        isNear(Tangent self, Tangent pTan2) -> bool
        """
        return _almathinternal.Tangent_isNear(self, *args)

    def __repr__(self):
        """__repr__(Tangent self) -> char *"""
        return _almathinternal.Tangent___repr__(self)

    __swig_destroy__ = _almathinternal.delete_Tangent
    __del__ = lambda self : None;
Tangent_swigregister = _almathinternal.Tangent_swigregister
Tangent_swigregister(Tangent)

class Key(_object):
    """Proxy of C++ AL::Math::Interpolation::Key class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Key, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Key, name)
    __swig_setmethods__["fValue"] = _almathinternal.Key_fValue_set
    __swig_getmethods__["fValue"] = _almathinternal.Key_fValue_get
    if _newclass:fValue = _swig_property(_almathinternal.Key_fValue_get, _almathinternal.Key_fValue_set)
    __swig_setmethods__["fLeftTangent"] = _almathinternal.Key_fLeftTangent_set
    __swig_getmethods__["fLeftTangent"] = _almathinternal.Key_fLeftTangent_get
    if _newclass:fLeftTangent = _swig_property(_almathinternal.Key_fLeftTangent_get, _almathinternal.Key_fLeftTangent_set)
    __swig_setmethods__["fRightTangent"] = _almathinternal.Key_fRightTangent_set
    __swig_getmethods__["fRightTangent"] = _almathinternal.Key_fRightTangent_get
    if _newclass:fRightTangent = _swig_property(_almathinternal.Key_fRightTangent_get, _almathinternal.Key_fRightTangent_set)
    def __init__(self, *args): 
        """
        __init__(AL::Math::Interpolation::Key self) -> Key
        __init__(AL::Math::Interpolation::Key self, float pValue) -> Key
        __init__(AL::Math::Interpolation::Key self, float const & pValue, Tangent pLeftTangent, Tangent pRightTangent) -> Key
        """
        this = _almathinternal.new_Key(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_Key
    __del__ = lambda self : None;
    def isNear(self, *args):
        """
        isNear(Key self, Key pTan2, float const & pEpsilon=0.0001) -> bool
        isNear(Key self, Key pTan2) -> bool
        """
        return _almathinternal.Key_isNear(self, *args)

    def __repr__(self):
        """__repr__(Key self) -> char *"""
        return _almathinternal.Key___repr__(self)

Key_swigregister = _almathinternal.Key_swigregister
Key_swigregister(Key)


def __lshift__(*args):
  """
    __lshift__(std::ostream & pStream, Tangent p) -> std::ostream
    __lshift__(std::ostream & pStream, Key p) -> std::ostream
    __lshift__(std::ostream & pStream, AL::Math::Interpolation::TALJointCommandPair const & p) -> std::ostream
    __lshift__(std::ostream & pStream, AL::Math::Interpolation::TALJointCommandVector const & p) -> std::ostream &
    """
  return _almathinternal.__lshift__(*args)

def checkVelocityMax(*args):
  """
    checkVelocityMax(AL::Math::Interpolation::TALJointCommandVector const & pVector, float const & pStartAngle, 
        float const & pMaxVelocity) -> float
    """
  return _almathinternal.checkVelocityMax(*args)
class ALInterpolationBezier(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationBezier class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationBezier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationBezier, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationBezier self) -> ALInterpolationBezier"""
        this = _almathinternal.new_ALInterpolationBezier()
        try: self.this.append(this)
        except: self.this = this
    def interpolate(self, *args):
        """
        interpolate(ALInterpolationBezier self, Position2D pP0, Position2D pP1, Position2D pP2, Position2D pP3, float pDt) -> vectorFloat
        interpolate(ALInterpolationBezier self, float pDuration, Key pFromKey, Key pToKey, float pDt) -> vectorFloat
        """
        return _almathinternal.ALInterpolationBezier_interpolate(self, *args)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationBezier
    __del__ = lambda self : None;
ALInterpolationBezier_swigregister = _almathinternal.ALInterpolationBezier_swigregister
ALInterpolationBezier_swigregister(ALInterpolationBezier)

class CubicBezierInverter(_object):
    """Proxy of C++ AL::Math::Interpolation::CubicBezierInverter class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CubicBezierInverter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CubicBezierInverter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::Interpolation::CubicBezierInverter self) -> CubicBezierInverter
        __init__(AL::Math::Interpolation::CubicBezierInverter self, float p0, float p1, float p2, float p3) -> CubicBezierInverter
        """
        this = _almathinternal.new_CubicBezierInverter(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """__call__(CubicBezierInverter self, float value) -> float"""
        return _almathinternal.CubicBezierInverter___call__(self, *args)

    __swig_destroy__ = _almathinternal.delete_CubicBezierInverter
    __del__ = lambda self : None;
CubicBezierInverter_swigregister = _almathinternal.CubicBezierInverter_swigregister
CubicBezierInverter_swigregister(CubicBezierInverter)


def updateBezierAutoTangents(*args):
  """
    updateBezierAutoTangents(int pCurrentIndex, Key pKey, int pLeftIndex, Key pLeftNeighbor, int pRightIndex, 
        Key pRightNeighbor) -> bool
    """
  return _almathinternal.updateBezierAutoTangents(*args)

def computeRightDerivativeOrder1AtKey(*args):
  """computeRightDerivativeOrder1AtKey(int pIndex, Key pKey, int pRightIndex, Key pRightNeighbor, vectorFloat pRes)"""
  return _almathinternal.computeRightDerivativeOrder1AtKey(*args)
class ALInterpolationArticular(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationArticular class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationArticular, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationArticular, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationArticular self) -> ALInterpolationArticular"""
        this = _almathinternal.new_ALInterpolationArticular()
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """
        init(ALInterpolationArticular self, vectorFloat pTime, vectorFloat pPoint, float const & pPeriod)
        init(ALInterpolationArticular self, float const & pTimeInit, float const & pTimeFinal, float const & pPointInit, float const & pPointFinal, 
            float const & pVelocityInit, float const & pVelocityFinal, 
            float const & pVelocityMaxAbs, bool const & pChangeTimeFinal, float const & pPeriod)
        init(ALInterpolationArticular self, float const & pTimeInit, float const & pTimeFinal, float const & pPointInit, float const & pPointFinal, 
            float const & pVelocityInit, float const & pVelocityFinal, 
            float const & pPeriod)
        init(ALInterpolationArticular self, vectorFloat pTime, vectorFloat pPoint, vectorFloat pVelocity, bool const & pIsHotStart, 
            float const & pPeriod)
        """
        return _almathinternal.ALInterpolationArticular_init(self, *args)

    def getCurrentInterpolation(self, *args):
        """
        getCurrentInterpolation(ALInterpolationArticular self, float const & pTimeCurrent, PositionAndVelocity pOut)
        getCurrentInterpolation(ALInterpolationArticular self, float const & pTimeCurrent) -> PositionAndVelocity
        """
        return _almathinternal.ALInterpolationArticular_getCurrentInterpolation(self, *args)

    def getAllInterpolation(self, *args):
        """getAllInterpolation(ALInterpolationArticular self, float const & dt_step) -> std::vector< AL::Math::PositionAndVelocity,std::allocator< AL::Math::PositionAndVelocity > >"""
        return _almathinternal.ALInterpolationArticular_getAllInterpolation(self, *args)

    def isFinished(self, *args):
        """isFinished(ALInterpolationArticular self, float const & time) -> bool"""
        return _almathinternal.ALInterpolationArticular_isFinished(self, *args)

    def setIsFinished(self, *args):
        """setIsFinished(ALInterpolationArticular self, bool pIsFinished)"""
        return _almathinternal.ALInterpolationArticular_setIsFinished(self, *args)

    def getNumTimesCalled(self):
        """getNumTimesCalled(ALInterpolationArticular self) -> unsigned int"""
        return _almathinternal.ALInterpolationArticular_getNumTimesCalled(self)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationArticular
    __del__ = lambda self : None;
ALInterpolationArticular_swigregister = _almathinternal.ALInterpolationArticular_swigregister
ALInterpolationArticular_swigregister(ALInterpolationArticular)

class ALInterpolationArticular3D(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationArticular3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationArticular3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationArticular3D, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationArticular3D self) -> ALInterpolationArticular3D"""
        this = _almathinternal.new_ALInterpolationArticular3D()
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """
        init(ALInterpolationArticular3D self, float const & pTimeInit, float const & pTimeFinal, Pose2D pPointInit, Pose2D pPointFinal, 
            Pose2D pVelocityInit, Pose2D pVelocityFinal, float const & pPeriod)
        """
        return _almathinternal.ALInterpolationArticular3D_init(self, *args)

    def getCurrentInterpolation(self, *args):
        """getCurrentInterpolation(ALInterpolationArticular3D self, float const & pTimeCurrent, Pose2D pPoint, Pose2D pVelocity)"""
        return _almathinternal.ALInterpolationArticular3D_getCurrentInterpolation(self, *args)

    def isFinished(self, *args):
        """isFinished(ALInterpolationArticular3D self, float const & time) -> bool"""
        return _almathinternal.ALInterpolationArticular3D_isFinished(self, *args)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationArticular3D
    __del__ = lambda self : None;
ALInterpolationArticular3D_swigregister = _almathinternal.ALInterpolationArticular3D_swigregister
ALInterpolationArticular3D_swigregister(ALInterpolationArticular3D)

class InterpolationTrapezoid(_object):
    """Proxy of C++ AL::Math::Interpolation::InterpolationTrapezoid class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterpolationTrapezoid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InterpolationTrapezoid, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::InterpolationTrapezoid self) -> InterpolationTrapezoid"""
        this = _almathinternal.new_InterpolationTrapezoid()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_InterpolationTrapezoid
    __del__ = lambda self : None;
    def getSmoothTrapezoid(self, *args):
        """
        getSmoothTrapezoid(InterpolationTrapezoid self, unsigned int const & pNumSamples, float const & pHeight, unsigned int const & pAttack, 
            unsigned int const & pDecay, vectorFloat pVectorResult)
        getSmoothTrapezoid(InterpolationTrapezoid self, unsigned int const & pNumSamples, float const & pHeight, unsigned int const & pAttack, 
            unsigned int const & pDecay) -> vectorFloat
        """
        return _almathinternal.InterpolationTrapezoid_getSmoothTrapezoid(self, *args)

InterpolationTrapezoid_swigregister = _almathinternal.InterpolationTrapezoid_swigregister
InterpolationTrapezoid_swigregister(InterpolationTrapezoid)

class ALInterpolationTrapezoidalAcceleration(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationTrapezoidalAcceleration class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationTrapezoidalAcceleration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationTrapezoidalAcceleration, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationTrapezoidalAcceleration self) -> ALInterpolationTrapezoidalAcceleration"""
        this = _almathinternal.new_ALInterpolationTrapezoidalAcceleration()
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """
        init(ALInterpolationTrapezoidalAcceleration self, float const & pVelocityInit, float const & pVelocityFinal, float const & pVelocityMaxAbs, 
            float const & pAccelerationInit, float const & pAccelerationMaxAbs, 
            float const & pJerkMaxAbs, float const & pPeriod)
        init(ALInterpolationTrapezoidalAcceleration self, VelAcc pStateInit, float pVelocityFinal, Limits pLimits, float pPeriod)
        """
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_init(self, *args)

    def getCurrentInterpolation(self, *args):
        """
        getCurrentInterpolation(ALInterpolationTrapezoidalAcceleration self, float pTime) -> VelAcc
        getCurrentInterpolation(ALInterpolationTrapezoidalAcceleration self, float pTime, VelAcc pResultVelAcc)
        """
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_getCurrentInterpolation(self, *args)

    def getCurrentJerk(self, *args):
        """getCurrentJerk(ALInterpolationTrapezoidalAcceleration self, float pTime) -> float"""
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_getCurrentJerk(self, *args)

    def getFinalTime(self):
        """getFinalTime(ALInterpolationTrapezoidalAcceleration self) -> float"""
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_getFinalTime(self)

    def setFinalTime(self, *args):
        """setFinalTime(ALInterpolationTrapezoidalAcceleration self, float const & pFinalTime)"""
        return _almathinternal.ALInterpolationTrapezoidalAcceleration_setFinalTime(self, *args)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationTrapezoidalAcceleration
    __del__ = lambda self : None;
ALInterpolationTrapezoidalAcceleration_swigregister = _almathinternal.ALInterpolationTrapezoidalAcceleration_swigregister
ALInterpolationTrapezoidalAcceleration_swigregister(ALInterpolationTrapezoidalAcceleration)

TRAPEZOIDSMOOTH_STATE_FINISHED = _almathinternal.TRAPEZOIDSMOOTH_STATE_FINISHED
TRAPEZOIDSMOOTH_STATE_INIT = _almathinternal.TRAPEZOIDSMOOTH_STATE_INIT
TRAPEZOIDSMOOTH_STATE_MID = _almathinternal.TRAPEZOIDSMOOTH_STATE_MID
TRAPEZOIDSMOOTH_STATE_END = _almathinternal.TRAPEZOIDSMOOTH_STATE_END
TRAPEZOIDSMOOTH_STATE_SIZE = _almathinternal.TRAPEZOIDSMOOTH_STATE_SIZE
class InterpolationTrapezoidSmooth(_object):
    """Proxy of C++ AL::Math::Interpolation::InterpolationTrapezoidSmooth class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterpolationTrapezoidSmooth, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InterpolationTrapezoidSmooth, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::Interpolation::InterpolationTrapezoidSmooth self) -> InterpolationTrapezoidSmooth
        __init__(AL::Math::Interpolation::InterpolationTrapezoidSmooth self, float const & pPeriod, unsigned int const & pNbStepMid, float const & pVelocityMax, 
            float const & pAccelerationMax) -> InterpolationTrapezoidSmooth
        __init__(AL::Math::Interpolation::InterpolationTrapezoidSmooth self, float const & pPeriod, unsigned int const & pNbStepMid, float const & pVelocityMax, 
            float const & pAccelerationMax, float const & pHeightMid, float const & pHeightEnd) -> InterpolationTrapezoidSmooth
        """
        this = _almathinternal.new_InterpolationTrapezoidSmooth(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_InterpolationTrapezoidSmooth
    __del__ = lambda self : None;
    def getAllInterpolation(self, *args):
        """
        getAllInterpolation(InterpolationTrapezoidSmooth self, vectorFloat pResult)
        getAllInterpolation(InterpolationTrapezoidSmooth self) -> vectorFloat
        """
        return _almathinternal.InterpolationTrapezoidSmooth_getAllInterpolation(self, *args)

    def init(self, *args):
        """init(InterpolationTrapezoidSmooth self, float const & pHeightMid, float const & pHeightEnd)"""
        return _almathinternal.InterpolationTrapezoidSmooth_init(self, *args)

    def restart(self):
        """restart(InterpolationTrapezoidSmooth self)"""
        return _almathinternal.InterpolationTrapezoidSmooth_restart(self)

    def getNextPosition(self):
        """getNextPosition(InterpolationTrapezoidSmooth self) -> float"""
        return _almathinternal.InterpolationTrapezoidSmooth_getNextPosition(self)

    def isFinished(self):
        """isFinished(InterpolationTrapezoidSmooth self) -> bool"""
        return _almathinternal.InterpolationTrapezoidSmooth_isFinished(self)

InterpolationTrapezoidSmooth_swigregister = _almathinternal.InterpolationTrapezoidSmooth_swigregister
InterpolationTrapezoidSmooth_swigregister(InterpolationTrapezoidSmooth)

class ALInterpolationTypeIV(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationTypeIV class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationTypeIV, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationTypeIV, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationTypeIV self) -> ALInterpolationTypeIV"""
        this = _almathinternal.new_ALInterpolationTypeIV()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_ALInterpolationTypeIV
    __del__ = lambda self : None;
    def init(self, *args):
        """
        init(ALInterpolationTypeIV self, PosVelAcc pInitialCondition, float const & pFinalPosition, float const & pFinalVelocity, 
            Limits pLimits, float const & pPeriod, float const & pFinalTime)
        init(ALInterpolationTypeIV self, PosVelAcc pInitialCondition, float const & pFinalPosition, float const & pFinalVelocity, 
            Limits pLimits, float const & pPeriod, bool const & pIsExact=False)
        init(ALInterpolationTypeIV self, PosVelAcc pInitialCondition, float const & pFinalPosition, float const & pFinalVelocity, 
            Limits pLimits, float const & pPeriod)
        """
        return _almathinternal.ALInterpolationTypeIV_init(self, *args)

    def setFinalTime(self, *args):
        """setFinalTime(ALInterpolationTypeIV self, float pFinalTime)"""
        return _almathinternal.ALInterpolationTypeIV_setFinalTime(self, *args)

    def getCurrentInterpolation(self, *args):
        """getCurrentInterpolation(ALInterpolationTypeIV self, float const & pTime) -> PosVelAcc"""
        return _almathinternal.ALInterpolationTypeIV_getCurrentInterpolation(self, *args)

    def getAllPositions(self):
        """getAllPositions(ALInterpolationTypeIV self) -> vectorFloat"""
        return _almathinternal.ALInterpolationTypeIV_getAllPositions(self)

    def getAllInterpolations(self):
        """getAllInterpolations(ALInterpolationTypeIV self) -> std::vector< AL::Math::PosVelAcc,std::allocator< AL::Math::PosVelAcc > >"""
        return _almathinternal.ALInterpolationTypeIV_getAllInterpolations(self)

    def getFinalTime(self):
        """getFinalTime(ALInterpolationTypeIV self) -> float"""
        return _almathinternal.ALInterpolationTypeIV_getFinalTime(self)

    def getMinimumTime(self):
        """getMinimumTime(ALInterpolationTypeIV self) -> float"""
        return _almathinternal.ALInterpolationTypeIV_getMinimumTime(self)

    def getInoperativeInterval(self):
        """getInoperativeInterval(ALInterpolationTypeIV self) -> std::pair< float,float >"""
        return _almathinternal.ALInterpolationTypeIV_getInoperativeInterval(self)

ALInterpolationTypeIV_swigregister = _almathinternal.ALInterpolationTypeIV_swigregister
ALInterpolationTypeIV_swigregister(ALInterpolationTypeIV)

class ALInterpolationTypeIV3D(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationTypeIV3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationTypeIV3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationTypeIV3D, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationTypeIV3D self) -> ALInterpolationTypeIV3D"""
        this = _almathinternal.new_ALInterpolationTypeIV3D()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_ALInterpolationTypeIV3D
    __del__ = lambda self : None;
    def init(self, *args):
        """
        init(ALInterpolationTypeIV3D self, Pose2D pPointInit, Pose2D pPointFinal, Pose2D pVelocityInit, Pose2D pVelocityFinal, 
            Pose2D pAccelerationInit, Limits pLimitsXY, Limits pLimitsTheta, float const & pPeriod)
        init(ALInterpolationTypeIV3D self, Pose2D pPointInit, Pose2D pPointFinal, Pose2D pVelocityInit, Pose2D pVelocityFinal, 
            Pose2D pAccelerationInit, Limits pLimitsXY, Limits pLimitsTheta, float const & pFinalTime, 
            float const & pPeriod)
        """
        return _almathinternal.ALInterpolationTypeIV3D_init(self, *args)

    def getCurrentInterpolation(self, *args):
        """getCurrentInterpolation(ALInterpolationTypeIV3D self, float const & pTimeCurrent, Pose2D pPoint, Pose2D pVelocity, Pose2D pAcceleration)"""
        return _almathinternal.ALInterpolationTypeIV3D_getCurrentInterpolation(self, *args)

    def getFinalTime(self):
        """getFinalTime(ALInterpolationTypeIV3D self) -> float"""
        return _almathinternal.ALInterpolationTypeIV3D_getFinalTime(self)

ALInterpolationTypeIV3D_swigregister = _almathinternal.ALInterpolationTypeIV3D_swigregister
ALInterpolationTypeIV3D_swigregister(ALInterpolationTypeIV3D)

class ALInterpolationQuinticSpline(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationQuinticSpline class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationQuinticSpline, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationQuinticSpline, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(AL::Math::Interpolation::ALInterpolationQuinticSpline self) -> ALInterpolationQuinticSpline"""
        this = _almathinternal.new_ALInterpolationQuinticSpline()
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """init(ALInterpolationQuinticSpline self, Limits pLimits, PosVelAcc pInitialCondition, PosVelAcc pFinaleCondition, float const & pPeriod)"""
        return _almathinternal.ALInterpolationQuinticSpline_init(self, *args)

    def getCurrentInterpolation(self, *args):
        """getCurrentInterpolation(ALInterpolationQuinticSpline self, float const & pTime) -> PosVelAcc"""
        return _almathinternal.ALInterpolationQuinticSpline_getCurrentInterpolation(self, *args)

    def getFinalTime(self):
        """getFinalTime(ALInterpolationQuinticSpline self) -> float"""
        return _almathinternal.ALInterpolationQuinticSpline_getFinalTime(self)

    def getMinimumTime(self):
        """getMinimumTime(ALInterpolationQuinticSpline self) -> float"""
        return _almathinternal.ALInterpolationQuinticSpline_getMinimumTime(self)

    def setFinalTime(self, *args):
        """setFinalTime(ALInterpolationQuinticSpline self, float const & pFinalTime)"""
        return _almathinternal.ALInterpolationQuinticSpline_setFinalTime(self, *args)

    def isFinished(self, *args):
        """isFinished(ALInterpolationQuinticSpline self, float const & pTime) -> bool"""
        return _almathinternal.ALInterpolationQuinticSpline_isFinished(self, *args)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationQuinticSpline
    __del__ = lambda self : None;
ALInterpolationQuinticSpline_swigregister = _almathinternal.ALInterpolationQuinticSpline_swigregister
ALInterpolationQuinticSpline_swigregister(ALInterpolationQuinticSpline)

class ALInterpolationBangBangAcceleration(_object):
    """Proxy of C++ AL::Math::Interpolation::ALInterpolationBangBangAcceleration class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALInterpolationBangBangAcceleration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALInterpolationBangBangAcceleration, name)
    __repr__ = _swig_repr
    DefaultPolicy = _almathinternal.ALInterpolationBangBangAcceleration_DefaultPolicy
    InitialSlowingDown = _almathinternal.ALInterpolationBangBangAcceleration_InitialSlowingDown
    AlwaysUseMaxAcc = _almathinternal.ALInterpolationBangBangAcceleration_AlwaysUseMaxAcc
    def __init__(self, *args): 
        """
        __init__(AL::Math::Interpolation::ALInterpolationBangBangAcceleration self) -> ALInterpolationBangBangAcceleration
        __init__(AL::Math::Interpolation::ALInterpolationBangBangAcceleration self, float pPositionFinal, Limits pLimits, AL::Math::Interpolation::ALInterpolationBangBangAcceleration::Policy pPolicy=DefaultPolicy) -> ALInterpolationBangBangAcceleration
        __init__(AL::Math::Interpolation::ALInterpolationBangBangAcceleration self, float pPositionFinal, Limits pLimits) -> ALInterpolationBangBangAcceleration
        """
        this = _almathinternal.new_ALInterpolationBangBangAcceleration(*args)
        try: self.this.append(this)
        except: self.this = this
    def init(self, *args):
        """
        init(ALInterpolationBangBangAcceleration self, float pPositionInit, float pPositionFinal, float pVelocityInit, Limits pLimits, AL::Math::Interpolation::ALInterpolationBangBangAcceleration::Policy pPolicy=DefaultPolicy)
        init(ALInterpolationBangBangAcceleration self, float pPositionInit, float pPositionFinal, float pVelocityInit, Limits pLimits)
        """
        return _almathinternal.ALInterpolationBangBangAcceleration_init(self, *args)

    def setInitStateOrder1(self, *args):
        """setInitStateOrder1(ALInterpolationBangBangAcceleration self, float pPositionInit, float VelocityInit)"""
        return _almathinternal.ALInterpolationBangBangAcceleration_setInitStateOrder1(self, *args)

    def getCurrentInterpolation(self, *args):
        """
        getCurrentInterpolation(ALInterpolationBangBangAcceleration self, float pTime, PosVelAcc pResult)
        getCurrentInterpolation(ALInterpolationBangBangAcceleration self, float pTime) -> PosVelAcc
        """
        return _almathinternal.ALInterpolationBangBangAcceleration_getCurrentInterpolation(self, *args)

    def getDuration(self):
        """getDuration(ALInterpolationBangBangAcceleration self) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration_getDuration(self)

    def getFinalTime(self):
        """getFinalTime(ALInterpolationBangBangAcceleration self) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration_getFinalTime(self)

    def getDerivativeOrder(self):
        """getDerivativeOrder(ALInterpolationBangBangAcceleration self) -> unsigned int"""
        return _almathinternal.ALInterpolationBangBangAcceleration_getDerivativeOrder(self)

    def getMinimumTime(self):
        """getMinimumTime(ALInterpolationBangBangAcceleration self) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration_getMinimumTime(self)

    def setFinalTime(self, *args):
        """setFinalTime(ALInterpolationBangBangAcceleration self, float pFinalTime)"""
        return _almathinternal.ALInterpolationBangBangAcceleration_setFinalTime(self, *args)

    def __call__(self, *args):
        """__call__(ALInterpolationBangBangAcceleration self, float pTime) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration___call__(self, *args)

    def duration(self):
        """duration(ALInterpolationBangBangAcceleration self) -> float"""
        return _almathinternal.ALInterpolationBangBangAcceleration_duration(self)

    __swig_destroy__ = _almathinternal.delete_ALInterpolationBangBangAcceleration
    __del__ = lambda self : None;
ALInterpolationBangBangAcceleration_swigregister = _almathinternal.ALInterpolationBangBangAcceleration_swigregister
ALInterpolationBangBangAcceleration_swigregister(ALInterpolationBangBangAcceleration)


def setDuration(*args):
  """setDuration(ALInterpolationBangBangAcceleration pObject, float pDuration)"""
  return _almathinternal.setDuration(*args)
class BezierSequence(_object):
    """Proxy of C++ AL::Math::Interpolation::BezierSequence class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BezierSequence, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BezierSequence, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::Interpolation::BezierSequence self, float pPeriod) -> BezierSequence
        __init__(AL::Math::Interpolation::BezierSequence self, BezierSequence other) -> BezierSequence
        """
        this = _almathinternal.new_BezierSequence(*args)
        try: self.this.append(this)
        except: self.this = this
    def setInitState(self, *args):
        """setInitState(BezierSequence self, vectorFloat pInitState)"""
        return _almathinternal.BezierSequence_setInitState(self, *args)

    def addKey(self, *args):
        """
        addKey(BezierSequence self, float pTime, Key pKey)
        addKey(BezierSequence self, AL::Math::Interpolation::TALJointCommandPair const & pKeyAtTime)
        """
        return _almathinternal.BezierSequence_addKey(self, *args)

    def addMultipleKeys(self, *args):
        """addMultipleKeys(BezierSequence self, AL::Math::Interpolation::TALJointCommandVector const & pKeysAtTimes)"""
        return _almathinternal.BezierSequence_addMultipleKeys(self, *args)

    def getDuration(self):
        """getDuration(BezierSequence self) -> float"""
        return _almathinternal.BezierSequence_getDuration(self)

    def duration(self):
        """duration(BezierSequence self) -> float"""
        return _almathinternal.BezierSequence_duration(self)

    def __call__(self, *args):
        """__call__(BezierSequence self, float pTime) -> float"""
        return _almathinternal.BezierSequence___call__(self, *args)

    def getDerivativeOrder(self):
        """getDerivativeOrder(BezierSequence self) -> unsigned int"""
        return _almathinternal.BezierSequence_getDerivativeOrder(self)

    __swig_destroy__ = _almathinternal.delete_BezierSequence
    __del__ = lambda self : None;
BezierSequence_swigregister = _almathinternal.BezierSequence_swigregister
BezierSequence_swigregister(BezierSequence)


def setInitStateOrder1(*args):
  """
    setInitStateOrder1(ALInterpolationBangBangAcceleration pObject, float pPos, float pVel)
    setInitStateOrder1(BezierSequence pObject, float pPos, float pVel)
    """
  return _almathinternal.setInitStateOrder1(*args)
class Limits(_object):
    """Proxy of C++ AL::Math::Limits class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Limits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Limits, name)
    __repr__ = _swig_repr
    __swig_setmethods__["maxJerk"] = _almathinternal.Limits_maxJerk_set
    __swig_getmethods__["maxJerk"] = _almathinternal.Limits_maxJerk_get
    if _newclass:maxJerk = _swig_property(_almathinternal.Limits_maxJerk_get, _almathinternal.Limits_maxJerk_set)
    __swig_setmethods__["maxAcc"] = _almathinternal.Limits_maxAcc_set
    __swig_getmethods__["maxAcc"] = _almathinternal.Limits_maxAcc_get
    if _newclass:maxAcc = _swig_property(_almathinternal.Limits_maxAcc_get, _almathinternal.Limits_maxAcc_set)
    __swig_setmethods__["maxVel"] = _almathinternal.Limits_maxVel_set
    __swig_getmethods__["maxVel"] = _almathinternal.Limits_maxVel_get
    if _newclass:maxVel = _swig_property(_almathinternal.Limits_maxVel_get, _almathinternal.Limits_maxVel_set)
    def __init__(self, *args): 
        """
        __init__(AL::Math::Limits self) -> Limits
        __init__(AL::Math::Limits self, float const & pMaxJerk, float const & pMaxAcc, float const & pMaxVel) -> Limits
        """
        this = _almathinternal.new_Limits(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_Limits
    __del__ = lambda self : None;
Limits_swigregister = _almathinternal.Limits_swigregister
Limits_swigregister(Limits)


def checkLimits(*args):
  """checkLimits(Limits pLimits, float const pEpsilon) -> bool"""
  return _almathinternal.checkLimits(*args)
class PosVelAcc(_object):
    """Proxy of C++ AL::Math::PosVelAcc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PosVelAcc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PosVelAcc, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _almathinternal.PosVelAcc_x_set
    __swig_getmethods__["x"] = _almathinternal.PosVelAcc_x_get
    if _newclass:x = _swig_property(_almathinternal.PosVelAcc_x_get, _almathinternal.PosVelAcc_x_set)
    __swig_setmethods__["dx"] = _almathinternal.PosVelAcc_dx_set
    __swig_getmethods__["dx"] = _almathinternal.PosVelAcc_dx_get
    if _newclass:dx = _swig_property(_almathinternal.PosVelAcc_dx_get, _almathinternal.PosVelAcc_dx_set)
    __swig_setmethods__["ddx"] = _almathinternal.PosVelAcc_ddx_set
    __swig_getmethods__["ddx"] = _almathinternal.PosVelAcc_ddx_get
    if _newclass:ddx = _swig_property(_almathinternal.PosVelAcc_ddx_get, _almathinternal.PosVelAcc_ddx_set)
    def __init__(self, px=0.0, pdx=0.0, pddx=0.0): 
        """
        __init__(AL::Math::PosVelAcc self, float const px=0.0, float const pdx=0.0, float const pddx=0.0) -> PosVelAcc
        __init__(AL::Math::PosVelAcc self, float const px=0.0, float const pdx=0.0) -> PosVelAcc
        __init__(AL::Math::PosVelAcc self, float const px=0.0) -> PosVelAcc
        __init__(AL::Math::PosVelAcc self) -> PosVelAcc
        """
        this = _almathinternal.new_PosVelAcc(px, pdx, pddx)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___sub__(self, *args)

    def __pos__(self):
        """__pos__(PosVelAcc self) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___pos__(self)

    def __neg__(self):
        """__neg__(PosVelAcc self) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___neg__(self)

    def __iadd__(self, *args):
        """__iadd__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(PosVelAcc self, PosVelAcc pPos2) -> PosVelAcc"""
        return _almathinternal.PosVelAcc___isub__(self, *args)

    def isNear(self, *args):
        """
        isNear(PosVelAcc self, PosVelAcc pDat2, float const & pEpsilon=0.0001) -> bool
        isNear(PosVelAcc self, PosVelAcc pDat2) -> bool
        """
        return _almathinternal.PosVelAcc_isNear(self, *args)

    __swig_destroy__ = _almathinternal.delete_PosVelAcc
    __del__ = lambda self : None;
PosVelAcc_swigregister = _almathinternal.PosVelAcc_swigregister
PosVelAcc_swigregister(PosVelAcc)

class Pose2DAndTime(_object):
    """Proxy of C++ AL::Math::Pose2DAndTime class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pose2DAndTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pose2DAndTime, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pose2D"] = _almathinternal.Pose2DAndTime_pose2D_set
    __swig_getmethods__["pose2D"] = _almathinternal.Pose2DAndTime_pose2D_get
    if _newclass:pose2D = _swig_property(_almathinternal.Pose2DAndTime_pose2D_get, _almathinternal.Pose2DAndTime_pose2D_set)
    __swig_setmethods__["t"] = _almathinternal.Pose2DAndTime_t_set
    __swig_getmethods__["t"] = _almathinternal.Pose2DAndTime_t_get
    if _newclass:t = _swig_property(_almathinternal.Pose2DAndTime_t_get, _almathinternal.Pose2DAndTime_t_set)
    def __init__(self, *args): 
        """
        __init__(AL::Math::Pose2DAndTime self, Pose2D pPose2D=AL::Math::Pose2D(), float const pT=0.0) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self, Pose2D pPose2D=AL::Math::Pose2D()) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self, float const pX, float const pY, float const pTheta, float const pT) -> Pose2DAndTime
        __init__(AL::Math::Pose2DAndTime self, vectorFloat pFloats) -> Pose2DAndTime
        """
        this = _almathinternal.new_Pose2DAndTime(*args)
        try: self.this.append(this)
        except: self.this = this
    def isNear(self, *args):
        """
        isNear(Pose2DAndTime self, Pose2DAndTime pDat, float const & pEpsilon=0.0001) -> bool
        isNear(Pose2DAndTime self, Pose2DAndTime pDat) -> bool
        """
        return _almathinternal.Pose2DAndTime_isNear(self, *args)

    def toVector(self, *args):
        """
        toVector(Pose2DAndTime self, vectorFloat pReturnVector)
        toVector(Pose2DAndTime self) -> vectorFloat
        """
        return _almathinternal.Pose2DAndTime_toVector(self, *args)

    __swig_destroy__ = _almathinternal.delete_Pose2DAndTime
    __del__ = lambda self : None;
Pose2DAndTime_swigregister = _almathinternal.Pose2DAndTime_swigregister
Pose2DAndTime_swigregister(Pose2DAndTime)

class VelAcc(_object):
    """Proxy of C++ AL::Math::VelAcc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VelAcc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VelAcc, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dq"] = _almathinternal.VelAcc_dq_set
    __swig_getmethods__["dq"] = _almathinternal.VelAcc_dq_get
    if _newclass:dq = _swig_property(_almathinternal.VelAcc_dq_get, _almathinternal.VelAcc_dq_set)
    __swig_setmethods__["ddq"] = _almathinternal.VelAcc_ddq_set
    __swig_getmethods__["ddq"] = _almathinternal.VelAcc_ddq_get
    if _newclass:ddq = _swig_property(_almathinternal.VelAcc_ddq_get, _almathinternal.VelAcc_ddq_set)
    def __init__(self, pdq=0.0, pddq=0.0): 
        """
        __init__(AL::Math::VelAcc self, float const pdq=0.0, float const pddq=0.0) -> VelAcc
        __init__(AL::Math::VelAcc self, float const pdq=0.0) -> VelAcc
        __init__(AL::Math::VelAcc self) -> VelAcc
        """
        this = _almathinternal.new_VelAcc(pdq, pddq)
        try: self.this.append(this)
        except: self.this = this
    def isNear(self, *args):
        """
        isNear(VelAcc self, VelAcc pDat2, float const & pEpsilon=0.0001) -> bool
        isNear(VelAcc self, VelAcc pDat2) -> bool
        """
        return _almathinternal.VelAcc_isNear(self, *args)

    __swig_destroy__ = _almathinternal.delete_VelAcc
    __del__ = lambda self : None;
VelAcc_swigregister = _almathinternal.VelAcc_swigregister
VelAcc_swigregister(VelAcc)

class PosVelTime(_object):
    """Proxy of C++ AL::Math::PosVelTime class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PosVelTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PosVelTime, name)
    __repr__ = _swig_repr
    __swig_setmethods__["posVel"] = _almathinternal.PosVelTime_posVel_set
    __swig_getmethods__["posVel"] = _almathinternal.PosVelTime_posVel_get
    if _newclass:posVel = _swig_property(_almathinternal.PosVelTime_posVel_get, _almathinternal.PosVelTime_posVel_set)
    __swig_setmethods__["t"] = _almathinternal.PosVelTime_t_set
    __swig_getmethods__["t"] = _almathinternal.PosVelTime_t_get
    if _newclass:t = _swig_property(_almathinternal.PosVelTime_t_get, _almathinternal.PosVelTime_t_set)
    def __init__(self, *args): 
        """
        __init__(AL::Math::PosVelTime self, PositionAndVelocity pPosVel=AL::Math::PositionAndVelocity(), float const pT=0.0) -> PosVelTime
        __init__(AL::Math::PosVelTime self, PositionAndVelocity pPosVel=AL::Math::PositionAndVelocity()) -> PosVelTime
        __init__(AL::Math::PosVelTime self) -> PosVelTime
        __init__(AL::Math::PosVelTime self, float const pq, float const pdq, float const pT) -> PosVelTime
        __init__(AL::Math::PosVelTime self, vectorFloat pFloats) -> PosVelTime
        """
        this = _almathinternal.new_PosVelTime(*args)
        try: self.this.append(this)
        except: self.this = this
    def isNear(self, *args):
        """
        isNear(PosVelTime self, PosVelTime pDat, float const & pEpsilon=0.0001) -> bool
        isNear(PosVelTime self, PosVelTime pDat) -> bool
        """
        return _almathinternal.PosVelTime_isNear(self, *args)

    def toVector(self, *args):
        """
        toVector(PosVelTime self, vectorFloat pReturnVector)
        toVector(PosVelTime self) -> vectorFloat
        """
        return _almathinternal.PosVelTime_toVector(self, *args)

    __swig_destroy__ = _almathinternal.delete_PosVelTime
    __del__ = lambda self : None;
PosVelTime_swigregister = _almathinternal.PosVelTime_swigregister
PosVelTime_swigregister(PosVelTime)


def computePose2DTwoObject(*args):
  """computePose2DTwoObject(Position3D pFirst, Position3D pSecond, Pose2D pRes)"""
  return _almathinternal.computePose2DTwoObject(*args)

def computeFrameToObject(*args):
  """
    computeFrameToObject(Transform pFrameToCam, float const & pDistance, float const & pWy, float const & pWz, 
        Position6D pResult)
    computeFrameToObject(Transform pFrameToCam, float const & pDistance, float const & pWy, float const & pWz) -> Position6D
    """
  return _almathinternal.computeFrameToObject(*args)

def computePointAtShoulderWy(*args):
  """
    computePointAtShoulderWy(Position3D pShoulderToObject, Transform pShoulderToElbow, float & pShoulderWy)
    computePointAtShoulderWy(Position3D pShoulderToObject, Transform pShoulderToElbow, vectorFloat pShoulderWy)
    """
  return _almathinternal.computePointAtShoulderWy(*args)

def computePointAtShoulderWz(*args):
  """
    computePointAtShoulderWz(Position3D pShoulderToObject, Transform pShoulderToElbow, float & pShoulderWz)
    computePointAtShoulderWz(Position3D pShoulderToObject, Transform pShoulderToElbow, vectorFloat pShoulderWz)
    """
  return _almathinternal.computePointAtShoulderWz(*args)

def computePointAtAnglesWyWz(*args):
  """computePointAtAnglesWyWz(Position3D pShoulderToObject, Position3D pShoulderToElbow, float & pShoulderWy, float & pShoulderWz)"""
  return _almathinternal.computePointAtAnglesWyWz(*args)

def oldComputePointAtAnglesWyWz(*args):
  """oldComputePointAtAnglesWyWz(Position3D pShoulderToObject, float & pShoulderWy, float & pShoulderWz)"""
  return _almathinternal.oldComputePointAtAnglesWyWz(*args)

def choosePointAtSolution(*args):
  """
    choosePointAtSolution(Position3D pShoulderToObject, Position3D pShoulderToElbow, vectorFloat pWySolution, 
        vectorFloat pWzSolution0, vectorFloat pWzSolution1, float & pShoulderWy, 
        float & pShoulderWz)
    """
  return _almathinternal.choosePointAtSolution(*args)

def computeLookAtAngles(*args):
  """
    computeLookAtAngles(Position3D pTorsoToTarget, Position3D pTorsoToNeck, Transform pNeckToEffector, float & pHeadWz, 
        float & pHeadWy) -> bool
    """
  return _almathinternal.computeLookAtAngles(*args)
class ALPath2DVisitor(_object):
    """Proxy of C++ AL::Math::Trajectory::ALPath2DVisitor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALPath2DVisitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALPath2DVisitor, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def visit(self, *args):
        """
        visit(ALPath2DVisitor self, AL::Math::Trajectory::ALPath2DStraightLine const & pLine)
        visit(ALPath2DVisitor self, AL::Math::Trajectory::ALPath2DArcOfCircle const & pCircle)
        visit(ALPath2DVisitor self, ALPath2DComposed pComposed)
        visit(ALPath2DVisitor self, ALPath2DFlat pFlat)
        """
        return _almathinternal.ALPath2DVisitor_visit(self, *args)

    __swig_destroy__ = _almathinternal.delete_ALPath2DVisitor
    __del__ = lambda self : None;
ALPath2DVisitor_swigregister = _almathinternal.ALPath2DVisitor_swigregister
ALPath2DVisitor_swigregister(ALPath2DVisitor)

class ALPath2D(_object):
    """Proxy of C++ AL::Math::Trajectory::ALPath2D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALPath2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ALPath2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def clone(self):
        """clone(ALPath2D self) -> ALPath2D"""
        return _almathinternal.ALPath2D_clone(self)

    __swig_destroy__ = _almathinternal.delete_ALPath2D
    __del__ = lambda self : None;
    def length(self):
        """length(ALPath2D self) -> float"""
        return _almathinternal.ALPath2D_length(self)

    def positionAtLengthInPlace(self, *args):
        """positionAtLengthInPlace(ALPath2D self, float pLength, Position2D pResultPosition)"""
        return _almathinternal.ALPath2D_positionAtLengthInPlace(self, *args)

    def positionAtLength(self, *args):
        """positionAtLength(ALPath2D self, float pLength) -> Position2D"""
        return _almathinternal.ALPath2D_positionAtLength(self, *args)

    def initialPosition(self):
        """initialPosition(ALPath2D self) -> Position2D"""
        return _almathinternal.ALPath2D_initialPosition(self)

    def finalPosition(self):
        """finalPosition(ALPath2D self) -> Position2D"""
        return _almathinternal.ALPath2D_finalPosition(self)

    def windingAngleAtLength(self, *args):
        """windingAngleAtLength(ALPath2D self, float pLength) -> float"""
        return _almathinternal.ALPath2D_windingAngleAtLength(self, *args)

    def getAllDerivativesAtLength(self, *args):
        """
        getAllDerivativesAtLength(ALPath2D self, float pLength, Position2D pPositionResult, Position2D pTangentResult, float & pCurvatureResult, 
            float & pCurvatureDerivativeResult)
        """
        return _almathinternal.ALPath2D_getAllDerivativesAtLength(self, *args)

    def maxCurvature(self):
        """maxCurvature(ALPath2D self) -> float"""
        return _almathinternal.ALPath2D_maxCurvature(self)

    def maxCurvatureInInterval(self, *args):
        """maxCurvatureInInterval(ALPath2D self, float pLengthMin, float pLengthMax) -> float"""
        return _almathinternal.ALPath2D_maxCurvatureInInterval(self, *args)

    def cloneEnd(self, *args):
        """cloneEnd(ALPath2D self, float pDistance) -> ALPath2D"""
        return _almathinternal.ALPath2D_cloneEnd(self, *args)

    def accept(self, *args):
        """accept(ALPath2D self, ALPath2DVisitor pVisitor)"""
        return _almathinternal.ALPath2D_accept(self, *args)

ALPath2D_swigregister = _almathinternal.ALPath2D_swigregister
ALPath2D_swigregister(ALPath2D)

class ALDirectPath2D(ALPath2D):
    """Proxy of C++ AL::Math::Trajectory::ALDirectPath2D class"""
    __swig_setmethods__ = {}
    for _s in [ALPath2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALDirectPath2D, name, value)
    __swig_getmethods__ = {}
    for _s in [ALPath2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ALDirectPath2D, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _almathinternal.delete_ALDirectPath2D
    __del__ = lambda self : None;
    def clone(self):
        """clone(ALDirectPath2D self) -> ALDirectPath2D"""
        return _almathinternal.ALDirectPath2D_clone(self)

    def cloneEnd(self, *args):
        """cloneEnd(ALDirectPath2D self, float pDistance) -> ALDirectPath2D"""
        return _almathinternal.ALDirectPath2D_cloneEnd(self, *args)

ALDirectPath2D_swigregister = _almathinternal.ALDirectPath2D_swigregister
ALDirectPath2D_swigregister(ALDirectPath2D)

class ALPath2DFlat(ALDirectPath2D):
    """Proxy of C++ AL::Math::Trajectory::ALPath2DFlat class"""
    __swig_setmethods__ = {}
    for _s in [ALDirectPath2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALPath2DFlat, name, value)
    __swig_getmethods__ = {}
    for _s in [ALDirectPath2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ALPath2DFlat, name)
    __repr__ = _swig_repr
    def __init__(self, pNbSamples=100): 
        """
        __init__(AL::Math::Trajectory::ALPath2DFlat self, unsigned int pNbSamples=100) -> ALPath2DFlat
        __init__(AL::Math::Trajectory::ALPath2DFlat self) -> ALPath2DFlat
        """
        this = _almathinternal.new_ALPath2DFlat(pNbSamples)
        try: self.this.append(this)
        except: self.this = this
    def clone(self):
        """clone(ALPath2DFlat self) -> ALPath2DFlat"""
        return _almathinternal.ALPath2DFlat_clone(self)

    def cloneEnd(self, *args):
        """cloneEnd(ALPath2DFlat self, float pDistance) -> ALPath2DFlat"""
        return _almathinternal.ALPath2DFlat_cloneEnd(self, *args)

    def init(self, *args):
        """
        init(ALPath2DFlat self, Position2D pPointInit, Position2D pTangentInit, float pCurvatureInit, Position2D pPointFinal, 
            Position2D pTangentFinal, float pCurvatureFinal)
        """
        return _almathinternal.ALPath2DFlat_init(self, *args)

    def length(self):
        """length(ALPath2DFlat self) -> float"""
        return _almathinternal.ALPath2DFlat_length(self)

    def positionAtLengthInPlace(self, *args):
        """positionAtLengthInPlace(ALPath2DFlat self, float pLength, Position2D pPositionResult)"""
        return _almathinternal.ALPath2DFlat_positionAtLengthInPlace(self, *args)

    def getAllDerivativesAtLength(self, *args):
        """
        getAllDerivativesAtLength(ALPath2DFlat self, float pLength, Position2D pPositionResult, Position2D pTangentResult, float & pCurvatureResult, 
            float & pCurvatureDerivativeResult)
        """
        return _almathinternal.ALPath2DFlat_getAllDerivativesAtLength(self, *args)

    def maxCurvature(self):
        """maxCurvature(ALPath2DFlat self) -> float"""
        return _almathinternal.ALPath2DFlat_maxCurvature(self)

    def maxCurvatureInInterval(self, *args):
        """maxCurvatureInInterval(ALPath2DFlat self, float pLengthMin, float pLengthMax) -> float"""
        return _almathinternal.ALPath2DFlat_maxCurvatureInInterval(self, *args)

    def windingAngleAtLength(self, *args):
        """windingAngleAtLength(ALPath2DFlat self, float pLength) -> float"""
        return _almathinternal.ALPath2DFlat_windingAngleAtLength(self, *args)

    def accept(self, *args):
        """accept(ALPath2DFlat self, ALPath2DVisitor pVisitor)"""
        return _almathinternal.ALPath2DFlat_accept(self, *args)

    def getTangentInit(self):
        """getTangentInit(ALPath2DFlat self) -> Position2D"""
        return _almathinternal.ALPath2DFlat_getTangentInit(self)

    def getTangentFinal(self):
        """getTangentFinal(ALPath2DFlat self) -> Position2D"""
        return _almathinternal.ALPath2DFlat_getTangentFinal(self)

    def getCurvatureInit(self):
        """getCurvatureInit(ALPath2DFlat self) -> float"""
        return _almathinternal.ALPath2DFlat_getCurvatureInit(self)

    def getCurvatureFinal(self):
        """getCurvatureFinal(ALPath2DFlat self) -> float"""
        return _almathinternal.ALPath2DFlat_getCurvatureFinal(self)

    __swig_destroy__ = _almathinternal.delete_ALPath2DFlat
    __del__ = lambda self : None;
ALPath2DFlat_swigregister = _almathinternal.ALPath2DFlat_swigregister
ALPath2DFlat_swigregister(ALPath2DFlat)

class ALPath2DComposed(ALPath2D):
    """Proxy of C++ AL::Math::Trajectory::ALPath2DComposed class"""
    __swig_setmethods__ = {}
    for _s in [ALPath2D]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ALPath2DComposed, name, value)
    __swig_getmethods__ = {}
    for _s in [ALPath2D]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ALPath2DComposed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(AL::Math::Trajectory::ALPath2DComposed self) -> ALPath2DComposed
        __init__(AL::Math::Trajectory::ALPath2DComposed self, ALPath2DComposed pPath) -> ALPath2DComposed
        """
        this = _almathinternal.new_ALPath2DComposed(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almathinternal.delete_ALPath2DComposed
    __del__ = lambda self : None;
    def clone(self):
        """clone(ALPath2DComposed self) -> ALPath2DComposed"""
        return _almathinternal.ALPath2DComposed_clone(self)

    def append(self, *args):
        """append(ALPath2DComposed self, ALDirectPath2D pDirectPath)"""
        return _almathinternal.ALPath2DComposed_append(self, *args)

    def pop(self):
        """pop(ALPath2DComposed self)"""
        return _almathinternal.ALPath2DComposed_pop(self)

    def replace(self, *args):
        """replace(ALPath2DComposed self, size_t i, ALDirectPath2D pDirectPath)"""
        return _almathinternal.ALPath2DComposed_replace(self, *args)

    def length(self):
        """length(ALPath2DComposed self) -> float"""
        return _almathinternal.ALPath2DComposed_length(self)

    def windingAngleAtLength(self, *args):
        """windingAngleAtLength(ALPath2DComposed self, float pLength) -> float"""
        return _almathinternal.ALPath2DComposed_windingAngleAtLength(self, *args)

    def getAllDerivativesAtLength(self, *args):
        """
        getAllDerivativesAtLength(ALPath2DComposed self, float pLength, Position2D pPositionResult, Position2D pTangentResult, float & pCurvatureResult, 
            float & pCurvatureDerivativeResult)
        """
        return _almathinternal.ALPath2DComposed_getAllDerivativesAtLength(self, *args)

    def positionAtLengthInPlace(self, *args):
        """positionAtLengthInPlace(ALPath2DComposed self, float pLength, Position2D pResultPosition)"""
        return _almathinternal.ALPath2DComposed_positionAtLengthInPlace(self, *args)

    def maxCurvature(self):
        """maxCurvature(ALPath2DComposed self) -> float"""
        return _almathinternal.ALPath2DComposed_maxCurvature(self)

    def maxCurvatureInInterval(self, *args):
        """maxCurvatureInInterval(ALPath2DComposed self, float pLengthMin, float pLengthMax) -> float"""
        return _almathinternal.ALPath2DComposed_maxCurvatureInInterval(self, *args)

    def empty(self):
        """empty(ALPath2DComposed self) -> bool"""
        return _almathinternal.ALPath2DComposed_empty(self)

    def size(self):
        """size(ALPath2DComposed self) -> size_t"""
        return _almathinternal.ALPath2DComposed_size(self)

    def cloneEnd(self, *args):
        """cloneEnd(ALPath2DComposed self, float pLength) -> ALPath2D"""
        return _almathinternal.ALPath2DComposed_cloneEnd(self, *args)

    def accept(self, *args):
        """accept(ALPath2DComposed self, ALPath2DVisitor pVisitor)"""
        return _almathinternal.ALPath2DComposed_accept(self, *args)

    def approximateWithFlatPaths(self, *args):
        """
        approximateWithFlatPaths(ALPath2DComposed self, Position2D pPointInit, Position2D pPointFinal, Position2D pTangentInit, Position2D pTangentFinal, 
            vectorPosition2D pPoints, vectorFloat pTolerances, bool pUseTangentInit, 
            bool pUseTangentFinal)
        """
        return _almathinternal.ALPath2DComposed_approximateWithFlatPaths(self, *args)

ALPath2DComposed_swigregister = _almathinternal.ALPath2DComposed_swigregister
ALPath2DComposed_swigregister(ALPath2DComposed)

# This file is compatible with both classic and new-style classes.


