<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>qi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div class="related">
  <ul>
    <!-- <li style="margin-right: 10px" class="right"> -->
    <!--   <a accesskey="I" title="General Index" href="genindex.html">index</a> -->
    <!-- </li> -->
    <!-- <li class="right"> -->
    <!--   <a accesskey="N" title="Whatâ€™s new?" href="news/whatsnew/index.html">next</a> | -->
    <!-- </li> -->
    <li><a href="../../index.html">Aldebaran documentation</a> |</li>
    <li><a href="../../ref/cpp-api.html">C++ Libraries</a> |</li>
    <li><a href="index.html">index</a></li>
  </ul>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqi-api
   &#160;<span id="projectnumber">2.8.2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Deprecated in 2.5. Use int8_t from &lt;cstdint&gt;.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceqi_1_1concept"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1concept.html">concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1log"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1log.html">log</a></td></tr>
<tr class="memdesc:namespaceqi_1_1log"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log functions with different levels of verbosity. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1measure"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1measure.html">measure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1os"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1os.html">os</a></td></tr>
<tr class="memdesc:namespaceqi_1_1os"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS abstraction layer. . <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1path"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1path.html">path</a></td></tr>
<tr class="memdesc:namespaceqi_1_1path"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of tools to handle SDK layouts. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1sock"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1sock.html">sock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespaceqi_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains anything related to compile-time type manipulation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1version"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1version.html">version</a></td></tr>
<tr class="memdesc:namespaceqi_1_1version"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqi_1_1version_1_1Version.html" title="Compare version strings Simple class that allow comparing two version number. ">Version</a> numbering API. . <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqi_1_1vs13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi_1_1vs13.html">vs13</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Actor.html">Actor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1VarArguments.html">VarArguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1VarArguments_3_01AnyValue_01_4.html">VarArguments&lt; AnyValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1CallableTypeInterface.html">CallableTypeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqi_1_1Signature.html">Signature</a> information for both callable types <a class="el" href="classqi_1_1FunctionTypeInterface.html">FunctionTypeInterface</a> and MethodType.  <a href="classqi_1_1CallableTypeInterface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FunctionTypeInterface.html">FunctionTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ArgumentTransformation.html">ArgumentTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1KeywordArguments.html">KeywordArguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AnyArguments.html">AnyArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function with <a class="el" href="classqi_1_1AnyArguments.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a> as its sole argument will behave as if <a class="el" href="classqi_1_1AnyFunction.html#af84daf701221e75612b814b823f7a91b">AnyFunction::fromDynamicFunction</a> was called.  <a href="classqi_1_1AnyArguments.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AnyFunction.html">AnyFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1GenericFunctionParameters.html">GenericFunctionParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ModuleInfo.html">ModuleInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AnyModule.html">AnyModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ModuleBuilder.html">ModuleBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Application.html">Application</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class handling startup and teardown of an application.  <a href="classqi_1_1Application.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ApplicationSession.html">ApplicationSession</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Atomic.html">Atomic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AtomicFlagLock.html">AtomicFlagLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ObjectSerializationInfo.html">ObjectSerializationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informations passed when serializing an object.  <a href="structqi_1_1ObjectSerializationInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store buffer. .  <a href="classqi_1_1Buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1BufferReader.html">BufferReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to read const buffer.  This class is intendeed to read buffer. It store an internal data cursor and an internal sub-buffer index. All offset are relative to the current position.  <a href="classqi_1_1BufferReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1SteadyClock.html">SteadyClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classqi_1_1SteadyClock.html" title="The SteadyClock class represents a monotonic clock.  &lt;includename&gt;qi/clock.hpp&lt;/includename&gt; ...">SteadyClock</a> class represents a monotonic clock. .  <a href="classqi_1_1SteadyClock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Clock.html">Clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classqi_1_1Clock.html" title="The Clock class represents a system-wide clock, best suitable for timestamping events. Typically monotonic and unaffected by the system clock adjustment, altough this is not guaranteed. ">Clock</a> class represents a system-wide clock, best suitable for timestamping events. Typically monotonic and unaffected by the system clock adjustment, altough this is not guaranteed.  <a href="classqi_1_1Clock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1SystemClock.html">SystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classqi_1_1SystemClock.html" title="The SystemClock class represents the system-wide real time wall clock. It may not be monotonic: on mo...">SystemClock</a> class represents the system-wide real time wall clock. It may not be monotonic: on most systems, the system time can be adjusted at any moment.  <a href="classqi_1_1SystemClock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Future.html">Future</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ExecutionContext.html">ExecutionContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ToPost.html">ToPost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1FutureValueConverter_3_01void_00_01void_01_4.html">FutureValueConverter&lt; void, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1FutureValueConverter_3_01T_00_01void_01_4.html">FutureValueConverter&lt; T, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1FutureValueConverter_3_01void_00_01T_01_4.html">FutureValueConverter&lt; void, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FutureSync.html">FutureSync</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Promise.html">Promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FutureException.html">FutureException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FutureUserException.html">FutureUserException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1FutureValueConverter.html">FutureValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this struct to provide conversion between future values.  <a href="structqi_1_1FutureValueConverter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1UnitFuture.html">UnitFuture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FutureBarrier.html">FutureBarrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps waiting for multiple futures at the same point.  <a href="classqi_1_1FutureBarrier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1HandleExceptionAndRethrow.html">HandleExceptionAndRethrow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ExceptionValue.html">ExceptionValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1EventLoop.html">EventLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to handle eventloop. .  <a href="classqi_1_1EventLoop.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Flags.html">Flags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1NoOpProcedure.html">NoOpProcedure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A procedure that does nothing.  <a href="structqi_1_1NoOpProcedure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1NoOpProcedure_3_01Ret_07Args_8_8_8_08_4.html">NoOpProcedure&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can specify the value to return.  <a href="structqi_1_1NoOpProcedure_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1NoOpProcedure_3_01void_07Args_8_8_8_08_4.html">NoOpProcedure&lt; void(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1PolymorphicConstantFunction.html">PolymorphicConstantFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1PolymorphicConstantFunction_3_01void_01_4.html">PolymorphicConstantFunction&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1IdTransfo.html">IdTransfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Composition.html">Composition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1DataBoundProc.html">DataBoundProc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1DataBoundTransfo.html">DataBoundTransfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1MoveAssign.html">MoveAssign</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Incr.html">Incr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Decr.html">Decr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Apply.html">Apply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ScopeLockProc.html">ScopeLockProc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ScopeLockTransfo.html">ScopeLockTransfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ScopedFutureGroup.html">ScopedFutureGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1ExceptionLogError.html">ExceptionLogError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AuthProvider.html">AuthProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AuthProviderFactory.html">AuthProviderFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AutoService.html">AutoService</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ClientAuthenticator.html">ClientAuthenticator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ClientAuthenticatorFactory.html">ClientAuthenticatorFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AutoService_3_01qi_1_1AnyObject_01_4.html">AutoService&lt; qi::AnyObject &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Gateway.html">Gateway</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ServiceInfo.html">ServiceInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MoveOnCopy.html">MoveOnCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classqi_1_1Path.html" title="The Path class allow handling filesystem path in a cross-platform maner.  &lt;includename&gt;qi/path.hpp&lt;/includename&gt;  The class assume that all string are encoded in UTF-8 if not specified otherwise. ">Path</a> class allow handling filesystem path in a cross-platform maner.  The class assume that all string are encoded in UTF-8 if not specified otherwise.  <a href="classqi_1_1Path.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DataPerf.html">DataPerf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute and store a benchmark time.  <a href="classqi_1_1DataPerf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DataPerfSuite.html">DataPerfSuite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to perform benchmarks.  <a href="classqi_1_1DataPerfSuite.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1PeriodicTask.html">PeriodicTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control a task executed periodically and asynchronously. .  <a href="classqi_1_1PeriodicTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1PropertyBase.html">PropertyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1PropertyImpl.html">PropertyImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1UnsafeProperty.html">UnsafeProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Property.html">Property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1GenericProperty.html">GenericProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased property, simulating a typed property but using <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a>.  <a href="classqi_1_1GenericProperty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1BoundedRange.html">BoundedRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1IncrBoundedRangeAction.html">IncrBoundedRangeAction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1RepeatRange.html">RepeatRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Scoped.html">Scoped</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1Scoped_3_01void_00_01F_01_4.html">Scoped&lt; void, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Session.html">Session</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1SignalBase.html">SignalBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Signal.html">Signal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1SignalF.html">SignalF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Signal_3_01void_01_4.html">Signal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1SignalSubscriber.html">SignalSubscriber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1SignalSubscriberPrivate.html">SignalSubscriberPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1SignalSpy.html">SignalSpy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tool to track signal emissions, specialized for testing. A signal spy can acknowledge every signal emission of a given signal, type-erased or not. Every emission is recorded, so that they can be compared to expectations, or to produce a history.  <a href="classqi_1_1SignalSpy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Signature.html">Signature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MinMaxSum.html">MinMaxSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores min, max and sum of values fed to it.  <a href="classqi_1_1MinMaxSum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MethodStatistics.html">MethodStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store statistics about method calls.  <a href="classqi_1_1MethodStatistics.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1StrandPrivate.html">StrandPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Strand.html">Strand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TrackableBase.html">TrackableBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class to templates <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> for compile-time detection.  <a href="classqi_1_1TrackableBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Trackable.html">Trackable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqi_1_1Object.html">Object</a> tracking by blocking destruction while shared pointers are present.  <a href="classqi_1_1Trackable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1PointerLockException.html">PointerLockException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TrackWithFallbackTransfo.html">TrackWithFallbackTransfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TrackSilentTransfo.html">TrackSilentTransfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Translator.html">Translator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Localization of your source code.  <a href="classqi_1_1Translator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1InfosKeyMask.html">InfosKeyMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FunctionTypeInterfaceEq.html">FunctionTypeInterfaceEq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AnyIterator.html">AnyIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AutoAnyReference.html">AutoAnyReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1AnyValue.html">AnyValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01AnyValue_01_4.html">TypeImpl&lt; AnyValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1FutureValueConverter_3_01T_00_01qi_1_1AnyValue_01_4.html">FutureValueConverter&lt; T, qi::AnyValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1FutureValueConverter_3_01void_00_01qi_1_1AnyValue_01_4.html">FutureValueConverter&lt; void, qi::AnyValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1boost__bind__result__type.html">boost_bind_result_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>boost_bind_result_type&lt; boost::_bi::bind_t&lt; R, A, B &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1boost__bind__parameter__types.html">boost_bind_parameter_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>boost_bind_parameter_types&lt; boost::_bi::bind_t&lt; R, F, B &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1boost__bind__function__type.html">boost_bind_function_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeBufferImpl.html">TypeBufferImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01Buffer_01_4.html">TypeImpl&lt; Buffer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>TypeImpl&lt; boost::any &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1GenericObject.html">GenericObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>TypeImpl&lt; boost::shared_ptr&lt; GenericObject &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1IntTypeInterfaceImpl.html">IntTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeBoolImpl.html">TypeBoolImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FloatTypeInterfaceImpl.html">FloatTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ListTypeInterfaceImpl.html">ListTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeSimpleIteratorImpl.html">TypeSimpleIteratorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TypeImpl_3_01std_1_1vector_3_01T_01_4_01_4.html">TypeImpl&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TypeImpl_3_01std_1_1list_3_01T_01_4_01_4.html">TypeImpl&lt; std::list&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TypeImpl_3_01std_1_1set_3_01T_01_4_01_4.html">TypeImpl&lt; std::set&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1VarArgsTypeInterfaceImpl.html">VarArgsTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TypeImpl_3_01qi_1_1VarArguments_3_01T_01_4_01_4.html">TypeImpl&lt; qi::VarArguments&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1EventTrace.html">EventTrace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Manageable.html">Manageable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MapTypeInterfaceImpl.html">MapTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1TypeImpl_3_01std_1_1map_3_01K_00_01V_00_01C_00_01A_01_4_01_4.html">TypeImpl&lt; std::map&lt; K, V, C, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Empty.html">Empty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Object.html">Object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1WeakObject.html">WeakObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01Object_3_01T_01_4_01_4.html">TypeImpl&lt; Object&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1PointerTypeInterfaceImpl.html">PointerTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01T_01_5_01_4.html">TypeImpl&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeSharedPointerImpl.html">TypeSharedPointerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>TypeImpl&lt; boost::shared_ptr&lt; T &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Proxy.html">Proxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeProxy.html">TypeProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1StringTypeInterfaceImpl.html">StringTypeInterfaceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01std_1_1string_01_4.html">TypeImpl&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeCStringImpl.html">TypeCStringImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01char_01_5_01_4.html">TypeImpl&lt; char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01char[I]_4.html">TypeImpl&lt; char[I]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeEquivalentString.html">TypeEquivalentString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1StructTypeInterfaceBouncer.html">StructTypeInterfaceBouncer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01std_1_1pair_3_01F_00_01S_01_4_01_4.html">TypeImpl&lt; std::pair&lt; F, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TraceAnalyzer.html">TraceAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplateImpl.html">TypeOfTemplateImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeByPointer.html">TypeByPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access API that stores a T* in storage.  <a href="classqi_1_1TypeByPointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeByPointer_3_01const_01T_01_4.html">TypeByPointer&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeByPointerPOD.html">TypeByPointerPOD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeByValue.html">TypeByValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access api that stores a T in storage.  <a href="classqi_1_1TypeByValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeByValue_3_01const_01T_01_4.html">TypeByValue&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DefaultTypeImplMethods.html">DefaultTypeImplMethods</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DefaultTypeImpl.html">DefaultTypeImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl.html">TypeImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01void_01_4.html">TypeImpl&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01T_01_6_01_4.html">TypeImpl&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeInfo.html">TypeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DynamicObject.html">DynamicObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DynamicObjectBuilder.html">DynamicObjectBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template <a class="el" href="structqi_1_1integer__sequence.html" title="Class template integer_sequence. ">integer_sequence</a>.  <a href="structqi_1_1integer__sequence.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaMethodParameter.html">MetaMethodParameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaMethod.html">MetaMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a method in an <a class="el" href="classqi_1_1GenericObject.html">GenericObject</a>.  <a href="classqi_1_1MetaMethod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaMethodBuilder.html">MetaMethodBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaObject.html">MetaObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of the signals and methods accessible on an <a class="el" href="classqi_1_1ObjectTypeInterface.html">ObjectTypeInterface</a>.  <a href="classqi_1_1MetaObject.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqi_1_1MemberAddInfo.html">MemberAddInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaObjectBuilder.html">MetaObjectBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaProperty.html">MetaProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MetaSignal.html">MetaSignal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <a class="el" href="classqi_1_1Signal.html">Signal</a> in an <a class="el" href="classqi_1_1GenericObject.html">GenericObject</a>.  <a href="classqi_1_1MetaSignal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ObjectTypeBuilderBase.html">ObjectTypeBuilderBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ObjectTypeBuilder.html">ObjectTypeBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplate_3_01qi_1_1Future_01_4.html">TypeOfTemplate&lt; qi::Future &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplate_3_01qi_1_1FutureSync_01_4.html">TypeOfTemplate&lt; qi::FutureSync &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplateFutImpl.html">TypeOfTemplateFutImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplateImpl_3_01qi_1_1Future_00_01T_01_4.html">TypeOfTemplateImpl&lt; qi::Future, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplateImpl_3_01qi_1_1FutureSync_00_01T_01_4.html">TypeOfTemplateImpl&lt; qi::FutureSync, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplate_3_01qi_1_1Promise_01_4.html">TypeOfTemplate&lt; qi::Promise &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeOfTemplateImpl_3_01qi_1_1Promise_00_01T_01_4.html">TypeOfTemplateImpl&lt; qi::Promise, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ProxyProperty.html">ProxyProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ProxySignal.html">ProxySignal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqi_1_1Signal.html">Signal</a> proxy, using an AnyObject and signal id as backend.  <a href="classqi_1_1ProxySignal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1IntTypeInterface.html">IntTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1FloatTypeInterface.html">FloatTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1StringTypeInterface.html">StringTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1RawTypeInterface.html">RawTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1PointerTypeInterface.html">PointerTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1IteratorTypeInterface.html">IteratorTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ListTypeInterface.html">ListTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1MapTypeInterface.html">MapTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1StructTypeInterface.html">StructTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1DynamicTypeInterface.html">DynamicTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1VarArgsTypeInterface.html">VarArgsTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01qi_1_1TypeInterface_01_4.html">TypeImpl&lt; qi::TypeInterface &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1TypeImpl_3_01qi_1_1TypeInterface_01_5_01_4.html">TypeImpl&lt; qi::TypeInterface * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1ObjectTypeInterface.html">ObjectTypeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqi_1_1Url.html">Url</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeb5f2fbcb10e8199ea7546a23c8c2a34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aeb5f2fbcb10e8199ea7546a23c8c2a34">AnyVarArguments</a> = <a class="el" href="classqi_1_1VarArguments.html">VarArguments</a>&lt;&gt;</td></tr>
<tr class="separator:aeb5f2fbcb10e8199ea7546a23c8c2a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bc36a20fb78f026936370ff40df799"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac0bc36a20fb78f026936370ff40df799">DynamicFunction</a> = boost::function&lt; <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>(const <a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> &amp;)&gt;</td></tr>
<tr class="separator:ac0bc36a20fb78f026936370ff40df799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61713bc0ea16186774a4df18db41e08b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a61713bc0ea16186774a4df18db41e08b">ModuleFactoryFunctor</a> = boost::function&lt; <a class="el" href="classqi_1_1AnyModule.html">AnyModule</a>(const <a class="el" href="structqi_1_1ModuleInfo.html">qi::ModuleInfo</a> &amp;)&gt;</td></tr>
<tr class="separator:a61713bc0ea16186774a4df18db41e08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e60a9cbccf0a2138b4f838b9ccd356a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> = <a class="el" href="classqi_1_1Object.html">Object</a>&lt; <a class="el" href="classqi_1_1Empty.html">Empty</a> &gt;</td></tr>
<tr class="separator:a0e60a9cbccf0a2138b4f838b9ccd356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0566263d5845787dd24f7d1e53a50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aeea0566263d5845787dd24f7d1e53a50">ApplicationSessionOptions</a> = <a class="el" href="classqi_1_1ApplicationSession.html#a6a2b6ae655f892a69b39e864c120b9e0">ApplicationSession::Option</a></td></tr>
<tr class="separator:aeea0566263d5845787dd24f7d1e53a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1810ab9faa895cc000a83e477570ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a3d1810ab9faa895cc000a83e477570ef">DeserializeObjectCallback</a> = boost::function&lt; <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>(const <a class="el" href="structqi_1_1ObjectSerializationInfo.html">ObjectSerializationInfo</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a3d1810ab9faa895cc000a83e477570ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callback invoked by sdeerializer when it encounters an object.  <a href="#a3d1810ab9faa895cc000a83e477570ef">More...</a><br/></td></tr>
<tr class="separator:a3d1810ab9faa895cc000a83e477570ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df728403f2294ca5d26f2e34d64852c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0df728403f2294ca5d26f2e34d64852c">SerializeObjectCallback</a> = boost::function&lt; <a class="el" href="structqi_1_1ObjectSerializationInfo.html">ObjectSerializationInfo</a>(const <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a0df728403f2294ca5d26f2e34d64852c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callback invoked by serializer when it encounters an object.  <a href="#a0df728403f2294ca5d26f2e34d64852c">More...</a><br/></td></tr>
<tr class="separator:a0df728403f2294ca5d26f2e34d64852c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130edabf43319b499ce3e8c325be0915"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Ratio &gt; </td></tr>
<tr class="memitem:a130edabf43319b499ce3e8c325be0915"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a> = boost::chrono::duration&lt; Rep, Ratio &gt;</td></tr>
<tr class="memdesc:a130edabf43319b499ce3e8c325be0915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedefs.  <a href="#a130edabf43319b499ce3e8c325be0915">More...</a><br/></td></tr>
<tr class="separator:a130edabf43319b499ce3e8c325be0915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd09bb05acef7308fba9e7a753d1582"><td class="memTemplParams" colspan="2">template&lt;class ClockType &gt; </td></tr>
<tr class="memitem:abcd09bb05acef7308fba9e7a753d1582"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abcd09bb05acef7308fba9e7a753d1582">TimePoint</a> = boost::chrono::time_point&lt; ClockType &gt;</td></tr>
<tr class="separator:abcd09bb05acef7308fba9e7a753d1582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fff863d93ebd834a9ed5615434045b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a35fff863d93ebd834a9ed5615434045b">NanoSeconds</a> = <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::nano &gt;</td></tr>
<tr class="separator:a35fff863d93ebd834a9ed5615434045b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16933a46408e5c2b9abe828900dc70d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a16933a46408e5c2b9abe828900dc70d5">MicroSeconds</a> = <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::micro &gt;</td></tr>
<tr class="separator:a16933a46408e5c2b9abe828900dc70d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556ff3e75cfbe6604e6e6c550e35c367"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a556ff3e75cfbe6604e6e6c550e35c367">MilliSeconds</a> = <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::milli &gt;</td></tr>
<tr class="separator:a556ff3e75cfbe6604e6e6c550e35c367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c4335385379166a6520793117f886c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a42c4335385379166a6520793117f886c">Seconds</a> = <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::ratio&lt; 1 &gt;&gt;</td></tr>
<tr class="separator:a42c4335385379166a6520793117f886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4833c7dcb72ab5eb0e7aa08d929c6d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa4833c7dcb72ab5eb0e7aa08d929c6d9">Minutes</a> = <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::ratio&lt; 60 &gt;&gt;</td></tr>
<tr class="separator:aa4833c7dcb72ab5eb0e7aa08d929c6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa001ed01e669f703fca72d7659456ab2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa001ed01e669f703fca72d7659456ab2">Hours</a> = <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::ratio&lt; 3600 &gt;&gt;</td></tr>
<tr class="separator:aa001ed01e669f703fca72d7659456ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2a2e5db2d66c95b8b6f15f2bafbf59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">Duration</a> = <a class="el" href="namespaceqi.html#a35fff863d93ebd834a9ed5615434045b">NanoSeconds</a></td></tr>
<tr class="separator:a2b2a2e5db2d66c95b8b6f15f2bafbf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3834497c0f4e5f94c302ca438f1f976c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">SteadyClockTimePoint</a> = <a class="el" href="classqi_1_1SteadyClock.html#a0292e248066d1cb00fbac295a83a4a1d">SteadyClock::time_point</a></td></tr>
<tr class="memdesc:a3834497c0f4e5f94c302ca438f1f976c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steady clock time point.  <a href="#a3834497c0f4e5f94c302ca438f1f976c">More...</a><br/></td></tr>
<tr class="separator:a3834497c0f4e5f94c302ca438f1f976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796401bb4b6275080745823738fd30e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a796401bb4b6275080745823738fd30e8">ClockTimePoint</a> = <a class="el" href="classqi_1_1Clock.html#abdda537df65b45a0a950464da0562d06">Clock::time_point</a></td></tr>
<tr class="memdesc:a796401bb4b6275080745823738fd30e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqi_1_1Clock.html" title="The Clock class represents a system-wide clock, best suitable for timestamping events. Typically monotonic and unaffected by the system clock adjustment, altough this is not guaranteed. ">qi::Clock</a> time point.  <a href="#a796401bb4b6275080745823738fd30e8">More...</a><br/></td></tr>
<tr class="separator:a796401bb4b6275080745823738fd30e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412ecc9dbc618e0f6816f9167f304f20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a> = <a class="el" href="classqi_1_1SystemClock.html#a0100715a9e06d84f554f931649c828e2">SystemClock::time_point</a></td></tr>
<tr class="memdesc:a412ecc9dbc618e0f6816f9167f304f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">System clock time point.  <a href="#a412ecc9dbc618e0f6816f9167f304f20">More...</a><br/></td></tr>
<tr class="separator:a412ecc9dbc618e0f6816f9167f304f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa647e3e3e2836c23e271aad9b606d4f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa647e3e3e2836c23e271aad9b606d4f6">FutureUniqueId</a> = void *</td></tr>
<tr class="separator:aa647e3e3e2836c23e271aad9b606d4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8b83d91c31225480036795fee7ce38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a7c8b83d91c31225480036795fee7ce38">JsonOption</a> = int</td></tr>
<tr class="separator:a7c8b83d91c31225480036795fee7ce38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c2b8c1c1c04f81bb319e7c5516d05e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af6c2b8c1c1c04f81bb319e7c5516d05e">LogContext</a> = int</td></tr>
<tr class="memdesc:af6c2b8c1c1c04f81bb319e7c5516d05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs context attribute value.  <a href="#af6c2b8c1c1c04f81bb319e7c5516d05e">More...</a><br/></td></tr>
<tr class="separator:af6c2b8c1c1c04f81bb319e7c5516d05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa9d95d751a10b47ba4f4d24f55cf2a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6fa9d95d751a10b47ba4f4d24f55cf2a">CapabilityMap</a> = std::map&lt; std::string, <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt;</td></tr>
<tr class="separator:a6fa9d95d751a10b47ba4f4d24f55cf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae3df954ff0b045407ceda0d7e90ad4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a2ae3df954ff0b045407ceda0d7e90ad4">AuthProviderPtr</a> = boost::shared_ptr&lt; <a class="el" href="classqi_1_1AuthProvider.html">AuthProvider</a> &gt;</td></tr>
<tr class="separator:a2ae3df954ff0b045407ceda0d7e90ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d4f697b87008b10e7a1a1c830c2f92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad2d4f697b87008b10e7a1a1c830c2f92">AuthProviderFactoryPtr</a> = boost::shared_ptr&lt; <a class="el" href="classqi_1_1AuthProviderFactory.html">AuthProviderFactory</a> &gt;</td></tr>
<tr class="separator:ad2d4f697b87008b10e7a1a1c830c2f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757656dc3b93d0d968362b133e149842"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a757656dc3b93d0d968362b133e149842">AnyAutoService</a> = <a class="el" href="classqi_1_1AutoService.html">AutoService</a>&lt; <a class="el" href="classqi_1_1Empty.html">qi::Empty</a> &gt;</td></tr>
<tr class="separator:a757656dc3b93d0d968362b133e149842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635df3ce1bb9dd26bd17890ab1d5517b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a635df3ce1bb9dd26bd17890ab1d5517b">ClientAuthenticatorPtr</a> = boost::shared_ptr&lt; <a class="el" href="classqi_1_1ClientAuthenticator.html">ClientAuthenticator</a> &gt;</td></tr>
<tr class="separator:a635df3ce1bb9dd26bd17890ab1d5517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d284145085bb4503487026fcc58f26"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a91d284145085bb4503487026fcc58f26">ClientAuthenticatorFactoryPtr</a> = boost::shared_ptr&lt; <a class="el" href="classqi_1_1ClientAuthenticatorFactory.html">ClientAuthenticatorFactory</a> &gt;</td></tr>
<tr class="separator:a91d284145085bb4503487026fcc58f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e6701dbcae4d1d06c50efbb4b2f21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a708e6701dbcae4d1d06c50efbb4b2f21">GatewayPrivatePtr</a> = std::unique_ptr&lt; GatewayPrivate &gt;</td></tr>
<tr class="separator:a708e6701dbcae4d1d06c50efbb4b2f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4736ceb28d028e6552c124fd1b78030d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a4736ceb28d028e6552c124fd1b78030d">ServiceInfoVector</a> = std::vector&lt; <a class="el" href="classqi_1_1ServiceInfo.html">qi::ServiceInfo</a> &gt;</td></tr>
<tr class="separator:a4736ceb28d028e6552c124fd1b78030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c7464752acddcdd4fa4111f65aeda"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8d4c7464752acddcdd4fa4111f65aeda">PathVector</a> = std::vector&lt; <a class="el" href="classqi_1_1Path.html">Path</a> &gt;</td></tr>
<tr class="separator:a8d4c7464752acddcdd4fa4111f65aeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827eae44eb9f8ca4154e87014b3720ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a827eae44eb9f8ca4154e87014b3720ec">codecvt_type</a> = std::codecvt&lt; wchar_t, char, std::mbstate_t &gt;</td></tr>
<tr class="memdesc:a827eae44eb9f8ca4154e87014b3720ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard std::codecvt type accepted by STL and boost.  <a href="#a827eae44eb9f8ca4154e87014b3720ec">More...</a><br/></td></tr>
<tr class="separator:a827eae44eb9f8ca4154e87014b3720ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc5a91e6d98c912baaa84d6ff3e54c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae3cc5a91e6d98c912baaa84d6ff3e54c">SessionPtr</a> = boost::shared_ptr&lt; <a class="el" href="classqi_1_1Session.html">Session</a> &gt;</td></tr>
<tr class="separator:ae3cc5a91e6d98c912baaa84d6ff3e54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69247b0b30dc5f6df95488f18e9aff01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a69247b0b30dc5f6df95488f18e9aff01">SignalLink</a> = <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">qi::uint64_t</a></td></tr>
<tr class="separator:a69247b0b30dc5f6df95488f18e9aff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5376edc7d633faa4c5ca3beed49dd48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af5376edc7d633faa4c5ca3beed49dd48">SignalSubscriberPtr</a> = boost::shared_ptr&lt; <a class="el" href="classqi_1_1SignalSubscriber.html">SignalSubscriber</a> &gt;</td></tr>
<tr class="separator:af5376edc7d633faa4c5ca3beed49dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49b9d29c59a9b651c2f5522ac50792c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af49b9d29c59a9b651c2f5522ac50792c">SignatureVector</a> = std::vector&lt; <a class="el" href="classqi_1_1Signature.html">Signature</a> &gt;</td></tr>
<tr class="separator:af49b9d29c59a9b651c2f5522ac50792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6526717e2ad65d93d8a801c099cc90a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> = std::vector&lt; <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &gt;</td></tr>
<tr class="separator:af6526717e2ad65d93d8a801c099cc90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc9c029f3e47daa5e331a46afca298b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a9fc9c029f3e47daa5e331a46afca298b">AnyValueVector</a> = std::vector&lt; <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt;</td></tr>
<tr class="separator:a9fc9c029f3e47daa5e331a46afca298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133f309be9d3b1b67922f2dda24bbe05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a133f309be9d3b1b67922f2dda24bbe05">ObjectStatistics</a> = std::map&lt; unsigned int, <a class="el" href="classqi_1_1MethodStatistics.html">MethodStatistics</a> &gt;</td></tr>
<tr class="separator:a133f309be9d3b1b67922f2dda24bbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984d5fa8d8f50699c31a3da9bca5b63a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a984d5fa8d8f50699c31a3da9bca5b63a">AnyWeakObject</a> = <a class="el" href="classqi_1_1WeakObject.html">WeakObject</a>&lt; <a class="el" href="classqi_1_1Empty.html">Empty</a> &gt;</td></tr>
<tr class="separator:a984d5fa8d8f50699c31a3da9bca5b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2398cec17c26c985a48a6ad16b2051f"><td class="memTemplParams" colspan="2">template&lt;typename Tp , Tp Num&gt; </td></tr>
<tr class="memitem:ab2398cec17c26c985a48a6ad16b2051f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ab2398cec17c26c985a48a6ad16b2051f">make_integer_sequence</a> = typename <a class="el" href="structqi_1_1detail_1_1make__integer__sequence.html">detail::make_integer_sequence</a>&lt; Tp, Num &gt;::type</td></tr>
<tr class="memdesc:ab2398cec17c26c985a48a6ad16b2051f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template make_integer_sequence.  <a href="#ab2398cec17c26c985a48a6ad16b2051f">More...</a><br/></td></tr>
<tr class="separator:ab2398cec17c26c985a48a6ad16b2051f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6306cefd8ae50212de16d744b715ee09"><td class="memTemplParams" colspan="2">template&lt;size_t... Idx&gt; </td></tr>
<tr class="memitem:a6306cefd8ae50212de16d744b715ee09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6306cefd8ae50212de16d744b715ee09">index_sequence</a> = <a class="el" href="structqi_1_1integer__sequence.html">integer_sequence</a>&lt; size_t, Idx...&gt;</td></tr>
<tr class="memdesc:a6306cefd8ae50212de16d744b715ee09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template index_sequence.  <a href="#a6306cefd8ae50212de16d744b715ee09">More...</a><br/></td></tr>
<tr class="separator:a6306cefd8ae50212de16d744b715ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be2335ae913e30603739c3c0ea0a00b"><td class="memTemplParams" colspan="2">template&lt;size_t Num&gt; </td></tr>
<tr class="memitem:a0be2335ae913e30603739c3c0ea0a00b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0be2335ae913e30603739c3c0ea0a00b">make_index_sequence</a> = typename <a class="el" href="structqi_1_1detail_1_1make__integer__sequence.html">detail::make_integer_sequence</a>&lt; size_t, Num &gt;::type</td></tr>
<tr class="memdesc:a0be2335ae913e30603739c3c0ea0a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template make_index_sequence.  <a href="#a0be2335ae913e30603739c3c0ea0a00b">More...</a><br/></td></tr>
<tr class="separator:a0be2335ae913e30603739c3c0ea0a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd202c160024759642782fe8450a21d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a7dd202c160024759642782fe8450a21d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a7dd202c160024759642782fe8450a21d">index_sequence_for</a> = <a class="el" href="namespaceqi.html#a0be2335ae913e30603739c3c0ea0a00b">make_index_sequence</a>&lt; sizeof...(Types)&gt;</td></tr>
<tr class="memdesc:a7dd202c160024759642782fe8450a21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template index_sequence_for.  <a href="#a7dd202c160024759642782fe8450a21d">More...</a><br/></td></tr>
<tr class="separator:a7dd202c160024759642782fe8450a21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add780030382fb666b15a721b62523d36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#add780030382fb666b15a721b62523d36">MetaMethodParameterVector</a> = std::vector&lt; <a class="el" href="classqi_1_1MetaMethodParameter.html">MetaMethodParameter</a> &gt;</td></tr>
<tr class="separator:add780030382fb666b15a721b62523d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5eed863e4c5e940fb4820df40ab5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a08a5eed863e4c5e940fb4820df40ab5c">int8_t</a> = <a class="el" href="namespaceqi.html#a08a5eed863e4c5e940fb4820df40ab5c">int8_t</a></td></tr>
<tr class="separator:a08a5eed863e4c5e940fb4820df40ab5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5f92384de94a81e0be6a2617577c9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a3f5f92384de94a81e0be6a2617577c9d">int16_t</a> = <a class="el" href="namespaceqi.html#a3f5f92384de94a81e0be6a2617577c9d">int16_t</a></td></tr>
<tr class="separator:a3f5f92384de94a81e0be6a2617577c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273969d76ca08978f1eb6d3ff72562bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a273969d76ca08978f1eb6d3ff72562bb">int32_t</a> = <a class="el" href="namespaceqi.html#a273969d76ca08978f1eb6d3ff72562bb">int32_t</a></td></tr>
<tr class="separator:a273969d76ca08978f1eb6d3ff72562bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80465fa597a2cce9b8a2dc595e685be7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a> = <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a></td></tr>
<tr class="separator:a80465fa597a2cce9b8a2dc595e685be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac120f3edc8f043b64c96e6e205f1f098"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac120f3edc8f043b64c96e6e205f1f098">uint8_t</a> = <a class="el" href="namespaceqi.html#ac120f3edc8f043b64c96e6e205f1f098">uint8_t</a></td></tr>
<tr class="separator:ac120f3edc8f043b64c96e6e205f1f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057f5b0592dbdf05c338ea6d7c369633"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a057f5b0592dbdf05c338ea6d7c369633">uint16_t</a> = <a class="el" href="namespaceqi.html#a057f5b0592dbdf05c338ea6d7c369633">uint16_t</a></td></tr>
<tr class="separator:a057f5b0592dbdf05c338ea6d7c369633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f4e8363661056c4f3aea8d20e3f9cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a31f4e8363661056c4f3aea8d20e3f9cc">uint32_t</a> = <a class="el" href="namespaceqi.html#a31f4e8363661056c4f3aea8d20e3f9cc">uint32_t</a></td></tr>
<tr class="separator:a31f4e8363661056c4f3aea8d20e3f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d0ac2d727a7e16134a0db019f3ceb6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">uint64_t</a> = <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">uint64_t</a></td></tr>
<tr class="separator:aa2d0ac2d727a7e16134a0db019f3ceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1d07cc053525dae4395ad582d9a8bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8b1d07cc053525dae4395ad582d9a8bc">UrlVector</a> = std::vector&lt; <a class="el" href="classqi_1_1Url.html">Url</a> &gt;</td></tr>
<tr class="separator:a8b1d07cc053525dae4395ad582d9a8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06fde6361c5d179ff0b9615a0ac4aa51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51">FutureState</a> { <br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51a7353b65c14fc6205a79798a3fbd4401a">FutureState_None</a>, 
<a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51ab4aa09c0a00d9b24933df2952b28bc15">FutureState_Running</a>, 
<a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51a3c3a4f9e8d394891d5717e8e962ce8f9">FutureState_Canceled</a>, 
<a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51a8a7110a297926cba1ba38f5272a1ba5d">FutureState_FinishedWithError</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51aa34f218f2ec9a05027f11f7e524cef0b">FutureState_FinishedWithValue</a>
<br/>
 }</td></tr>
<tr class="separator:a06fde6361c5d179ff0b9615a0ac4aa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66922f30da6f5708915f47ed330e0de0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a66922f30da6f5708915f47ed330e0de0">FutureCallbackType</a> { <a class="el" href="namespaceqi.html#a66922f30da6f5708915f47ed330e0de0a994de07b744ad919d45ec8666da03c4f">FutureCallbackType_Sync</a> = 0, 
<a class="el" href="namespaceqi.html#a66922f30da6f5708915f47ed330e0de0adee2428ef5a90f515ac7737c9a159d75">FutureCallbackType_Async</a> = 1, 
<a class="el" href="namespaceqi.html#a66922f30da6f5708915f47ed330e0de0a61edf564a20cbb5425c6117ee65e7963">FutureCallbackType_Auto</a> = 2
 }</td></tr>
<tr class="separator:a66922f30da6f5708915f47ed330e0de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f54e93f8719f4708669496c8a20a9c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad1f54e93f8719f4708669496c8a20a9c">FutureTimeout</a> { <a class="el" href="namespaceqi.html#ad1f54e93f8719f4708669496c8a20a9ca648162635a9fcbc69da607a51197e07c">FutureTimeout_Infinite</a> = ((int) 0x7fffffff), 
<a class="el" href="namespaceqi.html#ad1f54e93f8719f4708669496c8a20a9caa418e4954620069c7ddbb4bc6c1e661d">FutureTimeout_None</a> = 0
 }</td></tr>
<tr class="separator:ad1f54e93f8719f4708669496c8a20a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad950f2c2012aa46a30595bf769d72d32"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32">AdaptFutureOption</a> { <a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32a856974a106298f26aa88138b81bc5f6a">AdaptFutureOption_None</a> = 0, 
<a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32a2416fcefdc9fcdd947e1f2d76f4e11c0">AdaptFutureOption_ForwardCancel</a> = 1
 }</td></tr>
<tr class="separator:ad950f2c2012aa46a30595bf769d72d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118f2d350ecce997af3f9e1c817fa321"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321">StreamColor</a> { <br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a344631221068a24cef3301551065bc00">StreamColor_None</a> = 0, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321aa5ae1a9eb8c9ca2c0427682808b5b3a8">StreamColor_Reset</a> = 1, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a4f2f77f9392a206c386c1e89422e3152">StreamColor_Bold</a> = 2, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321aac8b681a7977a3d0a07ffcee0b99d5af">StreamColor_Faint</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a67fec5cb524c9c012d15a814833b1e57">StreamColor_Standout</a> = 4, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a4715eae0b58f7aa8cb08adfa6b5788b9">StreamColor_Underline</a> = 5, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a9f4660fb42a98a264060e46d5ba396b8">StreamColor_Blink</a> = 6, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321ab5ad1ee5aa153c51cb41d78ba91632a1">StreamColor_Overline</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a43a4c4c728f3f852cdb6e454ef918824">StreamColor_Black</a> = 8, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a67c34ed466def0e9a5dbf1da90fedde0">StreamColor_DarkRed</a> = 9, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a16f2e3b9e225ef941f0fe8b5a8a6f79c">StreamColor_DarkGreen</a> = 10, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a68b0b8fdcb78a4b2f8bd9eabf244efaa">StreamColor_Brown</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a1c64bda3e21fa88c070db2ac2bcd6bd5">StreamColor_DarkBlue</a> = 12, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321af937c4634377d7684ecbe385807e6c37">StreamColor_Purple</a> = 13, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a94a58a580a0576ea1f28a2564774f95a">StreamColor_Teal</a> = 14, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a6352965a77351604a4fb449f66df96e6">StreamColor_LightGray</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321af8cbac1491dc0aa4350d410c7979610a">StreamColor_DarkGray</a> = 16, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a0191c01a1ae8a0f32513e6d435a035b4">StreamColor_Red</a> = 17, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a7fb90bd6188ea53c9f501f07278639dc">StreamColor_Green</a> = 18, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321ab65ac4782da71d06fc5033877df7a342">StreamColor_Yellow</a> = 19, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a49b1c68c9ae2782eb143a3a66dae3d55">StreamColor_Blue</a> = 20, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321a68b9f3474d708de9bbbcfa8ee81f822b">StreamColor_Fuchsia</a> = 21, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321ac19037b0d7b1c1a760e7182f3b598091">StreamColor_Turquoise</a> = 22, 
<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321af2db4cdda545b6e45843235be74f637f">StreamColor_White</a> = 23
<br/>
 }</td></tr>
<tr class="memdesc:a118f2d350ecce997af3f9e1c817fa321"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Stream Color enum.  <a href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321">More...</a><br/></td></tr>
<tr class="separator:a118f2d350ecce997af3f9e1c817fa321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae404a3651bdc9116349a4a60a1d0afc5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5">LogLevel</a> { <br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5a77059e55763f4584259218f0802d6b58">LogLevel_Silent</a> = 0, 
<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5ab7f68198dd8bff433614815c8a226fc8">LogLevel_Fatal</a>, 
<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5a29568c44b55d44dec768128135f45d4a">LogLevel_Error</a>, 
<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5a1f5fad47e4e5cef1a8d437f94b9cc56f">LogLevel_Warning</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5ab813d452a834cc8990cde0a8592c9f8d">LogLevel_Info</a>, 
<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5a990d6cb9c4c1d0557c2e3780ae345839">LogLevel_Verbose</a>, 
<a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5a030864da44cde81392a2e2fbd2f33b1e">LogLevel_Debug</a>
<br/>
 }</td></tr>
<tr class="memdesc:ae404a3651bdc9116349a4a60a1d0afc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log level verbosity.  <a href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5">More...</a><br/></td></tr>
<tr class="separator:ae404a3651bdc9116349a4a60a1d0afc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d7c0b8007b1ab09fc2de493108396b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa1d7c0b8007b1ab09fc2de493108396b">LogColor</a> { <a class="el" href="namespaceqi.html#aa1d7c0b8007b1ab09fc2de493108396ba3bd8da8f7b698c20476796110d4647a1">LogColor_Never</a>, 
<a class="el" href="namespaceqi.html#aa1d7c0b8007b1ab09fc2de493108396ba6057d0099587041711b20c47580e79b0">LogColor_Auto</a>, 
<a class="el" href="namespaceqi.html#aa1d7c0b8007b1ab09fc2de493108396ba691067550d59a0e744b04b4bb782e829">LogColor_Always</a>
 }</td></tr>
<tr class="memdesc:aa1d7c0b8007b1ab09fc2de493108396b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs color mode.  <a href="namespaceqi.html#aa1d7c0b8007b1ab09fc2de493108396b">More...</a><br/></td></tr>
<tr class="separator:aa1d7c0b8007b1ab09fc2de493108396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49003e94f0efc86109a278d8d55f88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88">LogContextAttr</a> { <br/>
&#160;&#160;<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88a7de8d9712806cce940066df9c298dde6">LogContextAttr_None</a> = 0, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88aa98c7a6e68d61670619e925a6030850a">LogContextAttr_Verbosity</a> = 1 &lt;&lt; 0, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88a5082e95ca9152e6dd0c45acccef85dea">LogContextAttr_ShortVerbosity</a> = 1 &lt;&lt; 1, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88a47fb8dffe21791abad5cd4b757b7be6d">LogContextAttr_SystemDate</a> = 1 &lt;&lt; 2, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88a7dd9f2a728db294bbccab4452d97a718">LogContextAttr_Tid</a> = 1 &lt;&lt; 3, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88ace5552c93742d5968ed2e9551317c06b">LogContextAttr_Category</a> = 1 &lt;&lt; 4, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88a8b875514dd1c415afa9d92c9ca2a8e76">LogContextAttr_File</a> = 1 &lt;&lt; 5, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88add0679d327681fecef744811c7a3fdbf">LogContextAttr_Function</a> = 1 &lt;&lt; 6, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88ab137c7cf28a44e366b6d2e6ec675587f">LogContextAttr_Return</a> = 1 &lt;&lt; 7, 
<a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88abe8c8facb4ddf7e7cf8e362db8101e53">LogContextAttr_Date</a> = 1 &lt;&lt; 8
<br/>
 }</td></tr>
<tr class="memdesc:aeb49003e94f0efc86109a278d8d55f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs context attribute.  <a href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88">More...</a><br/></td></tr>
<tr class="separator:aeb49003e94f0efc86109a278d8d55f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d59aed9fc0a2b4ee91991e2888d0227"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227">ObjectThreadingModel</a> { <a class="el" href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227a56239778f0c7fc1f4ab6207862e81fbc">ObjectThreadingModel_SingleThread</a> = 0, 
<a class="el" href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227a6551c85d1e42bb6cff437d35ee1661cc">ObjectThreadingModel_MultiThread</a> = 1, 
<a class="el" href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227a4b1933f8429b66806e8387c1aff33cfd">ObjectThreadingModel_Default</a> = ObjectThreadingModel_SingleThread
 }</td></tr>
<tr class="memdesc:a8d59aed9fc0a2b4ee91991e2888d0227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible thread models for an object.  <a href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227">More...</a><br/></td></tr>
<tr class="separator:a8d59aed9fc0a2b4ee91991e2888d0227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01d947882857905031a3773561d3d83"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83">TypeKind</a> { <br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a9addb80987fbf6aba929a8ba36a8696a">TypeKind_Unknown</a> = 0, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a697124369f8d09989eb1799cc5b417f1">TypeKind_Void</a> = 1, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a5c9f02f8fde69ebf4ef298429f406ca1">TypeKind_Int</a> = 2, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83ac2cb42a5ad96ca81820b32883ff11ce1">TypeKind_Float</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a0cea76e7d2e7ca23952106e2df8e5477">TypeKind_String</a> = 4, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a2d80d8ac34eb816f880492fd48fa9947">TypeKind_List</a> = 5, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a02c298fe28a07aa0fd52762c6ead1f49">TypeKind_Map</a> = 6, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a3fdef608736434b0ed3db23409166f45">TypeKind_Object</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83ac588aa7668f30929b99f7b51e164d85e">TypeKind_Pointer</a> = 8, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83ae256bb50e674644be82c9e3c875b17b1">TypeKind_Tuple</a> = 9, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83ad4857d8288ae9b6587dbbe3a60afb7b1">TypeKind_Dynamic</a> = 10, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a629950116208ae3ec5707f826f77394a">TypeKind_Raw</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a053d4b330c4a9e259ddedd9bd8571ba3">TypeKind_Iterator</a> = 13, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a93d64a5491fde8c3736899b963ed84b6">TypeKind_Function</a> = 14, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83ade474d4acfbe0a14655b407dde022904">TypeKind_Signal</a> = 15, 
<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a657d2054debc55771add5e8c42987a26">TypeKind_Property</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83a94150a53653301f2fefce04752093ef9">TypeKind_VarArgs</a> = 17
<br/>
 }</td></tr>
<tr class="separator:ae01d947882857905031a3773561d3d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26fc7fa51e2905573cda6a194af6cae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6cae">MetaCallType</a> { <a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6caea0427d0d572be1d1929de10cb006946e8">MetaCallType_Auto</a> = 0, 
<a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6caea90daab2e41b08efb5341e827e543ebbc">MetaCallType_Direct</a> = 1, 
<a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6caea44b53fab14f133a377cfa684c4921b08">MetaCallType_Queued</a> = 2
 }</td></tr>
<tr class="separator:af26fc7fa51e2905573cda6a194af6cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afec3f81bb472c7ecc1211a9fc46bb944"><td class="memTemplParams" colspan="2">template&lt;typename S , typename P &gt; </td></tr>
<tr class="memitem:afec3f81bb472c7ecc1211a9fc46bb944"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afec3f81bb472c7ecc1211a9fc46bb944">erase_if</a> (S &amp;s, const P &amp;p)</td></tr>
<tr class="separator:afec3f81bb472c7ecc1211a9fc46bb944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af824fdaacc150d8140e14cedebc08f8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af824fdaacc150d8140e14cedebc08f8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1FunctionTypeInterface.html">FunctionTypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af824fdaacc150d8140e14cedebc08f8d">makeFunctionTypeInterface</a> ()</td></tr>
<tr class="separator:af824fdaacc150d8140e14cedebc08f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098783b698f8b1042afa3fcb13fb2d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1FunctionTypeInterface.html">FunctionTypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a098783b698f8b1042afa3fcb13fb2d75">dynamicFunctionTypeInterface</a> ()</td></tr>
<tr class="separator:a098783b698f8b1042afa3fcb13fb2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f39390146087e0629f56a47773afee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a1f39390146087e0629f56a47773afee0">registerCppEmbeddedModule</a> (const std::string &amp;moduleName, boost::function&lt; void(<a class="el" href="classqi_1_1ModuleBuilder.html">ModuleBuilder</a> *)&gt; fun)</td></tr>
<tr class="separator:a1f39390146087e0629f56a47773afee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68bfc01c21c9742b95d9cd5dbfd383f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structqi_1_1ModuleInfo.html">ModuleInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af68bfc01c21c9742b95d9cd5dbfd383f">listModules</a> ()</td></tr>
<tr class="separator:af68bfc01c21c9742b95d9cd5dbfd383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5882f25a3446993872bf1203d8ac5243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyModule.html">AnyModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5882f25a3446993872bf1203d8ac5243">import</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a5882f25a3446993872bf1203d8ac5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d8256b364ab12d3b96d6bb3832b60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyModule.html">AnyModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac2d8256b364ab12d3b96d6bb3832b60e">import</a> (const <a class="el" href="structqi_1_1ModuleInfo.html">ModuleInfo</a> &amp;name)</td></tr>
<tr class="separator:ac2d8256b364ab12d3b96d6bb3832b60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726e9946485acd3c5125ab71981d964b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a726e9946485acd3c5125ab71981d964b">registerModuleFactory</a> (const std::string &amp;name, <a class="el" href="namespaceqi.html#a61713bc0ea16186774a4df18db41e08b">ModuleFactoryFunctor</a> fun)</td></tr>
<tr class="separator:a726e9946485acd3c5125ab71981d964b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97cd68b446e79163130ece29d2c5f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt; <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aab97cd68b446e79163130ece29d2c5f0">metaCall</a> (<a class="el" href="classqi_1_1ExecutionContext.html">ExecutionContext</a> *ec, <a class="el" href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227">ObjectThreadingModel</a> objectThreadingModel, <a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6cae">MetaCallType</a> methodThreadingModel, <a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6cae">MetaCallType</a> callType, <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> manageable, unsigned int methodId, <a class="el" href="classqi_1_1AnyFunction.html">AnyFunction</a> func, const <a class="el" href="classqi_1_1GenericFunctionParameters.html">GenericFunctionParameters</a> &amp;params, bool noCloneFirst=false, unsigned int callerId=0, <a class="el" href="structqi_1_1os_1_1timeval.html">qi::os::timeval</a> postTimestamp=<a class="el" href="structqi_1_1os_1_1timeval.html">qi::os::timeval</a>())</td></tr>
<tr class="separator:aab97cd68b446e79163130ece29d2c5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d957483b6b2fc0c45cfdca6b6a8f0f0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a0d957483b6b2fc0c45cfdca6b6a8f0f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0d957483b6b2fc0c45cfdca6b6a8f0f0">asyncAt</a> (F &amp;&amp;callback, <a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">qi::SteadyClockTimePoint</a> timepoint) -&gt; decltype(<a class="el" href="namespaceqi.html#ac6a56d0b369a9a5eeb3655db91c684c4">qi::getEventLoop</a>() -&gt;asyncAt(std::forward&lt; F &gt;(callback), timepoint))</td></tr>
<tr class="separator:a0d957483b6b2fc0c45cfdca6b6a8f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca874e8edfc26e86e67d2aa0ebe4b46"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:acca874e8edfc26e86e67d2aa0ebe4b46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#acca874e8edfc26e86e67d2aa0ebe4b46">asyncDelay</a> (F &amp;&amp;callback, <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> delay) -&gt; decltype(<a class="el" href="namespaceqi_1_1detail.html#ac4f6e9085a06d7af6c789d000e840306">detail::asyncMaybeActor</a>(std::forward&lt; F &gt;(callback), delay))</td></tr>
<tr class="separator:acca874e8edfc26e86e67d2aa0ebe4b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab575e2e142b7b0233d6fc65037d2953c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab575e2e142b7b0233d6fc65037d2953c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ab575e2e142b7b0233d6fc65037d2953c">async</a> (F &amp;&amp;callback) -&gt; decltype(<a class="el" href="namespaceqi.html#acca874e8edfc26e86e67d2aa0ebe4b46">asyncDelay</a>(std::forward&lt; F &gt;(callback), <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a>(0)))</td></tr>
<tr class="separator:ab575e2e142b7b0233d6fc65037d2953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5152d9573d909c3c6af77bf2af3d36"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a8b5152d9573d909c3c6af77bf2af3d36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8b5152d9573d909c3c6af77bf2af3d36">async</a> (boost::function&lt; R()&gt; callback, <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">uint64_t</a> usDelay)</td></tr>
<tr class="separator:a8b5152d9573d909c3c6af77bf2af3d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b9ce4d215087ec6c44b1acead8439a"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ab8b9ce4d215087ec6c44b1acead8439a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ab8b9ce4d215087ec6c44b1acead8439a">async</a> (boost::function&lt; R()&gt; callback, <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> delay)</td></tr>
<tr class="separator:ab8b9ce4d215087ec6c44b1acead8439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf40c41506c08b9a833e52e75ec0cbc"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a2cf40c41506c08b9a833e52e75ec0cbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a2cf40c41506c08b9a833e52e75ec0cbc">async</a> (boost::function&lt; R()&gt; callback, <a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">qi::SteadyClockTimePoint</a> timepoint)</td></tr>
<tr class="separator:a2cf40c41506c08b9a833e52e75ec0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d5d914504a578f0b8a84c72ed225b0"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ae9d5d914504a578f0b8a84c72ed225b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae9d5d914504a578f0b8a84c72ed225b0">async</a> (<a class="el" href="structqi_1_1detail_1_1Function.html">detail::Function</a>&lt; R()&gt; callback)</td></tr>
<tr class="separator:ae9d5d914504a578f0b8a84c72ed225b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5210b7d2ffc2ef231ac3708fb8fe02f1"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Func , typename ArgTrack &gt; </td></tr>
<tr class="memitem:a5210b7d2ffc2ef231ac3708fb8fe02f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> <a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5210b7d2ffc2ef231ac3708fb8fe02f1">async</a> (const Func &amp;f, const ArgTrack &amp;toTrack,...)</td></tr>
<tr class="separator:a5210b7d2ffc2ef231ac3708fb8fe02f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7029b49605d7bbd34f9ccde4d27b38c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Duration &gt; </td></tr>
<tr class="memitem:aa7029b49605d7bbd34f9ccde4d27b38c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa7029b49605d7bbd34f9ccde4d27b38c">cancelOnTimeout</a> (<a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; fut, <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">Duration</a> timeout)</td></tr>
<tr class="separator:aa7029b49605d7bbd34f9ccde4d27b38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55c8cbcb460492f02918d9f5a8cb3be"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af55c8cbcb460492f02918d9f5a8cb3be">testAndSet</a> (long *cond)</td></tr>
<tr class="separator:af55c8cbcb460492f02918d9f5a8cb3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef52fccbce49beb8d9822a70fe379f47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aef52fccbce49beb8d9822a70fe379f47">tryRaiseAtomicFlag</a> (std::atomic&lt; bool &gt; &amp;b)</td></tr>
<tr class="separator:aef52fccbce49beb8d9822a70fe379f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc29e0f4207ef96732cf0fb801ec75d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afc29e0f4207ef96732cf0fb801ec75d6">tryLowerAtomicFlag</a> (std::atomic&lt; bool &gt; &amp;b)</td></tr>
<tr class="separator:afc29e0f4207ef96732cf0fb801ec75d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af844a26e7e6960b6c81ed6632d291a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AtomicFlagLock.html">AtomicFlagLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af844a26e7e6960b6c81ed6632d291a9f">scopelock</a> (std::atomic_flag &amp;f)</td></tr>
<tr class="memdesc:af844a26e7e6960b6c81ed6632d291a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">model ScopeLockable std::atomic_flag:  <a href="#af844a26e7e6960b6c81ed6632d291a9f">More...</a><br/></td></tr>
<tr class="separator:af844a26e7e6960b6c81ed6632d291a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af281051bb6005da6852e3c1663b92809"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af281051bb6005da6852e3c1663b92809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af281051bb6005da6852e3c1663b92809">decodeBinary</a> (<a class="el" href="classqi_1_1BufferReader.html">qi::BufferReader</a> *buf, T *value, <a class="el" href="namespaceqi.html#a3d1810ab9faa895cc000a83e477570ef">DeserializeObjectCallback</a> onObject=<a class="el" href="namespaceqi.html#a3d1810ab9faa895cc000a83e477570ef">DeserializeObjectCallback</a>(), StreamContext *streamContext=0)</td></tr>
<tr class="separator:af281051bb6005da6852e3c1663b92809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb540c3b6650f31ca7695cb2bccd69cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afb540c3b6650f31ca7695cb2bccd69cb">encodeBinary</a> (<a class="el" href="classqi_1_1Buffer.html">qi::Buffer</a> *buf, const <a class="el" href="classqi_1_1AutoAnyReference.html">AutoAnyReference</a> &amp;gvp, <a class="el" href="namespaceqi.html#a0df728403f2294ca5d26f2e34d64852c">SerializeObjectCallback</a> onObject=<a class="el" href="namespaceqi.html#a0df728403f2294ca5d26f2e34d64852c">SerializeObjectCallback</a>(), StreamContext *ctx=0)</td></tr>
<tr class="separator:afb540c3b6650f31ca7695cb2bccd69cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16af60016b63fd1947d059e73bc597a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a16af60016b63fd1947d059e73bc597a9">decodeBinary</a> (<a class="el" href="classqi_1_1BufferReader.html">qi::BufferReader</a> *buf, <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> gvp, <a class="el" href="namespaceqi.html#a3d1810ab9faa895cc000a83e477570ef">DeserializeObjectCallback</a> onObject=<a class="el" href="namespaceqi.html#a3d1810ab9faa895cc000a83e477570ef">DeserializeObjectCallback</a>(), StreamContext *ctx=0)</td></tr>
<tr class="separator:a16af60016b63fd1947d059e73bc597a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b10163de67d05dffe73b58463f68bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> <br class="typebreak"/>
<a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">SteadyClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a38b10163de67d05dffe73b58463f68bc">steadyClockNow</a> ()</td></tr>
<tr class="memdesc:a38b10163de67d05dffe73b58463f68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a time_point representing the current value of the clock.  <a href="#a38b10163de67d05dffe73b58463f68bc">More...</a><br/></td></tr>
<tr class="separator:a38b10163de67d05dffe73b58463f68bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d59e14f6a062febe8b365891879346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> <br class="typebreak"/>
<a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a82d59e14f6a062febe8b365891879346">wallClockNow</a> ()</td></tr>
<tr class="memdesc:a82d59e14f6a062febe8b365891879346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a time_point representing the current value of the clock.  <a href="#a82d59e14f6a062febe8b365891879346">More...</a><br/></td></tr>
<tr class="separator:a82d59e14f6a062febe8b365891879346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1259c32b2756fc157487bdb049443e9"><td class="memTemplParams" colspan="2">template&lt;class R , class P &gt; </td></tr>
<tr class="memitem:ab1259c32b2756fc157487bdb049443e9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ab1259c32b2756fc157487bdb049443e9">to_string</a> (const <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; R, P &gt; &amp;d)</td></tr>
<tr class="separator:ab1259c32b2756fc157487bdb049443e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c3096fbdc5499e98fb992f8b3a1ff1"><td class="memTemplParams" colspan="2">template&lt;class C , class D &gt; </td></tr>
<tr class="memitem:a55c3096fbdc5499e98fb992f8b3a1ff1"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a55c3096fbdc5499e98fb992f8b3a1ff1">to_string</a> (const boost::chrono::time_point&lt; C, D &gt; &amp;t)</td></tr>
<tr class="separator:a55c3096fbdc5499e98fb992f8b3a1ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342cbb877923284a84ec54f51a4009c4"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a342cbb877923284a84ec54f51a4009c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a342cbb877923284a84ec54f51a4009c4">sleepFor</a> (const boost::chrono::duration&lt; Rep, Period &gt; &amp;d)</td></tr>
<tr class="separator:a342cbb877923284a84ec54f51a4009c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74a830e15fdc58d8a32a5ec1c38d32"><td class="memTemplParams" colspan="2">template&lt;class R , class P &gt; </td></tr>
<tr class="memitem:afe74a830e15fdc58d8a32a5ec1c38d32"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afe74a830e15fdc58d8a32a5ec1c38d32">to_string</a> (const boost::chrono::duration&lt; R, P &gt; &amp;d)</td></tr>
<tr class="separator:afe74a830e15fdc58d8a32a5ec1c38d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d3fe036a58d21b7fe41fb71bf4cd95"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a86d3fe036a58d21b7fe41fb71bf4cd95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a86d3fe036a58d21b7fe41fb71bf4cd95">nullConverter</a> (void *, R &amp;)</td></tr>
<tr class="separator:a86d3fe036a58d21b7fe41fb71bf4cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14f72235d0dd750a72c972d59d6531a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad14f72235d0dd750a72c972d59d6531a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad14f72235d0dd750a72c972d59d6531a">makeFutureError</a> (const std::string &amp;error)</td></tr>
<tr class="memdesc:ad14f72235d0dd750a72c972d59d6531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to return a future with the error set.  <a href="#ad14f72235d0dd750a72c972d59d6531a">More...</a><br/></td></tr>
<tr class="separator:ad14f72235d0dd750a72c972d59d6531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb85d5edf8d351adc8212994bd237506"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:acb85d5edf8d351adc8212994bd237506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#acb85d5edf8d351adc8212994bd237506">adaptFutureUnwrap</a> (<a class="el" href="classqi_1_1Future.html">Future</a>&lt; <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &gt; &amp;f, <a class="el" href="classqi_1_1Promise.html">Promise</a>&lt; R &gt; &amp;p)</td></tr>
<tr class="memdesc:acb85d5edf8d351adc8212994bd237506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed a promise from a generic future which may be unwrapped if it contains itself a future.  <a href="#acb85d5edf8d351adc8212994bd237506">More...</a><br/></td></tr>
<tr class="separator:acb85d5edf8d351adc8212994bd237506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc720bd5b8f355e73363ff256c2986"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename PT &gt; </td></tr>
<tr class="memitem:a42bc720bd5b8f355e73363ff256c2986"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a42bc720bd5b8f355e73363ff256c2986">adaptFuture</a> (const <a class="el" href="classqi_1_1Future.html">Future</a>&lt; FT &gt; &amp;f, <a class="el" href="classqi_1_1Promise.html">Promise</a>&lt; PT &gt; &amp;p, <a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32">AdaptFutureOption</a> option=<a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32a2416fcefdc9fcdd947e1f2d76f4e11c0">AdaptFutureOption_ForwardCancel</a>)</td></tr>
<tr class="memdesc:a42bc720bd5b8f355e73363ff256c2986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed a promise from a future of possibly different type.  <a href="#a42bc720bd5b8f355e73363ff256c2986">More...</a><br/></td></tr>
<tr class="separator:a42bc720bd5b8f355e73363ff256c2986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6713195abab6fc700564cf545f642e6e"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename PT , typename CONV &gt; </td></tr>
<tr class="memitem:a6713195abab6fc700564cf545f642e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6713195abab6fc700564cf545f642e6e">adaptFuture</a> (const <a class="el" href="classqi_1_1Future.html">Future</a>&lt; FT &gt; &amp;f, <a class="el" href="classqi_1_1Promise.html">Promise</a>&lt; PT &gt; &amp;p, CONV converter, <a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32">AdaptFutureOption</a> option=<a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32a2416fcefdc9fcdd947e1f2d76f4e11c0">AdaptFutureOption_ForwardCancel</a>)</td></tr>
<tr class="memdesc:a6713195abab6fc700564cf545f642e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to adaptFuture(f, p) but with a custom converter.  <a href="#a6713195abab6fc700564cf545f642e6e">More...</a><br/></td></tr>
<tr class="separator:a6713195abab6fc700564cf545f642e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f62627a6f2a44b0d81ab2553827d00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82f62627a6f2a44b0d81ab2553827d00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a82f62627a6f2a44b0d81ab2553827d00">toAnyValueFuture</a> (<a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; future)</td></tr>
<tr class="separator:a82f62627a6f2a44b0d81ab2553827d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7719b3342ffcb84708136cfd6cb1c8ff"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7719b3342ffcb84708136cfd6cb1c8ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a7719b3342ffcb84708136cfd6cb1c8ff">toAnyValueFuture</a> (<a class="el" href="classqi_1_1Future.html">Future</a>&lt; void &gt; future)</td></tr>
<tr class="separator:a7719b3342ffcb84708136cfd6cb1c8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e17bcab021ca6d6bbcdcd7a7401781"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a11e17bcab021ca6d6bbcdcd7a7401781">operator&lt;&lt;</a> (std::ostream &amp;o, <a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51">FutureState</a> x)</td></tr>
<tr class="separator:a11e17bcab021ca6d6bbcdcd7a7401781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1a7c27d89691523d3009a02285169c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b1a7c27d89691523d3009a02285169c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5b1a7c27d89691523d3009a02285169c">PromiseNoop</a> (<a class="el" href="classqi_1_1Promise.html">qi::Promise</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a5b1a7c27d89691523d3009a02285169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b4c5ca7029f9c9b94be4c92f0aa1d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90b4c5ca7029f9c9b94be4c92f0aa1d3"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; void()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a90b4c5ca7029f9c9b94be4c92f0aa1d3">makeCanceler</a> (<a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; &amp;future)</td></tr>
<tr class="separator:a90b4c5ca7029f9c9b94be4c92f0aa1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b03843ce5c18a2014bd3661dfc29d6b"><td class="memTemplParams" colspan="2">template&lt;typename Proc &gt; </td></tr>
<tr class="memitem:a8b03843ce5c18a2014bd3661dfc29d6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8b03843ce5c18a2014bd3661dfc29d6b">futurizeOutput</a> (Proc &amp;&amp;p) -&gt; decltype(<a class="el" href="namespaceqi.html#ad68b84808e78bf348b4835101bbf1676">semiLift</a>(std::forward&lt; Proc &gt;(p), <a class="el" href="structqi_1_1UnitFuture.html">UnitFuture</a></td></tr>
<tr class="separator:a8b03843ce5c18a2014bd3661dfc29d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a33b40de86d6b6ac2550de54d45e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a221a33b40de86d6b6ac2550de54d45e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1FutureSync.html">qi::FutureSync</a>&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a221a33b40de86d6b6ac2550de54d45e5">waitForAll</a> (std::vector&lt; <a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; &gt; &amp;vect)</td></tr>
<tr class="memdesc:a221a33b40de86d6b6ac2550de54d45e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to wait on a vector of futures.  <a href="#a221a33b40de86d6b6ac2550de54d45e5">More...</a><br/></td></tr>
<tr class="separator:a221a33b40de86d6b6ac2550de54d45e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cac1e0f4ab939ac0b4e9a281d610993"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cac1e0f4ab939ac0b4e9a281d610993"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1FutureSync.html">qi::FutureSync</a>&lt; <a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6cac1e0f4ab939ac0b4e9a281d610993">waitForFirst</a> (std::vector&lt; <a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; &gt; &amp;vect)</td></tr>
<tr class="memdesc:a6cac1e0f4ab939ac0b4e9a281d610993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to wait for the first valid future.  <a href="#a6cac1e0f4ab939ac0b4e9a281d610993">More...</a><br/></td></tr>
<tr class="separator:a6cac1e0f4ab939ac0b4e9a281d610993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ccfd8deefb14a2fe5c90e78fd5c818"><td class="memTemplParams" colspan="2">template&lt;typename RF , typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a24ccfd8deefb14a2fe5c90e78fd5c818"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_function&lt; RF &gt;<br class="typebreak"/>
::value, boost::function&lt; RF &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a24ccfd8deefb14a2fe5c90e78fd5c818">bindWithFallback</a> (boost::function&lt; void()&gt; onFail, AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a24ccfd8deefb14a2fe5c90e78fd5c818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4b9da69c1f056b094ce6521301d6f5"><td class="memTemplParams" colspan="2">template&lt;typename RF , typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a8b4b9da69c1f056b094ce6521301d6f5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_function&lt; RF &gt;<br class="typebreak"/>
::value, boost::function&lt; RF &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8b4b9da69c1f056b094ce6521301d6f5">bindSilent</a> (AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a8b4b9da69c1f056b094ce6521301d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb703d73fee1effe1f0136b0904eafd"><td class="memTemplParams" colspan="2">template&lt;typename RF , typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:adeb703d73fee1effe1f0136b0904eafd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_function&lt; RF &gt;<br class="typebreak"/>
::value, boost::function&lt; RF &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#adeb703d73fee1effe1f0136b0904eafd">bind</a> (AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args)</td></tr>
<tr class="separator:adeb703d73fee1effe1f0136b0904eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65e70e6444329669eebf9aeb876c562"><td class="memTemplParams" colspan="2">template&lt;typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:af65e70e6444329669eebf9aeb876c562"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af65e70e6444329669eebf9aeb876c562">bindWithFallback</a> (boost::function&lt; void()&gt; onFail, AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args) -&gt; typename <a class="el" href="namespaceqi_1_1detail.html#a2ec28e348725b83a633567ec4692dc4b">detail::BindTransform</a>&lt; Arg0 &gt;::template wrap_type&lt; typename <a class="el" href="structqi_1_1detail_1_1WorkaroundVS2015.html">detail::WorkaroundVS2015</a>&lt; AF, Arg0, Args...&gt;::type &gt;</td></tr>
<tr class="separator:af65e70e6444329669eebf9aeb876c562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8420286a730e1b793c3a2f6208add98e"><td class="memTemplParams" colspan="2">template&lt;typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a8420286a730e1b793c3a2f6208add98e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8420286a730e1b793c3a2f6208add98e">bindSilent</a> (AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceqi.html#a24ccfd8deefb14a2fe5c90e78fd5c818">bindWithFallback</a>(</td></tr>
<tr class="separator:a8420286a730e1b793c3a2f6208add98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41601f0d2f297b3f1a984de10e8a9c9d"><td class="memTemplParams" colspan="2">template&lt;typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a41601f0d2f297b3f1a984de10e8a9c9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a41601f0d2f297b3f1a984de10e8a9c9d">bind</a> (AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args) -&gt; decltype(<a class="el" href="namespaceqi.html#a24ccfd8deefb14a2fe5c90e78fd5c818">bindWithFallback</a>(<a class="el" href="namespaceqi_1_1detail.html#a7c81371a8c1eed87561aee61381616da">detail::throwPointerLockException</a>, std::forward&lt; AF &gt;(fun), std::forward&lt; Arg0 &gt;(arg0), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:a41601f0d2f297b3f1a984de10e8a9c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852d1acd8a0824952d478af86474556c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename Instance , typename... Args0, typename... Args1&gt; </td></tr>
<tr class="memitem:a852d1acd8a0824952d478af86474556c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a852d1acd8a0824952d478af86474556c">bind</a> (R(T::*fun)(Args0...), Instance &amp;&amp;instance, Args1 &amp;&amp;...args1) -&gt; decltype(<a class="el" href="namespaceqi.html#a24ccfd8deefb14a2fe5c90e78fd5c818">bindWithFallback</a>(<a class="el" href="namespaceqi_1_1detail.html#a7c81371a8c1eed87561aee61381616da">detail::throwPointerLockException</a>, fun, std::forward&lt; Instance &gt;(instance), std::forward&lt; Args1 &gt;(args1)...))</td></tr>
<tr class="separator:a852d1acd8a0824952d478af86474556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98d4ee31d6e7c8440b43a01d27e2277"><td class="memTemplParams" colspan="2">template&lt;typename R , typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ad98d4ee31d6e7c8440b43a01d27e2277"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad98d4ee31d6e7c8440b43a01d27e2277">bindWithFallback</a> (boost::function&lt; void()&gt; onFail, AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args) -&gt; typename std::enable_if&lt;!std::is_function&lt; R &gt;::value, typename <a class="el" href="namespaceqi_1_1detail.html#a2ec28e348725b83a633567ec4692dc4b">detail::BindTransform</a>&lt; Arg0 &gt;::template wrap_type&lt; decltype(boost::bind&lt; R &gt;(std::forward&lt; AF &gt;(fun), <a class="el" href="namespaceqi_1_1detail.html#a2ec28e348725b83a633567ec4692dc4b">detail::BindTransform</a>&lt; Arg0 &gt;::transform(arg0), std::forward&lt; Args &gt;(args)...))&gt;&gt;::type</td></tr>
<tr class="separator:ad98d4ee31d6e7c8440b43a01d27e2277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9855741a0db80f057536af488980726"><td class="memTemplParams" colspan="2">template&lt;typename R , typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:aa9855741a0db80f057536af488980726"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa9855741a0db80f057536af488980726">bindSilent</a> (AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args) -&gt; typename std::enable_if&lt;!std::is_function&lt; R &gt;::value, decltype(<a class="el" href="namespaceqi.html#a24ccfd8deefb14a2fe5c90e78fd5c818">bindWithFallback</a>&lt; R &gt;(</td></tr>
<tr class="separator:aa9855741a0db80f057536af488980726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80211310d5c4fd6f9768396b14459835"><td class="memTemplParams" colspan="2">template&lt;typename R , typename AF , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a80211310d5c4fd6f9768396b14459835"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a80211310d5c4fd6f9768396b14459835">bind</a> (AF &amp;&amp;fun, Arg0 &amp;&amp;arg0, Args &amp;&amp;...args) -&gt; typename std::enable_if&lt;!std::is_function&lt; R &gt;::value, decltype(<a class="el" href="namespaceqi.html#a24ccfd8deefb14a2fe5c90e78fd5c818">bindWithFallback</a>&lt; R &gt;(<a class="el" href="namespaceqi_1_1detail.html#a7c81371a8c1eed87561aee61381616da">detail::throwPointerLockException</a>, std::forward&lt; AF &gt;(fun), std::forward&lt; Arg0 &gt;(arg0), std::forward&lt; Args &gt;(args)...))&gt;::type</td></tr>
<tr class="separator:a80211310d5c4fd6f9768396b14459835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec0fdbbbf4a3e42952da2a43c42fa9f"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:afec0fdbbbf4a3e42952da2a43c42fa9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afec0fdbbbf4a3e42952da2a43c42fa9f">trackWithFallback</a> (boost::function&lt; void()&gt; onFail, F &amp;&amp;f, T &amp;&amp;toTrack) -&gt; decltype(<a class="el" href="namespaceqi_1_1detail.html#a2ec28e348725b83a633567ec4692dc4b">detail::BindTransform</a>&lt; T &gt;::wrap(std::forward&lt; T &gt;(toTrack), std::forward&lt; F &gt;(f), std::move(onFail)))</td></tr>
<tr class="separator:afec0fdbbbf4a3e42952da2a43c42fa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cc706ceb17407798ebc096948fc43f"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a99cc706ceb17407798ebc096948fc43f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a99cc706ceb17407798ebc096948fc43f">track</a> (F &amp;&amp;f, T &amp;&amp;toTrack) -&gt; decltype(<a class="el" href="namespaceqi.html#afec0fdbbbf4a3e42952da2a43c42fa9f">trackWithFallback</a>(<a class="el" href="namespaceqi_1_1detail.html#a7c81371a8c1eed87561aee61381616da">detail::throwPointerLockException</a>, std::forward&lt; F &gt;(f), std::forward&lt; T &gt;(toTrack)))</td></tr>
<tr class="separator:a99cc706ceb17407798ebc096948fc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98848ce746c8b0be72f3b3808ac58879"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a98848ce746c8b0be72f3b3808ac58879"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a98848ce746c8b0be72f3b3808ac58879">trackSilent</a> (F &amp;&amp;f, T &amp;&amp;toTrack) -&gt; decltype(<a class="el" href="namespaceqi.html#afec0fdbbbf4a3e42952da2a43c42fa9f">trackWithFallback</a>(</td></tr>
<tr class="separator:a98848ce746c8b0be72f3b3808ac58879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c75972b852dbcbe852147732b2bf493"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a3c75972b852dbcbe852147732b2bf493"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a3c75972b852dbcbe852147732b2bf493">trackWithFallback</a> (boost::function&lt; void()&gt; onFail, boost::function&lt; F &gt; f, const T &amp;toTrack)</td></tr>
<tr class="separator:a3c75972b852dbcbe852147732b2bf493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431cbd0bdbc9dee42145337c2e3765d0"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a431cbd0bdbc9dee42145337c2e3765d0"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a431cbd0bdbc9dee42145337c2e3765d0">trackSilent</a> (boost::function&lt; F &gt; f, const T &amp;toTrack)</td></tr>
<tr class="separator:a431cbd0bdbc9dee42145337c2e3765d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890339ae56ba90c3fde5eb7fd91679d8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a890339ae56ba90c3fde5eb7fd91679d8"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a890339ae56ba90c3fde5eb7fd91679d8">track</a> (boost::function&lt; F &gt; f, const T &amp;toTrack)</td></tr>
<tr class="separator:a890339ae56ba90c3fde5eb7fd91679d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f866008cc174c5c3bbfe1aa53854d"><td class="memTemplParams" colspan="2">template&lt;typename Proc , typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a794f866008cc174c5c3bbfe1aa53854d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a794f866008cc174c5c3bbfe1aa53854d">invokeCatch</a> (Proc &amp;&amp;handleException, F &amp;&amp;f, Args &amp;&amp;...args) -&gt; decltype(std::forward&lt; F &gt;(f)(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:a794f866008cc174c5c3bbfe1aa53854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a56d0b369a9a5eeb3655db91c684c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1EventLoop.html">EventLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac6a56d0b369a9a5eeb3655db91c684c4">getEventLoop</a> ()</td></tr>
<tr class="memdesc:ac6a56d0b369a9a5eeb3655db91c684c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global eventloop, created on demand on first call.  <a href="#ac6a56d0b369a9a5eeb3655db91c684c4">More...</a><br/></td></tr>
<tr class="separator:ac6a56d0b369a9a5eeb3655db91c684c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43ba1400740a437a2ef3e2f70a5525f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1EventLoop.html">EventLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa43ba1400740a437a2ef3e2f70a5525f">getNetworkEventLoop</a> ()</td></tr>
<tr class="memdesc:aa43ba1400740a437a2ef3e2f70a5525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global network eventloop, created on demand on first call.  <a href="#aa43ba1400740a437a2ef3e2f70a5525f">More...</a><br/></td></tr>
<tr class="separator:aa43ba1400740a437a2ef3e2f70a5525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeed22e4f35d2e93eac1fec0ff4dd48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5eeed22e4f35d2e93eac1fec0ff4dd48">startEventLoop</a> (int nthread)</td></tr>
<tr class="memdesc:a5eeed22e4f35d2e93eac1fec0ff4dd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the eventloop with nthread threads. Does nothing if already started.  <a href="#a5eeed22e4f35d2e93eac1fec0ff4dd48">More...</a><br/></td></tr>
<tr class="separator:a5eeed22e4f35d2e93eac1fec0ff4dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ee2a95759c087e0cdadbe608a1ac59"><td class="memItemLeft" align="right" valign="top">boost::asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa3ee2a95759c087e0cdadbe608a1ac59">getIoService</a> ()</td></tr>
<tr class="memdesc:aa3ee2a95759c087e0cdadbe608a1ac59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the io_service used by the global event loop.  <a href="#aa3ee2a95759c087e0cdadbe608a1ac59">More...</a><br/></td></tr>
<tr class="separator:aa3ee2a95759c087e0cdadbe608a1ac59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f06858a9b60b22be750c329a7b9161"><td class="memTemplParams" colspan="2">template&lt;typename E , typename  = traits::EnableIf&lt;std::is_enum&lt;E&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a03f06858a9b60b22be750c329a7b9161"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a03f06858a9b60b22be750c329a7b9161">underlying</a> (const E &amp;e) -&gt; <a class="el" href="namespaceqi_1_1traits.html#aa6d3e0a41d483c44e2e62e4d620d5c67">traits::UnderlyingType</a>&lt; E &gt;</td></tr>
<tr class="separator:a03f06858a9b60b22be750c329a7b9161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd78c5617e5e124c476e7249b55338a"><td class="memTemplParams" colspan="2">template&lt;typename G , typename F &gt; </td></tr>
<tr class="memitem:a5cd78c5617e5e124c476e7249b55338a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1Composition.html">Composition</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; G &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5cd78c5617e5e124c476e7249b55338a">compose</a> (G &amp;&amp;g, F &amp;&amp;f)</td></tr>
<tr class="separator:a5cd78c5617e5e124c476e7249b55338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68b84808e78bf348b4835101bbf1676"><td class="memTemplParams" colspan="2">template&lt;typename Proc , typename F &gt; </td></tr>
<tr class="memitem:ad68b84808e78bf348b4835101bbf1676"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad68b84808e78bf348b4835101bbf1676">semiLift</a> (Proc &amp;&amp;p, F &amp;&amp;unit) -&gt; decltype(<a class="el" href="namespaceqi.html#a5cd78c5617e5e124c476e7249b55338a">compose</a>(std::forward&lt; F &gt;(unit), std::forward&lt; Proc &gt;(p)))</td></tr>
<tr class="separator:ad68b84808e78bf348b4835101bbf1676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0d4bdf8a789f784658ded47e0d917a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb0d4bdf8a789f784658ded47e0d917a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1DataBoundTransfo.html">DataBoundTransfo</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afb0d4bdf8a789f784658ded47e0d917a">dataBoundTransfo</a> (const T &amp;maintainAlive)</td></tr>
<tr class="memdesc:afb0d4bdf8a789f784658ded47e0d917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to deduce types for <a class="el" href="structqi_1_1DataBoundTransfo.html">DataBoundTransfo</a>.  <a href="#afb0d4bdf8a789f784658ded47e0d917a">More...</a><br/></td></tr>
<tr class="separator:afb0d4bdf8a789f784658ded47e0d917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ec8195dad170930fdfb6a976e87f4b"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Src &gt; </td></tr>
<tr class="memitem:a98ec8195dad170930fdfb6a976e87f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1MoveAssign.html">MoveAssign</a>&lt; Dest, <br class="typebreak"/>
<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; Src &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a98ec8195dad170930fdfb6a976e87f4b">makeMoveAssign</a> (Src &amp;&amp;s)</td></tr>
<tr class="memdesc:a98ec8195dad170930fdfb6a976e87f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that performs type deduction for <code><a class="el" href="structqi_1_1MoveAssign.html">MoveAssign</a></code>.  <a href="#a98ec8195dad170930fdfb6a976e87f4b">More...</a><br/></td></tr>
<tr class="separator:a98ec8195dad170930fdfb6a976e87f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2923b7870efab6ce589a4eafa051318"><td class="memTemplParams" colspan="2">template&lt;typename Proc , typename Args &gt; </td></tr>
<tr class="memitem:ad2923b7870efab6ce589a4eafa051318"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CONSTEXPR auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a> (Proc &amp;&amp;proc, Args &amp;&amp;args) -&gt; decltype(<a class="el" href="namespaceqi_1_1detail.html#a1a55fe6996bc918536b3353d81a83cfb">detail::applyImpl</a>(<a class="el" href="namespaceqi.html#aea73608226c5ebcb2ec776cb48326542">fwd</a>&lt; Proc &gt;(proc), <a class="el" href="namespaceqi.html#aea73608226c5ebcb2ec776cb48326542">fwd</a>&lt; Args &gt;(args), <a class="el" href="namespaceqi.html#a0be2335ae913e30603739c3c0ea0a00b">make_index_sequence</a>&lt; std::tuple_size&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; Args &gt;&gt;::value &gt;</td></tr>
<tr class="separator:ad2923b7870efab6ce589a4eafa051318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad097f61d76320a9c07fee60e835ec987"><td class="memTemplParams" colspan="2">template&lt;typename Proc &gt; </td></tr>
<tr class="memitem:ad097f61d76320a9c07fee60e835ec987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1Apply.html">Apply</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; Proc &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad097f61d76320a9c07fee60e835ec987">apply</a> (Proc &amp;&amp;proc)</td></tr>
<tr class="separator:ad097f61d76320a9c07fee60e835ec987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a334ec73532dfe9ad81a52ab498c7f"><td class="memTemplParams" colspan="2">template&lt;typename Proc , typename M &gt; </td></tr>
<tr class="memitem:a33a334ec73532dfe9ad81a52ab498c7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1ScopeLockProc.html">ScopeLockProc</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a><br class="typebreak"/>
&lt; Proc &gt;, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; M &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a33a334ec73532dfe9ad81a52ab498c7f">scopeLockProc</a> (Proc &amp;&amp;proc, M &amp;&amp;mutLockable)</td></tr>
<tr class="separator:a33a334ec73532dfe9ad81a52ab498c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e3524f08c9d697214c828d365b812d"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ae7e3524f08c9d697214c828d365b812d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1ScopeLockTransfo.html">ScopeLockTransfo</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; M &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae7e3524f08c9d697214c828d365b812d">scopeLockTransfo</a> (M &amp;&amp;mutLockable)</td></tr>
<tr class="separator:ae7e3524f08c9d697214c828d365b812d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbf6e86e09a9069786dfcc083b82074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321">StreamColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abdbf6e86e09a9069786dfcc083b82074">enabledColor</a> (<a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321">StreamColor</a> color, bool enable=true)</td></tr>
<tr class="memdesc:abdbf6e86e09a9069786dfcc083b82074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>color</code> if <code>enable</code> is true, otherwise returns no color.  <a href="#abdbf6e86e09a9069786dfcc083b82074">More...</a><br/></td></tr>
<tr class="separator:abdbf6e86e09a9069786dfcc083b82074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05c81e881944949765491389e879e78"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac05c81e881944949765491389e879e78">encodeJSON</a> (const <a class="el" href="classqi_1_1AutoAnyReference.html">qi::AutoAnyReference</a> &amp;val, <a class="el" href="namespaceqi.html#a7c8b83d91c31225480036795fee7ce38">JsonOption</a> jsonPrintOption=<a class="el" href="namespaceqi.html#ad5d0c6e0eeb368ebee10e1f66ced08a3">JsonOption_None</a>)</td></tr>
<tr class="separator:ac05c81e881944949765491389e879e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0f8ab49ff6d865e791e8fd84ffa212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyValue.html">qi::AnyValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abc0f8ab49ff6d865e791e8fd84ffa212">decodeJSON</a> (const std::string &amp;in)</td></tr>
<tr class="separator:abc0f8ab49ff6d865e791e8fd84ffa212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbddfd2b5c63e97a33bb1f4583a64ad"><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aefbddfd2b5c63e97a33bb1f4583a64ad">decodeJSON</a> (const std::string::const_iterator &amp;begin, const std::string::const_iterator &amp;end, <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;target)</td></tr>
<tr class="separator:aefbddfd2b5c63e97a33bb1f4583a64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc6dd0b5694ff4d27c7b027683040b0"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a5fc6dd0b5694ff4d27c7b027683040b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1MoveOnCopy.html">MoveOnCopy</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; T &gt;...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5fc6dd0b5694ff4d27c7b027683040b0">makeMoveOnCopy</a> (T &amp;&amp;...t)</td></tr>
<tr class="memdesc:a5fc6dd0b5694ff4d27c7b027683040b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to perform type deduction for constructing a <a class="el" href="classqi_1_1MoveOnCopy.html">MoveOnCopy</a>.  <a href="#a5fc6dd0b5694ff4d27c7b027683040b0">More...</a><br/></td></tr>
<tr class="separator:a5fc6dd0b5694ff4d27c7b027683040b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae119360c94e8f9f5c9f1ba9313317c79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae119360c94e8f9f5c9f1ba9313317c79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a>&lt; <a class="el" href="namespaceqi_1_1detail.html#ab8df1459137c970236482a85c81ede7f">detail::Raw</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1detail.html#ab8df1459137c970236482a85c81ede7f">detail::Raw</a>&lt; T &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae119360c94e8f9f5c9f1ba9313317c79">makeMutableStore</a> (T &amp;&amp;t)</td></tr>
<tr class="separator:ae119360c94e8f9f5c9f1ba9313317c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521d440f7a71f8bda469824ad8a46fbf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a521d440f7a71f8bda469824ad8a46fbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; T &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a521d440f7a71f8bda469824ad8a46fbf">makeMutableStoreFwd</a> (T &amp;&amp;t)</td></tr>
<tr class="separator:a521d440f7a71f8bda469824ad8a46fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefc7d2d6bfea0ac920f877752234493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#a827eae44eb9f8ca4154e87014b3720ec">codecvt_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afefc7d2d6bfea0ac920f877752234493">unicodeFacet</a> ()</td></tr>
<tr class="memdesc:afefc7d2d6bfea0ac920f877752234493"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 facet object getter.  <a href="#afefc7d2d6bfea0ac920f877752234493">More...</a><br/></td></tr>
<tr class="separator:afefc7d2d6bfea0ac920f877752234493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f7c49ded676ae47ef49ed3d148ccab"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a78f7c49ded676ae47ef49ed3d148ccab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a78f7c49ded676ae47ef49ed3d148ccab">front</a> (const <a class="el" href="structqi_1_1BoundedRange.html">BoundedRange</a>&lt; I &gt; &amp;x) -&gt; decltype(*x.b)</td></tr>
<tr class="memdesc:a78f7c49ded676ae47ef49ed3d148ccab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precondition: !isEmpty(x)  <a href="#a78f7c49ded676ae47ef49ed3d148ccab">More...</a><br/></td></tr>
<tr class="separator:a78f7c49ded676ae47ef49ed3d148ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f9911f327625384b40df3b77b91e1b"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a90f9911f327625384b40df3b77b91e1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a90f9911f327625384b40df3b77b91e1b">front</a> (<a class="el" href="structqi_1_1BoundedRange.html">BoundedRange</a>&lt; I &gt; &amp;x) -&gt; decltype(*x.b)</td></tr>
<tr class="memdesc:a90f9911f327625384b40df3b77b91e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precondition: !isEmpty(x)  <a href="#a90f9911f327625384b40df3b77b91e1b">More...</a><br/></td></tr>
<tr class="separator:a90f9911f327625384b40df3b77b91e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b632e7d53ca5acaf7cc97c66b17e99"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ae1b632e7d53ca5acaf7cc97c66b17e99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae1b632e7d53ca5acaf7cc97c66b17e99">boundedRange</a> (S &amp;s) -&gt; <a class="el" href="structqi_1_1BoundedRange.html">BoundedRange</a>&lt; decltype(begin(s))&gt;</td></tr>
<tr class="memdesc:ae1b632e7d53ca5acaf7cc97c66b17e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence S.  <a href="#ae1b632e7d53ca5acaf7cc97c66b17e99">More...</a><br/></td></tr>
<tr class="separator:ae1b632e7d53ca5acaf7cc97c66b17e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dfda437b43d1cbd65276236bb5e2ff"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a23dfda437b43d1cbd65276236bb5e2ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1BoundedRange.html">BoundedRange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a23dfda437b43d1cbd65276236bb5e2ff">boundedRange</a> (I b, I e)</td></tr>
<tr class="separator:a23dfda437b43d1cbd65276236bb5e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e094e4b1ee68b7e4890063f7848a5a9"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a6e094e4b1ee68b7e4890063f7848a5a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6e094e4b1ee68b7e4890063f7848a5a9">incrRange</a> (N &amp;&amp;b, N &amp;&amp;e)</td></tr>
<tr class="separator:a6e094e4b1ee68b7e4890063f7848a5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d75a3cdf9b7b89ac09dbc684f3c678b"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a1d75a3cdf9b7b89ac09dbc684f3c678b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a1d75a3cdf9b7b89ac09dbc684f3c678b">incrRange</a> (N &amp;&amp;e)</td></tr>
<tr class="separator:a1d75a3cdf9b7b89ac09dbc684f3c678b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21578104a134d3507d8152f05a99e3c8"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a21578104a134d3507d8152f05a99e3c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a21578104a134d3507d8152f05a99e3c8">incrRange</a> ()</td></tr>
<tr class="memdesc:a21578104a134d3507d8152f05a99e3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic N.  <a href="#a21578104a134d3507d8152f05a99e3c8">More...</a><br/></td></tr>
<tr class="separator:a21578104a134d3507d8152f05a99e3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57822b00c360f76c573a0b4e57bfb5d4"><td class="memTemplParams" colspan="2">template&lt;typename N , typename A &gt; </td></tr>
<tr class="memitem:a57822b00c360f76c573a0b4e57bfb5d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1IncrBoundedRangeAction.html">IncrBoundedRangeAction</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; N &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a57822b00c360f76c573a0b4e57bfb5d4">incrRange</a> (N &amp;&amp;b, N &amp;&amp;e, A &amp;&amp;incr)</td></tr>
<tr class="separator:a57822b00c360f76c573a0b4e57bfb5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a8299efe2331d67dee28e2c3b953f9"><td class="memTemplParams" colspan="2">template&lt;typename N , typename A &gt; </td></tr>
<tr class="memitem:ab6a8299efe2331d67dee28e2c3b953f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1IncrBoundedRangeAction.html">IncrBoundedRangeAction</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; N &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ab6a8299efe2331d67dee28e2c3b953f9">incrRange</a> (N &amp;&amp;e, A &amp;&amp;incr)</td></tr>
<tr class="separator:ab6a8299efe2331d67dee28e2c3b953f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d1120e34b4cc74c02accf512c3f6b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:ace6d1120e34b4cc74c02accf512c3f6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1RepeatRange.html">RepeatRange</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ace6d1120e34b4cc74c02accf512c3f6b">repeatRange</a> (T &amp;&amp;a, N &amp;&amp;end)</td></tr>
<tr class="separator:ace6d1120e34b4cc74c02accf512c3f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676caa123f59d84d4f0fe085f96e6e6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a676caa123f59d84d4f0fe085f96e6e6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1Scoped.html">Scoped</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a676caa123f59d84d4f0fe085f96e6e6f">scoped</a> (T &amp;&amp;value, F &amp;&amp;f)</td></tr>
<tr class="separator:a676caa123f59d84d4f0fe085f96e6e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8149de1afdcf1e0dc403be71daa51b18"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a8149de1afdcf1e0dc403be71daa51b18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1Scoped.html">Scoped</a>&lt; void, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8149de1afdcf1e0dc403be71daa51b18">scoped</a> (F &amp;&amp;f)</td></tr>
<tr class="separator:a8149de1afdcf1e0dc403be71daa51b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9386f4efcbaab68069500a86674df8ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename G &gt; </td></tr>
<tr class="memitem:a9386f4efcbaab68069500a86674df8ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a9386f4efcbaab68069500a86674df8ad">scopedApplyAndRetract</a> (T &amp;value, F &amp;&amp;f, G &amp;&amp;retraction) -&gt; <a class="el" href="structqi_1_1Scoped.html">Scoped</a>&lt; std::reference_wrapper&lt; T &gt;, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; G &gt;&gt;</td></tr>
<tr class="memdesc:a9386f4efcbaab68069500a86674df8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action&lt;T&gt; F, Action&lt;T&gt; G.  <a href="#a9386f4efcbaab68069500a86674df8ad">More...</a><br/></td></tr>
<tr class="separator:a9386f4efcbaab68069500a86674df8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fea5fdf4171f2492f5b5be826df500"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a71fea5fdf4171f2492f5b5be826df500"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a71fea5fdf4171f2492f5b5be826df500">scopedApplyAndRetract</a> (T &amp;value, F &amp;&amp;f) -&gt; <a class="el" href="structqi_1_1Scoped.html">Scoped</a>&lt; std::reference_wrapper&lt; T &gt;, <a class="el" href="namespaceqi_1_1vs13.html#a92a7144344ff6eb67abdcde749d9e4b4">vs13::Retract</a>&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; F &gt;&gt;&gt;</td></tr>
<tr class="separator:a71fea5fdf4171f2492f5b5be826df500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadde7a66bbf0a9b1b9b57e09d9a7fcc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abadde7a66bbf0a9b1b9b57e09d9a7fcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abadde7a66bbf0a9b1b9b57e09d9a7fcc">scopedSetAndRestore</a> (T &amp;value, U &amp;&amp;newValue) -&gt; decltype(<a class="el" href="namespaceqi.html#a9386f4efcbaab68069500a86674df8ad">scopedApplyAndRetract</a>(value, <a class="el" href="namespaceqi.html#a98ec8195dad170930fdfb6a976e87f4b">makeMoveAssign</a>&lt; T &gt;(<a class="el" href="namespaceqi.html#aea73608226c5ebcb2ec776cb48326542">fwd</a>&lt; U &gt;(newValue)), <a class="el" href="namespaceqi.html#a98ec8195dad170930fdfb6a976e87f4b">makeMoveAssign</a>&lt; T &gt;(std::move(value))))</td></tr>
<tr class="separator:abadde7a66bbf0a9b1b9b57e09d9a7fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc353c7c828ba1e98e3340604475e49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:addc353c7c828ba1e98e3340604475e49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#addc353c7c828ba1e98e3340604475e49">scopedIncrAndDecr</a> (T &amp;value) -&gt; decltype(<a class="el" href="namespaceqi.html#a9386f4efcbaab68069500a86674df8ad">scopedApplyAndRetract</a>(value, <a class="el" href="structqi_1_1Incr.html">Incr</a>&lt; T &gt;</td></tr>
<tr class="separator:addc353c7c828ba1e98e3340604475e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e80758d48f7fc287d29980eb0e6565"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a19e80758d48f7fc287d29980eb0e6565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#ae3cc5a91e6d98c912baaa84d6ff3e54c">SessionPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a19e80758d48f7fc287d29980eb0e6565">makeSession</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a19e80758d48f7fc287d29980eb0e6565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8199ee4e592ad4e5a704d44eefac588b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8199ee4e592ad4e5a704d44eefac588b">signatureSplit</a> (const std::string &amp;fullSignature)</td></tr>
<tr class="separator:a8199ee4e592ad4e5a704d44eefac588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e7b45e3cfcd1b27585b5776c268642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a57e7b45e3cfcd1b27585b5776c268642">makeTupleSignature</a> (const std::vector&lt; <a class="el" href="classqi_1_1AnyReference.html">qi::AnyReference</a> &gt; &amp;vgv, bool resolveDynamic=false, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;())</td></tr>
<tr class="separator:a57e7b45e3cfcd1b27585b5776c268642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f39be2e53755f32bc54f278b92f6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa0f39be2e53755f32bc54f278b92f6dc">makeTupleSignature</a> (const std::vector&lt; <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> * &gt; &amp;vgv, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;())</td></tr>
<tr class="separator:aa0f39be2e53755f32bc54f278b92f6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa258277993d928c87aed1a62bc8d900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aaa258277993d928c87aed1a62bc8d900">makeTupleSignature</a> (const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;element)</td></tr>
<tr class="separator:aaa258277993d928c87aed1a62bc8d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e3b32ae885f36dc89d1f72f91878bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a03e3b32ae885f36dc89d1f72f91878bd">makeListSignature</a> (const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;element)</td></tr>
<tr class="separator:a03e3b32ae885f36dc89d1f72f91878bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67377d0f4a7dddc54912d96031b4b06e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a67377d0f4a7dddc54912d96031b4b06e">makeVarArgsSignature</a> (const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;element)</td></tr>
<tr class="separator:a67377d0f4a7dddc54912d96031b4b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481997bd83b95542e6372d1d94456022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a481997bd83b95542e6372d1d94456022">makeKwArgsSignature</a> (const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;element)</td></tr>
<tr class="separator:a481997bd83b95542e6372d1d94456022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4e963b37472078c2a9d927b44ef97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0e4e963b37472078c2a9d927b44ef97d">makeMapSignature</a> (const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;key, const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;value)</td></tr>
<tr class="separator:a0e4e963b37472078c2a9d927b44ef97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac398d2fe06ebe5fdef4da056f35be095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac398d2fe06ebe5fdef4da056f35be095">operator!=</a> (const <a class="el" href="classqi_1_1Signature.html">Signature</a> &amp;lhs, const <a class="el" href="classqi_1_1Signature.html">Signature</a> &amp;rhs)</td></tr>
<tr class="separator:ac398d2fe06ebe5fdef4da056f35be095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df69be73d369666577f9d4b2cd8dd78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6df69be73d369666577f9d4b2cd8dd78">operator==</a> (const <a class="el" href="classqi_1_1Signature.html">Signature</a> &amp;lhs, const <a class="el" href="classqi_1_1Signature.html">Signature</a> &amp;rhs)</td></tr>
<tr class="separator:a6df69be73d369666577f9d4b2cd8dd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ca99743b6c820547dea46057a73ae0"><td class="memTemplParams" colspan="2">template&lt;typename RF , typename AF &gt; </td></tr>
<tr class="memitem:a22ca99743b6c820547dea46057a73ae0"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; RF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a22ca99743b6c820547dea46057a73ae0">bind</a> (const AF &amp;fun,...)</td></tr>
<tr class="separator:a22ca99743b6c820547dea46057a73ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9b0842d355f980ce85f11904a27b56"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ARG0 &gt; </td></tr>
<tr class="memitem:a9f9b0842d355f980ce85f11904a27b56"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a9f9b0842d355f980ce85f11904a27b56">track</a> (boost::function&lt; F &gt; f, const ARG0 &amp;arg0)</td></tr>
<tr class="memdesc:a9f9b0842d355f980ce85f11904a27b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> instance.  <a href="#a9f9b0842d355f980ce85f11904a27b56">More...</a><br/></td></tr>
<tr class="separator:a9f9b0842d355f980ce85f11904a27b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c311c861d4adb37f2bde6cd0e5f2f5"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ARG0 &gt; </td></tr>
<tr class="memitem:a73c311c861d4adb37f2bde6cd0e5f2f5"><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a73c311c861d4adb37f2bde6cd0e5f2f5">trackWithFallback</a> (boost::function&lt; void()&gt; onFail, boost::function&lt; F &gt; f, const ARG0 &amp;arg0)</td></tr>
<tr class="memdesc:a73c311c861d4adb37f2bde6cd0e5f2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> instance.  <a href="#a73c311c861d4adb37f2bde6cd0e5f2f5">More...</a><br/></td></tr>
<tr class="separator:a73c311c861d4adb37f2bde6cd0e5f2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2280708fe591ee73844f207c610cff"><td class="memTemplParams" colspan="2">template&lt;typename Proc , typename T &gt; </td></tr>
<tr class="memitem:a0e2280708fe591ee73844f207c610cff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1TrackWithFallbackTransfo.html">TrackWithFallbackTransfo</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt; Proc &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0e2280708fe591ee73844f207c610cff">trackWithFallbackTransfo</a> (Proc &amp;&amp;fallback, T *t)</td></tr>
<tr class="separator:a0e2280708fe591ee73844f207c610cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac69a3cb738aafb54c9220529d212f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfac69a3cb738aafb54c9220529d212f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1TrackSilentTransfo.html">TrackSilentTransfo</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#acfac69a3cb738aafb54c9220529d212f">trackSilentTransfo</a> (T *t)</td></tr>
<tr class="separator:acfac69a3cb738aafb54c9220529d212f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad774296b27b62b0ca406b6d15c4fd170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Translator.html">qi::Translator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad774296b27b62b0ca406b6d15c4fd170">defaultTranslator</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad774296b27b62b0ca406b6d15c4fd170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference on the default <a class="el" href="classqi_1_1Translator.html" title="Localization of your source code. ">Translator</a>.  <a href="#ad774296b27b62b0ca406b6d15c4fd170">More...</a><br/></td></tr>
<tr class="separator:ad774296b27b62b0ca406b6d15c4fd170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0992f93731c6e9ca683928547761c471"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0992f93731c6e9ca683928547761c471">tr</a> (const std::string &amp;msg, const std::string &amp;domain=&quot;&quot;, const std::string &amp;locale=&quot;&quot;, const std::string &amp;context=&quot;&quot;)</td></tr>
<tr class="memdesc:a0992f93731c6e9ca683928547761c471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a message.  <a href="#a0992f93731c6e9ca683928547761c471">More...</a><br/></td></tr>
<tr class="separator:a0992f93731c6e9ca683928547761c471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa455773e2cc2e0cdf9b785615da4151f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa455773e2cc2e0cdf9b785615da4151f">trContext</a> (const std::string &amp;msg, const std::string &amp;context)</td></tr>
<tr class="memdesc:aa455773e2cc2e0cdf9b785615da4151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a message with a specific context.  <a href="#aa455773e2cc2e0cdf9b785615da4151f">More...</a><br/></td></tr>
<tr class="separator:aa455773e2cc2e0cdf9b785615da4151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4e89c404bfea877211a60561db4f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a3f4e89c404bfea877211a60561db4f52">operator==</a> (const <a class="el" href="classqi_1_1AnyIterator.html">AnyIterator</a> &amp;a, const <a class="el" href="classqi_1_1AnyIterator.html">AnyIterator</a> &amp;b)</td></tr>
<tr class="separator:a3f4e89c404bfea877211a60561db4f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f54abf0f63a1de518ebaafbd3b699a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a93f54abf0f63a1de518ebaafbd3b699a">operator!=</a> (const <a class="el" href="classqi_1_1AnyIterator.html">AnyIterator</a> &amp;a, const <a class="el" href="classqi_1_1AnyIterator.html">AnyIterator</a> &amp;b)</td></tr>
<tr class="separator:a93f54abf0f63a1de518ebaafbd3b699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0458e8f45de0e037c7cb9bfa56b31c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a6c0458e8f45de0e037c7cb9bfa56b31c">operator&lt;</a> (const <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &amp;a, const <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &amp;b)</td></tr>
<tr class="separator:a6c0458e8f45de0e037c7cb9bfa56b31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b0cb5de04863592216daa6888214b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa93b0cb5de04863592216daa6888214b">operator==</a> (const <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &amp;a, const <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &amp;b)</td></tr>
<tr class="separator:aa93b0cb5de04863592216daa6888214b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6d91fe199c228cda7583edf00e5363"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aef6d91fe199c228cda7583edf00e5363">operator!=</a> (const <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &amp;a, const <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &amp;b)</td></tr>
<tr class="separator:aef6d91fe199c228cda7583edf00e5363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0677f9994ab898cc93a8131b83bd2102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0677f9994ab898cc93a8131b83bd2102">makeGenericTuple</a> (const <a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> &amp;values)</td></tr>
<tr class="separator:a0677f9994ab898cc93a8131b83bd2102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7d98cfcf8874b647ce4fbfbb0040ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a2f7d98cfcf8874b647ce4fbfbb0040ee">makeGenericTuplePtr</a> (const std::vector&lt; <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> * &gt; &amp;types, const std::vector&lt; void * &gt; &amp;values)</td></tr>
<tr class="separator:a2f7d98cfcf8874b647ce4fbfbb0040ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ecf9e30b3f2341c824fb4bd5493bbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae7ecf9e30b3f2341c824fb4bd5493bbf">operator&lt;</a> (const <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;a, const <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;b)</td></tr>
<tr class="memdesc:ae7ecf9e30b3f2341c824fb4bd5493bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator. Will compare the values within the <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a>.  <a href="#ae7ecf9e30b3f2341c824fb4bd5493bbf">More...</a><br/></td></tr>
<tr class="separator:ae7ecf9e30b3f2341c824fb4bd5493bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9403cd278f0ecd3901d3995f3b713d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ac9403cd278f0ecd3901d3995f3b713d3">operator==</a> (const <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;a, const <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;b)</td></tr>
<tr class="memdesc:ac9403cd278f0ecd3901d3995f3b713d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value equality operator. Will compare the values within.  <a href="#ac9403cd278f0ecd3901d3995f3b713d3">More...</a><br/></td></tr>
<tr class="separator:ac9403cd278f0ecd3901d3995f3b713d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621564f7183b228b46b58f1569bb563c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a621564f7183b228b46b58f1569bb563c">operator!=</a> (const <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;a, const <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &amp;b)</td></tr>
<tr class="separator:a621564f7183b228b46b58f1569bb563c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c2015abb2b45d42f54a2558def93e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a41c2015abb2b45d42f54a2558def93e3">asAnyReferenceVector</a> (const <a class="el" href="namespaceqi.html#a9fc9c029f3e47daa5e331a46afca298b">AnyValueVector</a> &amp;vect)</td></tr>
<tr class="separator:a41c2015abb2b45d42f54a2558def93e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb244ec529ea9c107997dac4a4038ff0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:adb244ec529ea9c107997dac4a4038ff0"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; typename <br class="typebreak"/>
<a class="el" href="structqi_1_1detail_1_1InterfaceImplTraits.html">detail::InterfaceImplTraits</a>&lt; T &gt;<br class="typebreak"/>
::Defined, <a class="el" href="classqi_1_1Object.html">qi::Object</a>&lt; T &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#adb244ec529ea9c107997dac4a4038ff0">constructObject</a> (Args...args)</td></tr>
<tr class="separator:adb244ec529ea9c107997dac4a4038ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bf0d39461c575e93e1525f62318675"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a04bf0d39461c575e93e1525f62318675"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; typename <br class="typebreak"/>
<a class="el" href="structqi_1_1detail_1_1InterfaceImplTraits.html">detail::InterfaceImplTraits</a>&lt; T &gt;<br class="typebreak"/>
::Defined, <a class="el" href="classqi_1_1Object.html">qi::Object</a>&lt; T &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a04bf0d39461c575e93e1525f62318675">constructObject</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a04bf0d39461c575e93e1525f62318675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167afc34f376286d2e46424ae4941065"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a167afc34f376286d2e46424ae4941065"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; typename <br class="typebreak"/>
detail::Accessor&lt; A &gt;<br class="typebreak"/>
::is_accessor, <a class="el" href="classqi_1_1SignalBase.html">SignalBase</a> * &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a167afc34f376286d2e46424ae4941065">signalAccess</a> (A acc, void *instance)</td></tr>
<tr class="separator:a167afc34f376286d2e46424ae4941065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceece21123bf061395fb61c01731a274"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aceece21123bf061395fb61c01731a274"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; typename <br class="typebreak"/>
detail::Accessor&lt; A &gt;<br class="typebreak"/>
::is_accessor, <a class="el" href="classqi_1_1PropertyBase.html">PropertyBase</a> * &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aceece21123bf061395fb61c01731a274">propertyAccess</a> (A acc, void *instance)</td></tr>
<tr class="separator:aceece21123bf061395fb61c01731a274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32994dde8c5e2313e5a50cb83a87e138"><td class="memTemplParams" colspan="2">template&lt;typename Proxy , typename Interface &gt; </td></tr>
<tr class="memitem:a32994dde8c5e2313e5a50cb83a87e138"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a32994dde8c5e2313e5a50cb83a87e138">registerProxyInterface</a> ()</td></tr>
<tr class="separator:a32994dde8c5e2313e5a50cb83a87e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f891b1f951f7e4d40b77e8d80a00a"><td class="memTemplParams" colspan="2">template&lt;class Func , class... Args&gt; </td></tr>
<tr class="memitem:a708f891b1f951f7e4d40b77e8d80a00a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a708f891b1f951f7e4d40b77e8d80a00a">callWithInstance</a> (Func &amp;&amp;f, Args &amp;&amp;...args) -&gt; decltype(std::forward&lt; Func &gt;(f)(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:a708f891b1f951f7e4d40b77e8d80a00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9702e228415f8fe6c8631fc61d67d15"><td class="memTemplParams" colspan="2">template&lt;class Func , class Obj , class... Args&gt; </td></tr>
<tr class="memitem:ae9702e228415f8fe6c8631fc61d67d15"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae9702e228415f8fe6c8631fc61d67d15">callWithInstance</a> (Func &amp;&amp;f, Obj &amp;&amp;o, Args &amp;&amp;...args) -&gt; decltype((std::forward&lt; Obj &gt;(o).*std::forward&lt; Func &gt;(f))(std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:ae9702e228415f8fe6c8631fc61d67d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c033cfdd2ccfc485a907b540e081595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1StringTypeInterface.html#a69bcd8b478c65e82ac1151603733cb66">StringTypeInterface::ManagedRawString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a0c033cfdd2ccfc485a907b540e081595">makeManagedString</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a0c033cfdd2ccfc485a907b540e081595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93205f8e788842061edc90c2a298a4f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1StringTypeInterface.html#a69bcd8b478c65e82ac1151603733cb66">StringTypeInterface::ManagedRawString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a93205f8e788842061edc90c2a298a4f1">makeManagedString</a> (std::string &amp;&amp;s)</td></tr>
<tr class="separator:a93205f8e788842061edc90c2a298a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e607036093eb12c791c880d865e5d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a23e607036093eb12c791c880d865e5d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1StringTypeInterface.html">StringTypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a23e607036093eb12c791c880d865e5d5">makeTypeEquivalentString</a> (T *, F f)</td></tr>
<tr class="separator:a23e607036093eb12c791c880d865e5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe00774a87836a58440771526eb26581"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abe00774a87836a58440771526eb26581">operator&lt;</a> (const <a class="el" href="structqi_1_1TraceAnalyzer_1_1FlowLink.html">TraceAnalyzer::FlowLink</a> &amp;a, const <a class="el" href="structqi_1_1TraceAnalyzer_1_1FlowLink.html">TraceAnalyzer::FlowLink</a> &amp;b)</td></tr>
<tr class="separator:abe00774a87836a58440771526eb26581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c4fec4058dee00453ef20d1c544eec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45c4fec4058dee00453ef20d1c544eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a45c4fec4058dee00453ef20d1c544eec">typeOf</a> ()</td></tr>
<tr class="separator:a45c4fec4058dee00453ef20d1c544eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5d0e34c6e110a2b35788f4fdf9ce40"><td class="memTemplParams" colspan="2">template&lt;typename TypeDispatcher &gt; </td></tr>
<tr class="memitem:a7d5d0e34c6e110a2b35788f4fdf9ce40"><td class="memTemplItemLeft" align="right" valign="top">TypeDispatcher &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a7d5d0e34c6e110a2b35788f4fdf9ce40">typeDispatch</a> (TypeDispatcher &amp;v, <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> value)</td></tr>
<tr class="separator:a7d5d0e34c6e110a2b35788f4fdf9ce40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28374f6240c824f5c32b7d3a30e6ba0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a28374f6240c824f5c32b7d3a30e6ba0c">getType</a> (const std::type_info &amp;type)</td></tr>
<tr class="memdesc:a28374f6240c824f5c32b7d3a30e6ba0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime Type factory getter. Used by <a class="el" href="namespaceqi.html#a45c4fec4058dee00453ef20d1c544eec">typeOf&lt;T&gt;()</a>  <a href="#a28374f6240c824f5c32b7d3a30e6ba0c">More...</a><br/></td></tr>
<tr class="separator:a28374f6240c824f5c32b7d3a30e6ba0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b3c262e479a240240bf2ddd3cb0f7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a74b3c262e479a240240bf2ddd3cb0f7e">registerType</a> (const std::type_info &amp;typeId, <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *type)</td></tr>
<tr class="memdesc:a74b3c262e479a240240bf2ddd3cb0f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime Type factory setter.  <a href="#a74b3c262e479a240240bf2ddd3cb0f7e">More...</a><br/></td></tr>
<tr class="separator:a74b3c262e479a240240bf2ddd3cb0f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42acc117e914a07695eb02cd0a13aeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa42acc117e914a07695eb02cd0a13aeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa42acc117e914a07695eb02cd0a13aeb">typeOf</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aa42acc117e914a07695eb02cd0a13aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type from a value. No need to delete the result.  <a href="#aa42acc117e914a07695eb02cd0a13aeb">More...</a><br/></td></tr>
<tr class="separator:aa42acc117e914a07695eb02cd0a13aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5acba1383706c293755c20935f7d613"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae5acba1383706c293755c20935f7d613">registerStruct</a> (<a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *type)</td></tr>
<tr class="separator:ae5acba1383706c293755c20935f7d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d0e709c6dd1b32ddd4d9a427926ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad7d0e709c6dd1b32ddd4d9a427926ea5">getRegisteredStruct</a> (const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;s)</td></tr>
<tr class="separator:ad7d0e709c6dd1b32ddd4d9a427926ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d6828dff16659a53da08c7de30956f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a04d6828dff16659a53da08c7de30956f">makeDynamicAnyObject</a> (<a class="el" href="classqi_1_1DynamicObject.html">DynamicObject</a> *obj, bool destroyObject=true, boost::function&lt; void(<a class="el" href="classqi_1_1GenericObject.html">GenericObject</a> *)&gt; onDelete=boost::function&lt; void(<a class="el" href="classqi_1_1GenericObject.html">GenericObject</a> *)&gt;())</td></tr>
<tr class="separator:a04d6828dff16659a53da08c7de30956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631fd1daf49d80aa9abb8210efc13769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a631fd1daf49d80aa9abb8210efc13769">makeDynamicSharedAnyObjectImpl</a> (<a class="el" href="classqi_1_1DynamicObject.html">DynamicObject</a> *obj, boost::shared_ptr&lt; <a class="el" href="classqi_1_1Empty.html">Empty</a> &gt; other)</td></tr>
<tr class="separator:a631fd1daf49d80aa9abb8210efc13769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230889c807a35900df1fb6385a926a98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230889c807a35900df1fb6385a926a98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a230889c807a35900df1fb6385a926a98">makeDynamicSharedAnyObject</a> (<a class="el" href="classqi_1_1DynamicObject.html">DynamicObject</a> *obj, boost::shared_ptr&lt; T &gt; other)</td></tr>
<tr class="separator:a230889c807a35900df1fb6385a926a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde1dffa366528f25db3597abb0b2fe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1ObjectTypeInterface.html">ObjectTypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#acde1dffa366528f25db3597abb0b2fe5">getDynamicTypeInterface</a> ()</td></tr>
<tr class="separator:acde1dffa366528f25db3597abb0b2fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe13c66dd9a2409ff4535a5673f71885"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#afe13c66dd9a2409ff4535a5673f71885">operator&lt;</a> (const <a class="el" href="classqi_1_1MetaObject.html">MetaObject</a> &amp;a, const <a class="el" href="classqi_1_1MetaObject.html">MetaObject</a> &amp;b)</td></tr>
<tr class="separator:afe13c66dd9a2409ff4535a5673f71885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a03dcb5873ecafec163c01ded08ccb"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class...&gt; class PropertyType&gt; </td></tr>
<tr class="memitem:a24a03dcb5873ecafec163c01ded08ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a24a03dcb5873ecafec163c01ded08ccb">makeProxyProperty</a> (PropertyType&lt; T &gt; &amp;target, <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr class="separator:a24a03dcb5873ecafec163c01ded08ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dbdca1386a4f383b1a8daba304a13d"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class...&gt; class PropertyType&gt; </td></tr>
<tr class="memitem:aa0dbdca1386a4f383b1a8daba304a13d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aa0dbdca1386a4f383b1a8daba304a13d">makeProxyProperty</a> (<a class="el" href="classqi_1_1ProxyProperty.html">ProxyProperty</a>&lt; T, PropertyType &gt; &amp;target, <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr class="separator:aa0dbdca1386a4f383b1a8daba304a13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ab95a69a97a75ef18b2337ac5a5932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4ab95a69a97a75ef18b2337ac5a5932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ab4ab95a69a97a75ef18b2337ac5a5932">makeProxySignal</a> (<a class="el" href="classqi_1_1SignalF.html">SignalF</a>&lt; T &gt; &amp;target, <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr class="separator:ab4ab95a69a97a75ef18b2337ac5a5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748adf53e6743b399564d041658ad6ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a748adf53e6743b399564d041658ad6ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a748adf53e6743b399564d041658ad6ab">makeProxySignal</a> (<a class="el" href="classqi_1_1ProxySignal.html">ProxySignal</a>&lt; T &gt; &amp;target, <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr class="separator:a748adf53e6743b399564d041658ad6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c3fd89490bba2596644ff2836f22a7"><td class="memTemplParams" colspan="2">template&lt;typename Dispatcher &gt; </td></tr>
<tr class="memitem:a81c3fd89490bba2596644ff2836f22a7"><td class="memTemplItemLeft" align="right" valign="top">Dispatcher &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a81c3fd89490bba2596644ff2836f22a7">typeDispatch</a> (Dispatcher &amp;dispatcher, <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> value)</td></tr>
<tr class="separator:a81c3fd89490bba2596644ff2836f22a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88d038b69d6ddd1416c07784d4c2854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad88d038b69d6ddd1416c07784d4c2854">makeTypeOfKind</a> (const <a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83">qi::TypeKind</a> &amp;kind)</td></tr>
<tr class="separator:ad88d038b69d6ddd1416c07784d4c2854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09c8c0d171c2ef5e3b2c4db795d8db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae09c8c0d171c2ef5e3b2c4db795d8db4">makeFloatType</a> (int bytelen)</td></tr>
<tr class="separator:ae09c8c0d171c2ef5e3b2c4db795d8db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b195e4c91c436ffe1a3230ec5f712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a426b195e4c91c436ffe1a3230ec5f712">makeIntType</a> (bool issigned, int bytelen)</td></tr>
<tr class="separator:a426b195e4c91c436ffe1a3230ec5f712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537adf368dd07b2b5d5a248780f4f768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a537adf368dd07b2b5d5a248780f4f768">makeVarArgsType</a> (<a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *elementType)</td></tr>
<tr class="separator:a537adf368dd07b2b5d5a248780f4f768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada86c6a16b6970d55b47851227487f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a4ada86c6a16b6970d55b47851227487f">makeListType</a> (<a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *elementType)</td></tr>
<tr class="separator:a4ada86c6a16b6970d55b47851227487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d0f507e9bcd84530c9650100c17a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a84d0f507e9bcd84530c9650100c17a67">makeMapType</a> (<a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *keyType, <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *ElementType)</td></tr>
<tr class="separator:a84d0f507e9bcd84530c9650100c17a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaf3d66d510df1dd23529d3f4f20631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a7eaf3d66d510df1dd23529d3f4f20631">makeTupleType</a> (const std::vector&lt; <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> * &gt; &amp;memberTypes, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;elementNames=std::vector&lt; std::string &gt;())</td></tr>
<tr class="separator:a7eaf3d66d510df1dd23529d3f4f20631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34013b6e2d0244f6863c17607be74a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae34013b6e2d0244f6863c17607be74a3">operator==</a> (const <a class="el" href="classqi_1_1Url.html">Url</a> &amp;lhs, const <a class="el" href="classqi_1_1Url.html">Url</a> &amp;rhs)</td></tr>
<tr class="separator:ae34013b6e2d0244f6863c17607be74a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8034f21d05a022058fc33b5d6f544f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8034f21d05a022058fc33b5d6f544f3c">operator!=</a> (const <a class="el" href="classqi_1_1Url.html">Url</a> &amp;lhs, const <a class="el" href="classqi_1_1Url.html">Url</a> &amp;rhs)</td></tr>
<tr class="separator:a8034f21d05a022058fc33b5d6f544f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b47909071f18b24e7456faa433a50df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqi_1_1Url.html">Url</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5b47909071f18b24e7456faa433a50df">specifyUrl</a> (const <a class="el" href="classqi_1_1Url.html">Url</a> &amp;specification, const <a class="el" href="classqi_1_1Url.html">Url</a> &amp;baseUrl)</td></tr>
<tr class="separator:a5b47909071f18b24e7456faa433a50df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea73608226c5ebcb2ec776cb48326542"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea73608226c5ebcb2ec776cb48326542"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CONSTEXPR T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aea73608226c5ebcb2ec776cb48326542">fwd</a> (typename std::remove_reference&lt; T &gt;::type &amp;t) <a class="el" href="macro_8hpp.html#acbe7b990db4e128b426d9303bfaec1ab">QI_NOEXCEPT</a>(true)</td></tr>
<tr class="separator:aea73608226c5ebcb2ec776cb48326542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f42f6da26ee4f8591073a1054e2303"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67f42f6da26ee4f8591073a1054e2303"><td class="memTemplItemLeft" align="right" valign="top">BOOST_CONSTEXPR T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a67f42f6da26ee4f8591073a1054e2303">fwd</a> (typename std::remove_reference&lt; T &gt;::type &amp;&amp;t) <a class="el" href="macro_8hpp.html#acbe7b990db4e128b426d9303bfaec1ab">QI_NOEXCEPT</a>(true)</td></tr>
<tr class="separator:a67f42f6da26ee4f8591073a1054e2303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15e3f2c9126d512dbdc9a5d77abd212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af15e3f2c9126d512dbdc9a5d77abd212"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af15e3f2c9126d512dbdc9a5d77abd212">declref</a> ()</td></tr>
<tr class="separator:af15e3f2c9126d512dbdc9a5d77abd212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e3526e66dd5ddc5e8fee467974575e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52e3526e66dd5ddc5e8fee467974575e"><td class="memTemplItemLeft" align="right" valign="top">std::weak_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a52e3526e66dd5ddc5e8fee467974575e">weakPtr</a> (const std::shared_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a52e3526e66dd5ddc5e8fee467974575e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weak_ptr&lt;T&gt; with T deduced from a shared_ptr&lt;T&gt;  <a href="#a52e3526e66dd5ddc5e8fee467974575e">More...</a><br/></td></tr>
<tr class="separator:a52e3526e66dd5ddc5e8fee467974575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4c6998ed94e2df3993d0d787ed740a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf4c6998ed94e2df3993d0d787ed740a"><td class="memTemplItemLeft" align="right" valign="top">boost::weak_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abf4c6998ed94e2df3993d0d787ed740a">weakPtr</a> (const boost::shared_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:abf4c6998ed94e2df3993d0d787ed740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab708943448eb9763254b9a6470728e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ab708943448eb9763254b9a6470728e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5ab708943448eb9763254b9a6470728e">scopelock</a> (std::weak_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a5ab708943448eb9763254b9a6470728e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3caa086a8287c6e24e93a33bbd83c6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3caa086a8287c6e24e93a33bbd83c6a"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af3caa086a8287c6e24e93a33bbd83c6a">scopelock</a> (boost::weak_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:af3caa086a8287c6e24e93a33bbd83c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f4518e1723f5b66a985e2fbd11fb52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72f4518e1723f5b66a985e2fbd11fb52"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a><br class="typebreak"/>
&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a72f4518e1723f5b66a985e2fbd11fb52">sharedPtr</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a72f4518e1723f5b66a985e2fbd11fb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a std::shared_ptr&lt;T&gt; with T deduced from the parameter.  <a href="#a72f4518e1723f5b66a985e2fbd11fb52">More...</a><br/></td></tr>
<tr class="separator:a72f4518e1723f5b66a985e2fbd11fb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a74acfd43dea835f6752dad8fa47cc7f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a74acfd43dea835f6752dad8fa47cc7f1">sleepFor</a> (const <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> &amp;d)</td></tr>
<tr class="separator:a74acfd43dea835f6752dad8fa47cc7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62a281dc7248335ab2a69fab70adc09"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:ad62a281dc7248335ab2a69fab70adc09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad62a281dc7248335ab2a69fab70adc09">sleepFor</a> (const <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt; Rep, Period &gt; &amp;d)</td></tr>
<tr class="separator:ad62a281dc7248335ab2a69fab70adc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a25f5e223a90ec2016534ef6d33d9729f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a25f5e223a90ec2016534ef6d33d9729f">sleepUntil</a> (const <a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">SteadyClockTimePoint</a> &amp;t)</td></tr>
<tr class="memdesc:a25f5e223a90ec2016534ef6d33d9729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the execution of the current thread until <code>t</code> has been reached.  <a href="#a25f5e223a90ec2016534ef6d33d9729f">More...</a><br/></td></tr>
<tr class="separator:a25f5e223a90ec2016534ef6d33d9729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58586cd571c328f307c91f3768d47ed5"><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr class="memitem:a58586cd571c328f307c91f3768d47ed5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a58586cd571c328f307c91f3768d47ed5">sleepUntil</a> (const boost::chrono::time_point&lt; <a class="el" href="classqi_1_1SteadyClock.html">SteadyClock</a>, <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">Duration</a> &gt; &amp;t)</td></tr>
<tr class="separator:a58586cd571c328f307c91f3768d47ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad1cf1e23ac8f95d9729d5b3f0a9957cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad1cf1e23ac8f95d9729d5b3f0a9957cf">sleepUntil</a> (const <a class="el" href="namespaceqi.html#a796401bb4b6275080745823738fd30e8">ClockTimePoint</a> &amp;t)</td></tr>
<tr class="memdesc:ad1cf1e23ac8f95d9729d5b3f0a9957cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the execution of the current thread until <code>t</code> has been reached.  <a href="#ad1cf1e23ac8f95d9729d5b3f0a9957cf">More...</a><br/></td></tr>
<tr class="separator:ad1cf1e23ac8f95d9729d5b3f0a9957cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf72cbd80cca5bd06955cdf5296a457"><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr class="memitem:aadf72cbd80cca5bd06955cdf5296a457"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aadf72cbd80cca5bd06955cdf5296a457">sleepUntil</a> (const boost::chrono::time_point&lt; <a class="el" href="classqi_1_1Clock.html">Clock</a>, <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">Duration</a> &gt; &amp;t)</td></tr>
<tr class="separator:aadf72cbd80cca5bd06955cdf5296a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf082a7d6317673162dd6be89e877b6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#abf082a7d6317673162dd6be89e877b6e">sleepUntil</a> (const <a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a> &amp;t)</td></tr>
<tr class="memdesc:abf082a7d6317673162dd6be89e877b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the execution of the current thread until <code>t</code> has been reached.  <a href="#abf082a7d6317673162dd6be89e877b6e">More...</a><br/></td></tr>
<tr class="separator:abf082a7d6317673162dd6be89e877b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c238426659012039786a3a9a1cea5d6"><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr class="memitem:a5c238426659012039786a3a9a1cea5d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a5c238426659012039786a3a9a1cea5d6">sleepUntil</a> (const boost::chrono::time_point&lt; <a class="el" href="classqi_1_1SystemClock.html">SystemClock</a>, <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">Duration</a> &gt; &amp;t)</td></tr>
<tr class="separator:a5c238426659012039786a3a9a1cea5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a890dc87043938975dac578ce19a0c971"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a890dc87043938975dac578ce19a0c971">toISO8601String</a> (const <a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a> &amp;t)</td></tr>
<tr class="memdesc:a890dc87043938975dac578ce19a0c971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the date and time as a string in ISO 8601 format. The time is given up to millisecond precision, in UTC. The format does not include colon characters, to be suitable for inclusion in filenames on any filesystem.  <a href="#a890dc87043938975dac578ce19a0c971">More...</a><br/></td></tr>
<tr class="separator:a890dc87043938975dac578ce19a0c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d36a78c6f895808cf6b964413a0a3"><td class="memTemplParams" colspan="2">template&lt;class DurationTo , class TimePointFrom &gt; </td></tr>
<tr class="memitem:ae26d36a78c6f895808cf6b964413a0a3"><td class="memTemplItemLeft" align="right" valign="top">DurationTo&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ae26d36a78c6f895808cf6b964413a0a3">durationSince</a> (const TimePointFrom &amp;t)</td></tr>
<tr class="memdesc:ae26d36a78c6f895808cf6b964413a0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">}@  <a href="#ae26d36a78c6f895808cf6b964413a0a3">More...</a><br/></td></tr>
<tr class="separator:ae26d36a78c6f895808cf6b964413a0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a00ef59cda7cb3b77ed04d3fa77d80512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> typedef <br class="typebreak"/>
<a class="el" href="classqi_1_1SystemClock.html">SystemClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a00ef59cda7cb3b77ed04d3fa77d80512">WallClock</a></td></tr>
<tr class="separator:a00ef59cda7cb3b77ed04d3fa77d80512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad096ee419913be83f1767644d3104975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> typedef <br class="typebreak"/>
<a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad096ee419913be83f1767644d3104975">WallClockTimePoint</a></td></tr>
<tr class="memdesc:ad096ee419913be83f1767644d3104975"><td class="mdescLeft">&#160;</td><td class="mdescRight">System clock time point.  <a href="#ad096ee419913be83f1767644d3104975">More...</a><br/></td></tr>
<tr class="separator:ad096ee419913be83f1767644d3104975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfddda083c8a79db85dde8042dda955e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfddda083c8a79db85dde8042dda955e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structqi_1_1Incr.html">Incr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#adfddda083c8a79db85dde8042dda955e">retract</a> (<a class="el" href="structqi_1_1Decr.html">Decr</a>&lt; T &gt;)</td></tr>
<tr class="separator:adfddda083c8a79db85dde8042dda955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d0c6e0eeb368ebee10e1f66ced08a3"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#ad5d0c6e0eeb368ebee10e1f66ced08a3">JsonOption_None</a> = 0</td></tr>
<tr class="separator:ad5d0c6e0eeb368ebee10e1f66ced08a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ab4fea7eb9f2f2ed2d1deedc3fd996"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#af5ab4fea7eb9f2f2ed2d1deedc3fd996">JsonOption_PrettyPrint</a> = 1</td></tr>
<tr class="separator:af5ab4fea7eb9f2f2ed2d1deedc3fd996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac8c843a70dad2461e2e18f3e6593c9"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqi.html#a8ac8c843a70dad2461e2e18f3e6593c9">JsonOption_Expand</a> = 2</td></tr>
<tr class="separator:a8ac8c843a70dad2461e2e18f3e6593c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7d2ac0e55865d84ff65749c4c4c7a1"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class T&gt; </td></tr>
<tr class="memitem:aed7d2ac0e55865d84ff65749c4c4c7a1"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="api_8hpp.html#aa7f9e677e31e5208fa52fe4bbe899703">QITYPE_TEMPLATE_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqi.html#aed7d2ac0e55865d84ff65749c4c4c7a1">TypeOfTemplate</a></td></tr>
<tr class="separator:aed7d2ac0e55865d84ff65749c4c4c7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Deprecated in 2.5. Use int8_t from &lt;cstdint&gt;. </p>
<p>Language factory, for each language (C++, Python, ...) a factory should be registered. The factory will be used to load the module</p>
  <a class="el" href="namespaceqi.html#a08a5eed863e4c5e940fb4820df40ab5c">qi::int8_t</a>  <a class="el" href="namespaceqi.html#a3f5f92384de94a81e0be6a2617577c9d">qi::int16_t</a> Deprecated in 2.5. Use int16_t from &lt;cstdint&gt;.  <a class="el" href="namespaceqi.html#a273969d76ca08978f1eb6d3ff72562bb">qi::int32_t</a> Deprecated in 2.5. Use int32_t from &lt;cstdint&gt;.  <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">qi::int64_t</a> Deprecated in 2.5. Use int64_t from &lt;cstdint&gt;.  <a class="el" href="namespaceqi.html#ac120f3edc8f043b64c96e6e205f1f098">qi::uint8_t</a> Deprecated in 2.5. Use uint8_t from &lt;cstdint&gt;.  <a class="el" href="namespaceqi.html#a057f5b0592dbdf05c338ea6d7c369633">qi::uint16_t</a> Deprecated in 2.5. Use uint16_t from &lt;cstdint&gt;.  <a class="el" href="namespaceqi.html#a31f4e8363661056c4f3aea8d20e3f9cc">qi::uint32_t</a> Deprecated in 2.5. Use uint32_t from &lt;cstdint&gt;.  <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">qi::uint64_t</a> Deprecated in 2.5. Use uint64_t from &lt;cstdint&gt;. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a757656dc3b93d0d968362b133e149842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a757656dc3b93d0d968362b133e149842">qi::AnyAutoService</a> = typedef <a class="el" href="classqi_1_1AutoService.html">AutoService</a>&lt;<a class="el" href="classqi_1_1Empty.html">qi::Empty</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="autoservice_8hpp_source.html#l00105">105</a> of file <a class="el" href="autoservice_8hpp_source.html">autoservice.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e60a9cbccf0a2138b4f838b9ccd356a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classqi_1_1Object.html">Object</a>&lt; <a class="el" href="classqi_1_1Empty.html">Empty</a> &gt; <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">qi::AnyObject</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyobject_8hpp_source.html#l00021">21</a> of file <a class="el" href="anyobject_8hpp_source.html">anyobject.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6526717e2ad65d93d8a801c099cc90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> &gt; <a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">qi::AnyReferenceVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyreference_8hpp_source.html#l00024">24</a> of file <a class="el" href="anyreference_8hpp_source.html">anyreference.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc9c029f3e47daa5e331a46afca298b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt; <a class="el" href="namespaceqi.html#a9fc9c029f3e47daa5e331a46afca298b">qi::AnyValueVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type_2detail_2anyvalue_8hpp_source.html#l00116">116</a> of file <a class="el" href="type_2detail_2anyvalue_8hpp_source.html">anyvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb5f2fbcb10e8199ea7546a23c8c2a34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#aeb5f2fbcb10e8199ea7546a23c8c2a34">qi::AnyVarArguments</a> = typedef <a class="el" href="classqi_1_1VarArguments.html">VarArguments</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyfunction_8hpp_source.html#l00050">50</a> of file <a class="el" href="anyfunction_8hpp_source.html">anyfunction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a984d5fa8d8f50699c31a3da9bca5b63a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classqi_1_1WeakObject.html">WeakObject</a>&lt; <a class="el" href="classqi_1_1Empty.html">Empty</a> &gt; <a class="el" href="namespaceqi.html#a984d5fa8d8f50699c31a3da9bca5b63a">qi::AnyWeakObject</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="object_8hxx_source.html#l00338">338</a> of file <a class="el" href="object_8hxx_source.html">object.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aeea0566263d5845787dd24f7d1e53a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classqi_1_1ApplicationSession.html#a6a2b6ae655f892a69b39e864c120b9e0">qi::ApplicationSessionOptions</a> = typedef <a class="el" href="classqi_1_1ApplicationSession.html#a6a2b6ae655f892a69b39e864c120b9e0">ApplicationSession::Option</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="applicationsession_8hpp_source.html#l00165">165</a> of file <a class="el" href="applicationsession_8hpp_source.html">applicationsession.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2d4f697b87008b10e7a1a1c830c2f92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt; <a class="el" href="classqi_1_1AuthProviderFactory.html">AuthProviderFactory</a> &gt; <a class="el" href="namespaceqi.html#ad2d4f697b87008b10e7a1a1c830c2f92">qi::AuthProviderFactoryPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="authproviderfactory_8hpp_source.html#l00036">36</a> of file <a class="el" href="authproviderfactory_8hpp_source.html">authproviderfactory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ae3df954ff0b045407ceda0d7e90ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt; <a class="el" href="classqi_1_1AuthProvider.html">AuthProvider</a> &gt; <a class="el" href="namespaceqi.html#a2ae3df954ff0b045407ceda0d7e90ad4">qi::AuthProviderPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="authprovider_8hpp_source.html#l00060">60</a> of file <a class="el" href="authprovider_8hpp_source.html">authprovider.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fa9d95d751a10b47ba4f4d24f55cf2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; std::string, <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt; <a class="el" href="namespaceqi.html#a6fa9d95d751a10b47ba4f4d24f55cf2a">qi::CapabilityMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="authprovider_8hpp_source.html#l00021">21</a> of file <a class="el" href="authprovider_8hpp_source.html">authprovider.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91d284145085bb4503487026fcc58f26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt; <a class="el" href="classqi_1_1ClientAuthenticatorFactory.html">ClientAuthenticatorFactory</a> &gt; <a class="el" href="namespaceqi.html#a91d284145085bb4503487026fcc58f26">qi::ClientAuthenticatorFactoryPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clientauthenticatorfactory_8hpp_source.html#l00027">27</a> of file <a class="el" href="clientauthenticatorfactory_8hpp_source.html">clientauthenticatorfactory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a635df3ce1bb9dd26bd17890ab1d5517b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a635df3ce1bb9dd26bd17890ab1d5517b">qi::ClientAuthenticatorPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classqi_1_1ClientAuthenticator.html">ClientAuthenticator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clientauthenticator_8hpp_source.html#l00045">45</a> of file <a class="el" href="clientauthenticator_8hpp_source.html">clientauthenticator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a796401bb4b6275080745823738fd30e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a796401bb4b6275080745823738fd30e8">qi::ClockTimePoint</a> = typedef <a class="el" href="classqi_1_1Clock.html#abdda537df65b45a0a950464da0562d06">Clock::time_point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqi_1_1Clock.html" title="The Clock class represents a system-wide clock, best suitable for timestamping events. Typically monotonic and unaffected by the system clock adjustment, altough this is not guaranteed. ">qi::Clock</a> time point. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00212">212</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a827eae44eb9f8ca4154e87014b3720ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a827eae44eb9f8ca4154e87014b3720ec">qi::codecvt_type</a> = typedef std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard std::codecvt type accepted by STL and boost. </p>
<p>Typedef for std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; that can be used with boost::filesystem::path and std::locale. </p>

<p>Definition at line <a class="el" href="path_8hpp_source.html#l00518">518</a> of file <a class="el" href="path_8hpp_source.html">path.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d1810ab9faa895cc000a83e477570ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a3d1810ab9faa895cc000a83e477570ef">qi::DeserializeObjectCallback</a> = typedef boost::function&lt;<a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>(const <a class="el" href="structqi_1_1ObjectSerializationInfo.html">ObjectSerializationInfo</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of callback invoked by sdeerializer when it encounters an object. </p>

<p>Definition at line <a class="el" href="binarycodec_8hpp_source.html#l00039">39</a> of file <a class="el" href="binarycodec_8hpp_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b2a2e5db2d66c95b8b6f15f2bafbf59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> = typedef <a class="el" href="namespaceqi.html#a35fff863d93ebd834a9ed5615434045b">NanoSeconds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00032">32</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a130edabf43319b499ce3e8c325be0915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Ratio &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">qi::DurationType</a> = typedef boost::chrono::duration&lt;Rep, Ratio&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedefs. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00020">20</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0bc36a20fb78f026936370ff40df799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#ac0bc36a20fb78f026936370ff40df799">qi::DynamicFunction</a> = typedef boost::function&lt;<a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>(const <a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyfunction_8hpp_source.html#l00142">142</a> of file <a class="el" href="anyfunction_8hpp_source.html">anyfunction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa647e3e3e2836c23e271aad9b606d4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#aa647e3e3e2836c23e271aad9b606d4f6">qi::FutureUniqueId</a> = typedef void*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l00117">117</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a708e6701dbcae4d1d06c50efbb4b2f21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a708e6701dbcae4d1d06c50efbb4b2f21">qi::GatewayPrivatePtr</a> = typedef std::unique_ptr&lt;GatewayPrivate&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gateway_8hpp_source.html#l00026">26</a> of file <a class="el" href="gateway_8hpp_source.html">gateway.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa001ed01e669f703fca72d7659456ab2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#aa001ed01e669f703fca72d7659456ab2">qi::Hours</a> = typedef <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt;<a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::ratio&lt;3600&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00030">30</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6306cefd8ae50212de16d744b715ee09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Idx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a6306cefd8ae50212de16d744b715ee09">qi::index_sequence</a> = typedef <a class="el" href="structqi_1_1integer__sequence.html">integer_sequence</a>&lt;size_t, Idx...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template index_sequence. </p>

<p>Definition at line <a class="el" href="integersequence_8hpp_source.html#l00088">88</a> of file <a class="el" href="integersequence_8hpp_source.html">integersequence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7dd202c160024759642782fe8450a21d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a7dd202c160024759642782fe8450a21d">qi::index_sequence_for</a> = typedef <a class="el" href="namespaceqi.html#a0be2335ae913e30603739c3c0ea0a00b">make_index_sequence</a>&lt;sizeof...(Types)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template index_sequence_for. </p>

<p>Definition at line <a class="el" href="integersequence_8hpp_source.html#l00096">96</a> of file <a class="el" href="integersequence_8hpp_source.html">integersequence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f5f92384de94a81e0be6a2617577c9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a3f5f92384de94a81e0be6a2617577c9d">qi::int16_t</a> = typedef <a class="el" href="namespaceqi.html#a3f5f92384de94a81e0be6a2617577c9d">int16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00059">59</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a273969d76ca08978f1eb6d3ff72562bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a273969d76ca08978f1eb6d3ff72562bb">qi::int32_t</a> = typedef <a class="el" href="namespaceqi.html#a273969d76ca08978f1eb6d3ff72562bb">int32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00060">60</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80465fa597a2cce9b8a2dc595e685be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">qi::int64_t</a> = typedef <a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00061">61</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08a5eed863e4c5e940fb4820df40ab5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a08a5eed863e4c5e940fb4820df40ab5c">qi::int8_t</a> = typedef <a class="el" href="namespaceqi.html#a08a5eed863e4c5e940fb4820df40ab5c">int8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00058">58</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8b83d91c31225480036795fee7ce38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a7c8b83d91c31225480036795fee7ce38">qi::JsonOption</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="jsoncodec_8hpp_source.html#l00016">16</a> of file <a class="el" href="jsoncodec_8hpp_source.html">jsoncodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6c2b8c1c1c04f81bb319e7c5516d05e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#af6c2b8c1c1c04f81bb319e7c5516d05e">qi::LogContext</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs context attribute value. </p>

<p>Definition at line <a class="el" href="log_8hpp_source.html#l00176">176</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0be2335ae913e30603739c3c0ea0a00b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Num&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a0be2335ae913e30603739c3c0ea0a00b">qi::make_index_sequence</a> = typedef typename <a class="el" href="structqi_1_1detail_1_1make__integer__sequence.html">detail::make_integer_sequence</a>&lt;size_t, Num&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template make_index_sequence. </p>

<p>Definition at line <a class="el" href="integersequence_8hpp_source.html#l00092">92</a> of file <a class="el" href="integersequence_8hpp_source.html">integersequence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2398cec17c26c985a48a6ad16b2051f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , Tp Num&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#ab2398cec17c26c985a48a6ad16b2051f">qi::make_integer_sequence</a> = typedef typename <a class="el" href="structqi_1_1detail_1_1make__integer__sequence.html">detail::make_integer_sequence</a>&lt;Tp, Num&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template make_integer_sequence. </p>

<p>Definition at line <a class="el" href="integersequence_8hpp_source.html#l00084">84</a> of file <a class="el" href="integersequence_8hpp_source.html">integersequence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add780030382fb666b15a721b62523d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#add780030382fb666b15a721b62523d36">qi::MetaMethodParameterVector</a> = typedef std::vector&lt;<a class="el" href="classqi_1_1MetaMethodParameter.html">MetaMethodParameter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="metamethod_8hpp_source.html#l00038">38</a> of file <a class="el" href="metamethod_8hpp_source.html">metamethod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16933a46408e5c2b9abe828900dc70d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a16933a46408e5c2b9abe828900dc70d5">qi::MicroSeconds</a> = typedef <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt;<a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::micro&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00026">26</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a556ff3e75cfbe6604e6e6c550e35c367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a556ff3e75cfbe6604e6e6c550e35c367">qi::MilliSeconds</a> = typedef <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt;<a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::milli&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00027">27</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4833c7dcb72ab5eb0e7aa08d929c6d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#aa4833c7dcb72ab5eb0e7aa08d929c6d9">qi::Minutes</a> = typedef <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt;<a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::ratio&lt;60&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00029">29</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61713bc0ea16186774a4df18db41e08b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a61713bc0ea16186774a4df18db41e08b">qi::ModuleFactoryFunctor</a> = typedef boost::function&lt;<a class="el" href="classqi_1_1AnyModule.html">AnyModule</a>(const <a class="el" href="structqi_1_1ModuleInfo.html">qi::ModuleInfo</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anymodule_8hpp_source.html#l00148">148</a> of file <a class="el" href="anymodule_8hpp_source.html">anymodule.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35fff863d93ebd834a9ed5615434045b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a35fff863d93ebd834a9ed5615434045b">qi::NanoSeconds</a> = typedef <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt;<a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::nano&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00025">25</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a133f309be9d3b1b67922f2dda24bbe05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a133f309be9d3b1b67922f2dda24bbe05">qi::ObjectStatistics</a> = typedef std::map&lt;unsigned int, <a class="el" href="classqi_1_1MethodStatistics.html">MethodStatistics</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="manageable_8hpp_source.html#l00120">120</a> of file <a class="el" href="manageable_8hpp_source.html">manageable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d4c7464752acddcdd4fa4111f65aeda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a8d4c7464752acddcdd4fa4111f65aeda">qi::PathVector</a> = typedef std::vector&lt;<a class="el" href="classqi_1_1Path.html">Path</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="path_8hpp_source.html#l00027">27</a> of file <a class="el" href="path_8hpp_source.html">path.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42c4335385379166a6520793117f886c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a42c4335385379166a6520793117f886c">qi::Seconds</a> = typedef <a class="el" href="namespaceqi.html#a130edabf43319b499ce3e8c325be0915">DurationType</a>&lt;<a class="el" href="namespaceqi.html#a80465fa597a2cce9b8a2dc595e685be7">int64_t</a>, boost::ratio&lt;1&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00028">28</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0df728403f2294ca5d26f2e34d64852c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a0df728403f2294ca5d26f2e34d64852c">qi::SerializeObjectCallback</a> = typedef boost::function&lt;<a class="el" href="structqi_1_1ObjectSerializationInfo.html">ObjectSerializationInfo</a>(const <a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of callback invoked by serializer when it encounters an object. </p>

<p>Definition at line <a class="el" href="binarycodec_8hpp_source.html#l00042">42</a> of file <a class="el" href="binarycodec_8hpp_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4736ceb28d028e6552c124fd1b78030d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a4736ceb28d028e6552c124fd1b78030d">qi::ServiceInfoVector</a> = typedef std::vector&lt;<a class="el" href="classqi_1_1ServiceInfo.html">qi::ServiceInfo</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="serviceinfo_8hpp_source.html#l00050">50</a> of file <a class="el" href="serviceinfo_8hpp_source.html">serviceinfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3cc5a91e6d98c912baaa84d6ff3e54c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#ae3cc5a91e6d98c912baaa84d6ff3e54c">qi::SessionPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classqi_1_1Session.html">Session</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="session_8hpp_source.html#l00196">196</a> of file <a class="el" href="session_8hpp_source.html">session.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69247b0b30dc5f6df95488f18e9aff01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">qi::uint64_t</a> <a class="el" href="namespaceqi.html#a69247b0b30dc5f6df95488f18e9aff01">qi::SignalLink</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="signal_8hpp_source.html#l00034">34</a> of file <a class="el" href="signal_8hpp_source.html">signal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5376edc7d633faa4c5ca3beed49dd48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#af5376edc7d633faa4c5ca3beed49dd48">qi::SignalSubscriberPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classqi_1_1SignalSubscriber.html">SignalSubscriber</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="signal_8hpp_source.html#l00307">307</a> of file <a class="el" href="signal_8hpp_source.html">signal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af49b9d29c59a9b651c2f5522ac50792c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#af49b9d29c59a9b651c2f5522ac50792c">qi::SignatureVector</a> = typedef std::vector&lt;<a class="el" href="classqi_1_1Signature.html">Signature</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="signature_8hpp_source.html#l00063">63</a> of file <a class="el" href="signature_8hpp_source.html">signature.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3834497c0f4e5f94c302ca438f1f976c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">qi::SteadyClockTimePoint</a> = typedef <a class="el" href="classqi_1_1SteadyClock.html#a0292e248066d1cb00fbac295a83a4a1d">SteadyClock::time_point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Steady clock time point. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00211">211</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a412ecc9dbc618e0f6816f9167f304f20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">qi::SystemClockTimePoint</a> = typedef <a class="el" href="classqi_1_1SystemClock.html#a0100715a9e06d84f554f931649c828e2">SystemClock::time_point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System clock time point. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00213">213</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcd09bb05acef7308fba9e7a753d1582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ClockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#abcd09bb05acef7308fba9e7a753d1582">qi::TimePoint</a> = typedef boost::chrono::time_point&lt;ClockType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00023">23</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a057f5b0592dbdf05c338ea6d7c369633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a057f5b0592dbdf05c338ea6d7c369633">qi::uint16_t</a> = typedef <a class="el" href="namespaceqi.html#a057f5b0592dbdf05c338ea6d7c369633">uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00064">64</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31f4e8363661056c4f3aea8d20e3f9cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a31f4e8363661056c4f3aea8d20e3f9cc">qi::uint32_t</a> = typedef <a class="el" href="namespaceqi.html#a31f4e8363661056c4f3aea8d20e3f9cc">uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00065">65</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d0ac2d727a7e16134a0db019f3ceb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">qi::uint64_t</a> = typedef <a class="el" href="namespaceqi.html#aa2d0ac2d727a7e16134a0db019f3ceb6">uint64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00066">66</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac120f3edc8f043b64c96e6e205f1f098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#ac120f3edc8f043b64c96e6e205f1f098">qi::uint8_t</a> = typedef <a class="el" href="namespaceqi.html#ac120f3edc8f043b64c96e6e205f1f098">uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="types_8hpp_source.html#l00063">63</a> of file <a class="el" href="types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b1d07cc053525dae4395ad582d9a8bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqi.html#a8b1d07cc053525dae4395ad582d9a8bc">qi::UrlVector</a> = typedef std::vector&lt;<a class="el" href="classqi_1_1Url.html">Url</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="url_8hpp_source.html#l00153">153</a> of file <a class="el" href="url_8hpp_source.html">url.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad950f2c2012aa46a30595bf769d72d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#ad950f2c2012aa46a30595bf769d72d32">qi::AdaptFutureOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad950f2c2012aa46a30595bf769d72d32a856974a106298f26aa88138b81bc5f6a"></a>AdaptFutureOption_None</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad950f2c2012aa46a30595bf769d72d32a2416fcefdc9fcdd947e1f2d76f4e11c0"></a>AdaptFutureOption_ForwardCancel</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l00112">112</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66922f30da6f5708915f47ed330e0de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#a66922f30da6f5708915f47ed330e0de0">qi::FutureCallbackType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a66922f30da6f5708915f47ed330e0de0a994de07b744ad919d45ec8666da03c4f"></a>FutureCallbackType_Sync</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a66922f30da6f5708915f47ed330e0de0adee2428ef5a90f515ac7737c9a159d75"></a>FutureCallbackType_Async</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a66922f30da6f5708915f47ed330e0de0a61edf564a20cbb5425c6117ee65e7963"></a>FutureCallbackType_Auto</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l00101">101</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#a06fde6361c5d179ff0b9615a0ac4aa51">qi::FutureState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State of the future. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51a7353b65c14fc6205a79798a3fbd4401a"></a>FutureState_None</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="classqi_1_1Future.html">Future</a> is not tied to a promise. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51ab4aa09c0a00d9b24933df2952b28bc15"></a>FutureState_Running</em>&#160;</td><td class="fielddoc">
<p>Operation pending. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51a3c3a4f9e8d394891d5717e8e962ce8f9"></a>FutureState_Canceled</em>&#160;</td><td class="fielddoc">
<p>The future has been canceled. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51a8a7110a297926cba1ba38f5272a1ba5d"></a>FutureState_FinishedWithError</em>&#160;</td><td class="fielddoc">
<p>The operation is finished with an error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51aa34f218f2ec9a05027f11f7e524cef0b"></a>FutureState_FinishedWithValue</em>&#160;</td><td class="fielddoc">
<p>The operation is finished with a value. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l00079">79</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1f54e93f8719f4708669496c8a20a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#ad1f54e93f8719f4708669496c8a20a9c">qi::FutureTimeout</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad1f54e93f8719f4708669496c8a20a9ca648162635a9fcbc69da607a51197e07c"></a>FutureTimeout_Infinite</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad1f54e93f8719f4708669496c8a20a9caa418e4954620069c7ddbb4bc6c1e661d"></a>FutureTimeout_None</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l00107">107</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#aa1d7c0b8007b1ab09fc2de493108396b">qi::LogColor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs color mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396ba3bd8da8f7b698c20476796110d4647a1"></a>LogColor_Never</em>&#160;</td><td class="fielddoc">
<p>Never show color. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396ba6057d0099587041711b20c47580e79b0"></a>LogColor_Auto</em>&#160;</td><td class="fielddoc">
<p>Auto color. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396ba691067550d59a0e744b04b4bb782e829"></a>LogColor_Always</em>&#160;</td><td class="fielddoc">
<p>Always show color. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="log_8hpp_source.html#l00151">151</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#aeb49003e94f0efc86109a278d8d55f88">qi::LogContextAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs context attribute. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a7de8d9712806cce940066df9c298dde6"></a>LogContextAttr_None</em>&#160;</td><td class="fielddoc">
<p>No context. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88aa98c7a6e68d61670619e925a6030850a"></a>LogContextAttr_Verbosity</em>&#160;</td><td class="fielddoc">
<p>Show logs level. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a5082e95ca9152e6dd0c45acccef85dea"></a>LogContextAttr_ShortVerbosity</em>&#160;</td><td class="fielddoc">
<p>Show short logs level. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a47fb8dffe21791abad5cd4b757b7be6d"></a>LogContextAttr_SystemDate</em>&#160;</td><td class="fielddoc">
<p>Show <a class="el" href="classqi_1_1SystemClock.html" title="The SystemClock class represents the system-wide real time wall clock. It may not be monotonic: on mo...">qi::SystemClock</a> dates. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a7dd9f2a728db294bbccab4452d97a718"></a>LogContextAttr_Tid</em>&#160;</td><td class="fielddoc">
<p>Show threads id. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88ace5552c93742d5968ed2e9551317c06b"></a>LogContextAttr_Category</em>&#160;</td><td class="fielddoc">
<p>Show categories. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a8b875514dd1c415afa9d92c9ca2a8e76"></a>LogContextAttr_File</em>&#160;</td><td class="fielddoc">
<p>Show logs files. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88add0679d327681fecef744811c7a3fdbf"></a>LogContextAttr_Function</em>&#160;</td><td class="fielddoc">
<p>Show functions name. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88ab137c7cf28a44e366b6d2e6ec675587f"></a>LogContextAttr_Return</em>&#160;</td><td class="fielddoc">
<p>Print an end line between contexts and logs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88abe8c8facb4ddf7e7cf8e362db8101e53"></a>LogContextAttr_Date</em>&#160;</td><td class="fielddoc">
<p>Show <a class="el" href="classqi_1_1Clock.html" title="The Clock class represents a system-wide clock, best suitable for timestamping events. Typically monotonic and unaffected by the system clock adjustment, altough this is not guaranteed. ">qi::Clock</a> dates. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="log_8hpp_source.html#l00160">160</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#ae404a3651bdc9116349a4a60a1d0afc5">qi::LogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log level verbosity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a77059e55763f4584259218f0802d6b58"></a>LogLevel_Silent</em>&#160;</td><td class="fielddoc">
<p>silent log level </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5ab7f68198dd8bff433614815c8a226fc8"></a>LogLevel_Fatal</em>&#160;</td><td class="fielddoc">
<p>fatal log level </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a29568c44b55d44dec768128135f45d4a"></a>LogLevel_Error</em>&#160;</td><td class="fielddoc">
<p>error log level </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a1f5fad47e4e5cef1a8d437f94b9cc56f"></a>LogLevel_Warning</em>&#160;</td><td class="fielddoc">
<p>warning log level </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5ab813d452a834cc8990cde0a8592c9f8d"></a>LogLevel_Info</em>&#160;</td><td class="fielddoc">
<p>info log level </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a990d6cb9c4c1d0557c2e3780ae345839"></a>LogLevel_Verbose</em>&#160;</td><td class="fielddoc">
<p>verbose log level </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a030864da44cde81392a2e2fbd2f33b1e"></a>LogLevel_Debug</em>&#160;</td><td class="fielddoc">
<p>debug log level </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="log_8hpp_source.html#l00138">138</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af26fc7fa51e2905573cda6a194af6cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#af26fc7fa51e2905573cda6a194af6cae">qi::MetaCallType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies how a call should be made. Can be used at both call-site, and callback-registration site. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af26fc7fa51e2905573cda6a194af6caea0427d0d572be1d1929de10cb006946e8"></a>MetaCallType_Auto</em>&#160;</td><td class="fielddoc">
<p>Honor the default behavior. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af26fc7fa51e2905573cda6a194af6caea90daab2e41b08efb5341e827e543ebbc"></a>MetaCallType_Direct</em>&#160;</td><td class="fielddoc">
<p>Force a synchronous call. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af26fc7fa51e2905573cda6a194af6caea44b53fab14f133a377cfa684c4921b08"></a>MetaCallType_Queued</em>&#160;</td><td class="fielddoc">
<p>Force an asynchronous call in an other thread. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="typeobject_8hpp_source.html#l00021">21</a> of file <a class="el" href="typeobject_8hpp_source.html">typeobject.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#a8d59aed9fc0a2b4ee91991e2888d0227">qi::ObjectThreadingModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible thread models for an object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227a56239778f0c7fc1f4ab6207862e81fbc"></a>ObjectThreadingModel_SingleThread</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="classqi_1_1Object.html">Object</a> is not thread safe, all method calls must occur in the same thread. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227a6551c85d1e42bb6cff437d35ee1661cc"></a>ObjectThreadingModel_MultiThread</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="classqi_1_1Object.html">Object</a> is thread safe, multiple calls can occur in different threads in parallel. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227a4b1933f8429b66806e8387c1aff33cfd"></a>ObjectThreadingModel_Default</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="manageable_8hpp_source.html#l00033">33</a> of file <a class="el" href="manageable_8hpp_source.html">manageable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321">qi::StreamColor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Stream Color enum. </p>
<dl class="section warning"><dt>Warning</dt><dd>Only working under POSIX.  </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a344631221068a24cef3301551065bc00"></a>StreamColor_None</em>&#160;</td><td class="fielddoc">
<p>No Color. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321aa5ae1a9eb8c9ca2c0427682808b5b3a8"></a>StreamColor_Reset</em>&#160;</td><td class="fielddoc">
<p>Reset the color and mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a4f2f77f9392a206c386c1e89422e3152"></a>StreamColor_Bold</em>&#160;</td><td class="fielddoc">
<p>Bold mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321aac8b681a7977a3d0a07ffcee0b99d5af"></a>StreamColor_Faint</em>&#160;</td><td class="fielddoc">
<p>Faint mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a67fec5cb524c9c012d15a814833b1e57"></a>StreamColor_Standout</em>&#160;</td><td class="fielddoc">
<p>Standout mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a4715eae0b58f7aa8cb08adfa6b5788b9"></a>StreamColor_Underline</em>&#160;</td><td class="fielddoc">
<p>Underline mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a9f4660fb42a98a264060e46d5ba396b8"></a>StreamColor_Blink</em>&#160;</td><td class="fielddoc">
<p>Blink mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321ab5ad1ee5aa153c51cb41d78ba91632a1"></a>StreamColor_Overline</em>&#160;</td><td class="fielddoc">
<p>Overline mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a43a4c4c728f3f852cdb6e454ef918824"></a>StreamColor_Black</em>&#160;</td><td class="fielddoc">
<p>Black. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a67c34ed466def0e9a5dbf1da90fedde0"></a>StreamColor_DarkRed</em>&#160;</td><td class="fielddoc">
<p>Dark Red. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a16f2e3b9e225ef941f0fe8b5a8a6f79c"></a>StreamColor_DarkGreen</em>&#160;</td><td class="fielddoc">
<p>Dark Green. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a68b0b8fdcb78a4b2f8bd9eabf244efaa"></a>StreamColor_Brown</em>&#160;</td><td class="fielddoc">
<p>Brown. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a1c64bda3e21fa88c070db2ac2bcd6bd5"></a>StreamColor_DarkBlue</em>&#160;</td><td class="fielddoc">
<p>Dark Blue. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321af937c4634377d7684ecbe385807e6c37"></a>StreamColor_Purple</em>&#160;</td><td class="fielddoc">
<p>Purple. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a94a58a580a0576ea1f28a2564774f95a"></a>StreamColor_Teal</em>&#160;</td><td class="fielddoc">
<p>Teal. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a6352965a77351604a4fb449f66df96e6"></a>StreamColor_LightGray</em>&#160;</td><td class="fielddoc">
<p>LightGray. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321af8cbac1491dc0aa4350d410c7979610a"></a>StreamColor_DarkGray</em>&#160;</td><td class="fielddoc">
<p>Dark Gray. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a0191c01a1ae8a0f32513e6d435a035b4"></a>StreamColor_Red</em>&#160;</td><td class="fielddoc">
<p>Red. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a7fb90bd6188ea53c9f501f07278639dc"></a>StreamColor_Green</em>&#160;</td><td class="fielddoc">
<p>Green. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321ab65ac4782da71d06fc5033877df7a342"></a>StreamColor_Yellow</em>&#160;</td><td class="fielddoc">
<p>Yellow. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a49b1c68c9ae2782eb143a3a66dae3d55"></a>StreamColor_Blue</em>&#160;</td><td class="fielddoc">
<p>Blue. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a68b9f3474d708de9bbbcfa8ee81f822b"></a>StreamColor_Fuchsia</em>&#160;</td><td class="fielddoc">
<p>Fuchsia. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321ac19037b0d7b1c1a760e7182f3b598091"></a>StreamColor_Turquoise</em>&#160;</td><td class="fielddoc">
<p>Turquoise. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321af2db4cdda545b6e45843235be74f637f"></a>StreamColor_White</em>&#160;</td><td class="fielddoc">
<p>White. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="iocolor_8hpp_source.html#l00019">19</a> of file <a class="el" href="iocolor_8hpp_source.html">iocolor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae01d947882857905031a3773561d3d83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83">qi::TypeKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a9addb80987fbf6aba929a8ba36a8696a"></a>TypeKind_Unknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a697124369f8d09989eb1799cc5b417f1"></a>TypeKind_Void</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a5c9f02f8fde69ebf4ef298429f406ca1"></a>TypeKind_Int</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ac2cb42a5ad96ca81820b32883ff11ce1"></a>TypeKind_Float</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a0cea76e7d2e7ca23952106e2df8e5477"></a>TypeKind_String</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a2d80d8ac34eb816f880492fd48fa9947"></a>TypeKind_List</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a02c298fe28a07aa0fd52762c6ead1f49"></a>TypeKind_Map</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a3fdef608736434b0ed3db23409166f45"></a>TypeKind_Object</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ac588aa7668f30929b99f7b51e164d85e"></a>TypeKind_Pointer</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ae256bb50e674644be82c9e3c875b17b1"></a>TypeKind_Tuple</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ad4857d8288ae9b6587dbbe3a60afb7b1"></a>TypeKind_Dynamic</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a629950116208ae3ec5707f826f77394a"></a>TypeKind_Raw</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a053d4b330c4a9e259ddedd9bd8571ba3"></a>TypeKind_Iterator</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a93d64a5491fde8c3736899b963ed84b6"></a>TypeKind_Function</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ade474d4acfbe0a14655b407dde022904"></a>TypeKind_Signal</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a657d2054debc55771add5e8c42987a26"></a>TypeKind_Property</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a94150a53653301f2fefce04752093ef9"></a>TypeKind_VarArgs</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="fwd_8hpp_source.html#l00053">53</a> of file <a class="el" href="fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a42bc720bd5b8f355e73363ff256c2986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename PT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::adaptFuture </td>
          <td>(</td>
          <td class="paramtype">const Future&lt; FT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Promise&lt; PT &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdaptFutureOption&#160;</td>
          <td class="paramname"><em>option</em> = <code>AdaptFutureOption_ForwardCancel</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feed a promise from a future of possibly different type. </p>
<p>Will monitor <code>f</code>, and bounce its state to <code>p</code>. Error and canceled state are bounced as is. Valued state is bounced through FutureValueConverter&lt;FT, PT&gt;::convert() </p>

<p>Definition at line <a class="el" href="future_8hxx_source.html#l00686">686</a> of file <a class="el" href="future_8hxx_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a6713195abab6fc700564cf545f642e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename PT , typename CONV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::adaptFuture </td>
          <td>(</td>
          <td class="paramtype">const Future&lt; FT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Promise&lt; PT &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONV&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdaptFutureOption&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to adaptFuture(f, p) but with a custom converter. </p>

<p>Definition at line <a class="el" href="future_8hxx_source.html#l00696">696</a> of file <a class="el" href="future_8hxx_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="acb85d5edf8d351adc8212994bd237506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::adaptFutureUnwrap </td>
          <td>(</td>
          <td class="paramtype">Future&lt; AnyReference &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Promise&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feed a promise from a generic future which may be unwrapped if it contains itself a future. </p>

<p>Definition at line <a class="el" href="future_8hxx_source.html#l00677">677</a> of file <a class="el" href="future_8hxx_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad2923b7870efab6ce589a4eafa051318"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc , typename Args &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CONSTEXPR auto qi::apply </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(detail::applyImpl(fwd&lt;Proc&gt;(proc), fwd&lt;Args&gt;(args),
      make_index_sequence&lt;std::tuple_size&lt;traits::Decay&lt;Args&gt;&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the procedure after unpacking the arguments.</p>
<p>Besides std::tuple, arguments can be stored as std::pair, std::array, or any type modeling the <code>Tuple</code> concept (see concept.hpp).</p>
<p>Note: This is roughly equivalent to C++17's <code>std::apply</code>. The main difference is that this version use function call syntax instead of C++17's <code>std::invoke</code>.</p>
<p>TODO: Replace this by <code>std::apply</code> when C++17 is available.</p>
<p>Example: using a <code>std::tuple</code> as a container for arguments </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i, <span class="keywordtype">char</span> c, <span class="keywordtype">float</span> f) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> args = std::make_tuple(5, <span class="charliteral">&#39;a&#39;</span>, 3.14f);</div>
<div class="line"><span class="keywordtype">int</span> res = <a class="code" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a>(f, args);</div>
</div><!-- fragment --><p>Example: using a <code>std::pair</code> as a container for arguments </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i, <span class="keywordtype">char</span> c) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> args = std::make_pair(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"><span class="keywordtype">int</span> res = <a class="code" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a>(f, args);</div>
</div><!-- fragment --><p>Example: using a <code>std::array</code> as a container for arguments </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">std::array&lt;int, 4&gt; args = {13, 2, 9874, 42};</div>
<div class="line"><span class="keywordtype">int</span> res = <a class="code" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a>(f, args);</div>
</div><!-- fragment --><p>Example: using a custom type as a container for arguments </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>test</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">  <span class="keyword">using</span> index = std::integral_constant&lt;std::size_t, N&gt;;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</div>
<div class="line">  <span class="keyword">struct </span>X</div>
<div class="line">  {</div>
<div class="line">    A a;</div>
<div class="line">    B b;</div>
<div class="line">    C c;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="namespaceqi.html#a6df69be73d369666577f9d4b2cd8dd78">operator==</a>(<span class="keyword">const</span> X&amp; y)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> a == y.a &amp;&amp; b == y.b &amp;&amp; c == y.c;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    A&amp; <span class="keyword">get</span>(index&lt;0&gt;) {<span class="keywordflow">return</span> a;}</div>
<div class="line">    B&amp; <span class="keyword">get</span>(index&lt;1&gt;) {<span class="keywordflow">return</span> b;}</div>
<div class="line">    C&amp; <span class="keyword">get</span>(index&lt;2&gt;) {<span class="keywordflow">return</span> c;}</div>
<div class="line">    <span class="keyword">const</span> A&amp; <span class="keyword">get</span>(index&lt;0&gt;) <span class="keyword">const</span> {<span class="keywordflow">return</span> a;}</div>
<div class="line">    <span class="keyword">const</span> B&amp; <span class="keyword">get</span>(index&lt;1&gt;) <span class="keyword">const</span> {<span class="keywordflow">return</span> b;}</div>
<div class="line">    <span class="keyword">const</span> C&amp; <span class="keyword">get</span>(index&lt;2&gt;) <span class="keyword">const</span> {<span class="keywordflow">return</span> c;}</div>
<div class="line">  };</div>
<div class="line">} <span class="comment">// namespace test</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</div>
<div class="line">  <span class="keyword">struct </span>tuple_size&lt;test::X&lt;A, B, C&gt;&gt; : integral_constant&lt;size_t, 3&gt;</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> I, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</div>
<div class="line">  BOOST_CONSTEXPR <span class="keyword">auto</span> <span class="keyword">get</span>(test::X&lt;A, B, C&gt;&amp; x)</div>
<div class="line">    <span class="comment">// TODO: replace the trailing return by a `decltype(auto)` when c++14 is available</span></div>
<div class="line">    -&gt; decltype(x.get(integral_constant&lt;size_t, I&gt;{}))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> x.get(integral_constant&lt;size_t, I&gt;{});</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> I, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;</div>
<div class="line">  BOOST_CONSTEXPR <span class="keyword">auto</span> <span class="keyword">get</span>(<span class="keyword">const</span> test::X&lt;A, B, C&gt;&amp; x)</div>
<div class="line">    <span class="comment">// TODO: replace the trailing return by a `decltype(auto)` when c++14 is available</span></div>
<div class="line">    -&gt; decltype(x.get(integral_constant&lt;size_t, I&gt;{}))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> x.get(integral_constant&lt;size_t, I&gt;{});</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace std</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i, <span class="keywordtype">char</span> c, <span class="keywordtype">float</span> f) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> X args{5, <span class="charliteral">&#39;a&#39;</span>, 3.14f};</div>
<div class="line"><span class="keywordtype">int</span> res = <a class="code" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a>(f, args);</div>
</div><!-- fragment --><p>See <code><a class="el" href="structqi_1_1Apply.html">Apply</a></code> to transform a function into an equivalent tuple-accepting function.</p>
<p>Procedure Proc, Tuple Args </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00549">549</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad097f61d76320a9c07fee60e835ec987"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1Apply.html">Apply</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;Proc&gt; &gt; qi::apply </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to enable type deduction for <code><a class="el" href="structqi_1_1Apply.html">Apply</a></code>.</p>
<p>Note: An overload taking the procedure <em>and</em> the arguments also exists. This allows for currying. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) {</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> args = std::make_pair(34, 45);</div>
<div class="line"></div>
<div class="line"><span class="comment">// immediate call version</span></div>
<div class="line"><span class="keyword">auto</span> res0 = <a class="code" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a>(f, args);</div>
<div class="line"></div>
<div class="line"><span class="comment">// currified version (this version)</span></div>
<div class="line"><span class="keyword">auto</span> f2 = <a class="code" href="namespaceqi.html#ad2923b7870efab6ce589a4eafa051318">apply</a>(f);</div>
<div class="line"><span class="keyword">auto</span> res1 = f2(args);</div>
</div><!-- fragment --><p>Procedure Proc </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00617">617</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41c2015abb2b45d42f54a2558def93e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> qi::asAnyReferenceVector </td>
          <td>(</td>
          <td class="paramtype">const AnyValueVector &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyvalue_8hxx_source.html#l00222">222</a> of file <a class="el" href="anyvalue_8hxx_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab575e2e142b7b0233d6fc65037d2953c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qi::async </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> -&gt; decltype(asyncDelay(std::forward&lt;F&gt;(callback), <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a>(0)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="async_8hpp_source.html#l00053">53</a> of file <a class="el" href="async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b5152d9573d909c3c6af77bf2af3d36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt; qi::async </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>usDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="namespaceqi.html#ab575e2e142b7b0233d6fc65037d2953c">qi::async</a> with <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>use <a class="el" href="namespaceqi.html#ab575e2e142b7b0233d6fc65037d2953c">qi::async</a> with <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> </dd></dl>

<p>Definition at line <a class="el" href="async_8hxx_source.html#l00074">74</a> of file <a class="el" href="async_8hxx_source.html">async.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab8b9ce4d215087ec6c44b1acead8439a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt; qi::async </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="async_8hxx_source.html#l00080">80</a> of file <a class="el" href="async_8hxx_source.html">async.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a2cf40c41506c08b9a833e52e75ec0cbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt; qi::async </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">qi::SteadyClockTimePoint</a>&#160;</td>
          <td class="paramname"><em>timepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="async_8hxx_source.html#l00086">86</a> of file <a class="el" href="async_8hxx_source.html">async.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae9d5d914504a578f0b8a84c72ed225b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; R &gt; qi::async </td>
          <td>(</td>
          <td class="paramtype">detail::Function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="async_8hxx_source.html#l00092">92</a> of file <a class="el" href="async_8hxx_source.html">async.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5210b7d2ffc2ef231ac3708fb8fe02f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename Func , typename ArgTrack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> <a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt; R &gt; qi::async </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgTrack &amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>since 2.5 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>since 2.5 </dd></dl>

</div>
</div>
<a class="anchor" id="a0d957483b6b2fc0c45cfdca6b6a8f0f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qi::asyncAt </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">qi::SteadyClockTimePoint</a>&#160;</td>
          <td class="paramname"><em>timepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespaceqi.html#ac6a56d0b369a9a5eeb3655db91c684c4">qi::getEventLoop</a>()-&gt;asyncAt(std::forward&lt;F&gt;(callback), timepoint))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="async_8hpp_source.html#l00039">39</a> of file <a class="el" href="async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acca874e8edfc26e86e67d2aa0ebe4b46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto qi::asyncDelay </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(detail::asyncMaybeActor(std::forward&lt;F&gt;(callback), delay))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="async_8hpp_source.html#l00046">46</a> of file <a class="el" href="async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22ca99743b6c820547dea46057a73ae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RF , typename AF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;RF&gt; qi::bind </td>
          <td>(</td>
          <td class="paramtype">const AF &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind a set of arguments or placeholders to a function.</p>
<p>Handles first function argument of kind boost::weak_ptr and <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">qi::Trackable</a>: will try to lock and throw <a class="el" href="classqi_1_1PointerLockException.html">qi::PointerLockException</a> in case of failure </p>

</div>
</div>
<a class="anchor" id="adeb703d73fee1effe1f0136b0904eafd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RF , typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_function&lt;RF&gt;::value, boost::function&lt;RF&gt; &gt;::type qi::bind </td>
          <td>(</td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00328">328</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a41601f0d2f297b3f1a984de10e8a9c9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bind </td>
          <td>(</td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(bindWithFallback(detail::throwPointerLockException,
                                 std::forward&lt;AF&gt;(fun),
                                 std::forward&lt;Arg0&gt;(arg0),
                                 std::forward&lt;Args&gt;(args)...))
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00367">367</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a852d1acd8a0824952d478af86474556c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , typename Instance , typename... Args0, typename... Args1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bind </td>
          <td>(</td>
          <td class="paramtype">R(T::*)(Args0...)&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Instance &amp;&amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args1 &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(bindWithFallback(detail::throwPointerLockException,
                                 fun,
                                 std::forward&lt;Instance&gt;(instance),
                                 std::forward&lt;Args1&gt;(args1)...))
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00380">380</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a80211310d5c4fd6f9768396b14459835"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bind </td>
          <td>(</td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;!std::is_function&lt;R&gt;::value,
                               decltype(bindWithFallback&lt;R&gt;(detail::throwPointerLockException,
                                                            std::forward&lt;AF&gt;(fun),
                                                            std::forward&lt;Arg0&gt;(arg0),
                                                            std::forward&lt;Args&gt;(args)...))&gt;::type
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00419">419</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8b4b9da69c1f056b094ce6521301d6f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RF , typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_function&lt;RF&gt;::value, boost::function&lt;RF&gt; &gt;::type qi::bindSilent </td>
          <td>(</td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00320">320</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8420286a730e1b793c3a2f6208add98e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bindSilent </td>
          <td>(</td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(bindWithFallback(</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00361">361</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa9855741a0db80f057536af488980726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bindSilent </td>
          <td>(</td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;!std::is_function&lt;R&gt;::value,
                               decltype(bindWithFallback&lt;R&gt;(</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00408">408</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a24ccfd8deefb14a2fe5c90e78fd5c818"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RF , typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_function&lt;RF&gt;::value, boost::function&lt;RF&gt; &gt;::type qi::bindWithFallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00311">311</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="af65e70e6444329669eebf9aeb876c562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bindWithFallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename detail::BindTransform&lt;Arg0&gt;::template wrap_type&lt;
         typename detail::WorkaroundVS2015&lt;AF, Arg0, Args...&gt;::type
       &gt;
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00349">349</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad98d4ee31d6e7c8440b43a01d27e2277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename AF , typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::bindWithFallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AF &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;!std::is_function&lt;R&gt;::value,
                               typename detail::BindTransform&lt;Arg0&gt;::template wrap_type&lt;
                                 decltype(boost::bind&lt;R&gt;(std::forward&lt;AF&gt;(fun),
                                                         detail::BindTransform&lt;Arg0&gt;::transform(arg0),
                                                         std::forward&lt;Args&gt;(args)...))&gt;&gt;::type
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00394">394</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae1b632e7d53ca5acaf7cc97c66b17e99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::boundedRange </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; BoundedRange&lt;decltype(begin(s))&gt;
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence S. </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00129">129</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23dfda437b43d1cbd65276236bb5e2ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1BoundedRange.html">BoundedRange</a>&lt;I&gt; qi::boundedRange </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precondition: boundedRange(b, e) (we're talking about the property here) Iterator I </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00137">137</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a708f891b1f951f7e4d40b77e8d80a00a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::callWithInstance </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::forward&lt;Func&gt;(f)(std::forward&lt;Args&gt;(args)...))
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stringtypeinterface_8hxx_source.html#l00112">112</a> of file <a class="el" href="stringtypeinterface_8hxx_source.html">stringtypeinterface.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae9702e228415f8fe6c8631fc61d67d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Obj , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::callWithInstance </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((std::forward&lt;Obj&gt;(o).*std::forward&lt;Func&gt;(f))(std::forward&lt;Args&gt;(args)...))
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stringtypeinterface_8hxx_source.html#l00119">119</a> of file <a class="el" href="stringtypeinterface_8hxx_source.html">stringtypeinterface.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa7029b49605d7bbd34f9ccde4d27b38c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; T &gt; qi::cancelOnTimeout </td>
          <td>(</td>
          <td class="paramtype">Future&lt; T &gt;&#160;</td>
          <td class="paramname"><em>fut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Duration&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels the future when the timeout expires.</p>
<p>The output future is the same as the input one, to allow functional composition. </p>

<p>Definition at line <a class="el" href="async_8hxx_source.html#l00147">147</a> of file <a class="el" href="async_8hxx_source.html">async.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5cd78c5617e5e124c476e7249b55338a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1Composition.html">Composition</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;G&gt;, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;F&gt; &gt; qi::compose </td>
          <td>(</td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a mathematical function composition.</p>
<p>Example: Composing with a non-void function </p>
<div class="fragment"><div class="line"><span class="comment">// `motor` takes a `string` and returns the properties of a motor.</span></div>
<div class="line"><span class="comment">// `heat` takes the properties of a motor and returns an `int`.</span></div>
<div class="line"><span class="comment">// `motorNames` is a container of string.</span></div>
<div class="line"><span class="keyword">auto</span> heatOfMotor = <a class="code" href="namespaceqi.html#a5cd78c5617e5e124c476e7249b55338a">compose</a>(heat, motor);</div>
<div class="line"><span class="keyword">auto</span> maxHeat = std::max_element(motorNames.begin(), motorNames.end(), heatOfMotor);</div>
</div><!-- fragment --><p>Example: Composing with a void function </p>
<div class="fragment"><div class="line"><span class="comment">// `logName` and `logHeat` take no input (void) and returns no ouput (void).</span></div>
<div class="line"><span class="keyword">auto</span> logNameThenHeat = <a class="code" href="namespaceqi.html#a5cd78c5617e5e124c476e7249b55338a">compose</a>(logHeat, logName);</div>
<div class="line"><span class="keyword">auto</span> fut = strand.async(logNameThenHeat);</div>
</div><!-- fragment --><p>Remark: In the future, add a SFINAE guard if there is a name clash. Alternatively, rename this function in <code>funCompose</code>.</p>
<p>Procedure&lt;C (B)&gt; G, Procedure&lt;B (Args...)&gt; F </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00163">163</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb244ec529ea9c107997dac4a4038ff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;typename <a class="el" href="structqi_1_1detail_1_1InterfaceImplTraits.html">detail::InterfaceImplTraits</a>&lt;T&gt;::Defined, <a class="el" href="classqi_1_1Object.html">qi::Object</a>&lt;T&gt; &gt;::type qi::constructObject </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="object_8hxx_source.html#l00185">185</a> of file <a class="el" href="object_8hxx_source.html">object.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a04bf0d39461c575e93e1525f62318675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;typename <a class="el" href="structqi_1_1detail_1_1InterfaceImplTraits.html">detail::InterfaceImplTraits</a>&lt;T&gt;::Defined, <a class="el" href="classqi_1_1Object.html">qi::Object</a>&lt;T&gt; &gt;::type qi::constructObject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="object_8hxx_source.html#l00191">191</a> of file <a class="el" href="object_8hxx_source.html">object.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="afb0d4bdf8a789f784658ded47e0d917a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1DataBoundTransfo.html">DataBoundTransfo</a>&lt;T&gt; qi::dataBoundTransfo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>maintainAlive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to deduce types for <a class="el" href="structqi_1_1DataBoundTransfo.html">DataBoundTransfo</a>. </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00311">311</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af15e3f2c9126d512dbdc9a5d77abd212"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; qi::declref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a L-value reference in a non-evaluated context.</p>
<p>Note: Because of the non-evaluated context, the function need not be defined.</p>
<p>Note: This follows the same idea as <code>std::declval()</code>.</p>
<p>Example: Statically selecting an overload. </p>
<div class="fragment"><div class="line"><span class="comment">// Different overloads of `f` will return different types.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T f(T&amp; t) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T* f(T (&amp;a)[N]) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;ytpename T&gt;</div>
<div class="line"><span class="keyword">struct </span>X {</div>
<div class="line">  <span class="comment">// Produce a &quot;fake&quot; L-value reference in a `decltype` context.</span></div>
<div class="line">  <span class="keyword">using</span> U = decltype(f(declref&lt;T&gt;()));</div>
<div class="line">};</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af281051bb6005da6852e3c1663b92809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> qi::decodeBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqi_1_1BufferReader.html">qi::BufferReader</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeserializeObjectCallback&#160;</td>
          <td class="paramname"><em>onObject</em> = <code>DeserializeObjectCallback()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamContext *&#160;</td>
          <td class="paramname"><em>streamContext</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binarycodec_8hpp_source.html#l00072">72</a> of file <a class="el" href="binarycodec_8hpp_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16af60016b63fd1947d059e73bc597a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> qi::decodeBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqi_1_1BufferReader.html">qi::BufferReader</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyReference&#160;</td>
          <td class="paramname"><em>gvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeserializeObjectCallback&#160;</td>
          <td class="paramname"><em>onObject</em> = <code>DeserializeObjectCallback()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamContext *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode content of <code>buf</code> into <code>gvp</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer with serialized data </td></tr>
    <tr><td class="paramname">gvp</td><td>initialized <a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> of correct type. Will be filled in. </td></tr>
    <tr><td class="paramname">onObject</td><td>callback invoked each time an object is encountered. </td></tr>
    <tr><td class="paramname">ctx</td><td>connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the deserialize type visitor</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the decoding fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc0f8ab49ff6d865e791e8fd84ffa212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyValue.html">qi::AnyValue</a> qi::decodeJSON </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>creates a GV representing a JSON string or throw on parse error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>JSON string to decode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a GV representing the JSON string </dd></dl>

</div>
</div>
<a class="anchor" id="aefbddfd2b5c63e97a33bb1f4583a64ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator qi::decodeJSON </td>
          <td>(</td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyValue &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the input GV to represent the JSON sequence between two string iterators or throw on parse error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the beginning of the sequence to decode. </td></tr>
    <tr><td class="paramname">end</td><td>iterator to the end of the sequence to decode. </td></tr>
    <tr><td class="paramname">target</td><td>GV to set. Not modified if an error occured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the last read char + 1 </dd></dl>

</div>
</div>
<a class="anchor" id="ad774296b27b62b0ca406b6d15c4fd170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Translator.html">qi::Translator</a>&amp; qi::defaultTranslator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference on the default <a class="el" href="classqi_1_1Translator.html" title="Localization of your source code. ">Translator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td><a class="el" href="classqi_1_1Application.html" title="Class handling startup and teardown of an application. ">Application</a> or Library name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference on default <a class="el" href="classqi_1_1Translator.html" title="Localization of your source code. ">qi::Translator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae26d36a78c6f895808cf6b964413a0a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DurationTo , class TimePointFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DurationTo qi::durationSince </td>
          <td>(</td>
          <td class="paramtype">const TimePointFrom &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>}@ </p>
<p>Returns the duration elapsed since <code>t</code>. </p>

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00041">41</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a098783b698f8b1042afa3fcb13fb2d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1FunctionTypeInterface.html">FunctionTypeInterface</a>* qi::dynamicFunctionTypeInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the type used by dynamic functions </dd></dl>

</div>
</div>
<a class="anchor" id="abdbf6e86e09a9069786dfcc083b82074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#a118f2d350ecce997af3f9e1c817fa321">StreamColor</a> qi::enabledColor </td>
          <td>(</td>
          <td class="paramtype">StreamColor&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>color</code> if <code>enable</code> is true, otherwise returns no color. </p>
<p>This function can be used to easily enable or disable colors when streaming.  
<p>Definition at line <a class="el" href="iocolor_8hpp_source.html#l00059">59</a> of file <a class="el" href="iocolor_8hpp_source.html">iocolor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb540c3b6650f31ca7695cb2bccd69cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::encodeBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqi_1_1Buffer.html">qi::Buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AutoAnyReference &amp;&#160;</td>
          <td class="paramname"><em>gvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerializeObjectCallback&#160;</td>
          <td class="paramname"><em>onObject</em> = <code>SerializeObjectCallback()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamContext *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encode content of <code>gvp</code> into <code>buf</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer that will be filled with serialized data </td></tr>
    <tr><td class="paramname">gvp</td><td><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> to serialize </td></tr>
    <tr><td class="paramname">onObject</td><td>callback invoked each time an object is encountered. </td></tr>
    <tr><td class="paramname">ctx</td><td>connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the encoding fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac05c81e881944949765491389e879e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::encodeJSON </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1AutoAnyReference.html">qi::AutoAnyReference</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonOption&#160;</td>
          <td class="paramname"><em>jsonPrintOption</em> = <code>JsonOption_None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value encoded in JSON. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to encode </td></tr>
    <tr><td class="paramname">jsonPrintOption</td><td>Option to change JSON output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afec3f81bb472c7ecc1211a9fc46bb944"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::erase_if </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase all elements that respect the predicate. Optimizations are performed for contiguous-like sequences (vector, deque...) and for list sequences (list, forward_list). If you want to take advantage on this for your own containers, specialize <a class="el" href="namespaceqi_1_1traits.html#a89615ceb8eb2349e635177375fb6c9cc" title="True if the underlying memory is contiguous, or &quot;almost&quot; as in std::deque. ">traits::IsContiguousLike</a> or <a class="el" href="namespaceqi_1_1traits.html#a7ee5d9fddb738993675a5ac04664c29a">traits::IsList</a>. Note: It would be nice to return the predicate, because it could be stateful and for example count the number of true elements, but it's not possible because underlying stl algorithms and member functions do not return the predicate... Sequence&lt;T&gt; S, Predicate&lt;T&gt; P </p>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00078">78</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78f7c49ded676ae47ef49ed3d148ccab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::front </td>
          <td>(</td>
          <td class="paramtype">const BoundedRange&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(*x.b)
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precondition: !isEmpty(x) </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00115">115</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90f9911f327625384b40df3b77b91e1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::front </td>
          <td>(</td>
          <td class="paramtype">BoundedRange&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(*x.b)
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precondition: !isEmpty(x) </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00122">122</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b03843ce5c18a2014bd3661dfc29d6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::futurizeOutput </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; decltype(semiLift(std::forward&lt;Proc&gt;(p), UnitFuture</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new function similar to the given one except that it returns a future.</p>
<p>This is a "semi-lifting" (see <code>semilift</code> for an explanation of the lifting notion)</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="comment">// `heavyCompute` takes a `vector&lt;int&gt;` and returns an `int`.</span></div>
<div class="line"><span class="comment">// `v` is a `vector&lt;int&gt;`.</span></div>
<div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespaceqi.html#a8b03843ce5c18a2014bd3661dfc29d6b">futurizeOutput</a>(heavyCompute);</div>
<div class="line">Future&lt;int&gt; res = f(v);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>TODO: Remove the trailing return type when get rid of C++11.</p>
<p>Procedure Proc </p>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l01105">1105</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea73608226c5ebcb2ec776cb48326542"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CONSTEXPR T&amp;&amp; qi::fwd </td>
          <td>(</td>
          <td class="paramtype">typename std::remove_reference&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Less noisy equivalent to <code>std::forward</code>.</p>
<p>The only purpose is to reduce the noise in libqi's generic code: occurrences of <code>std::forward&lt;T&gt;(t)</code> can be replaced by <code>fwd&lt;T&gt;(t)</code>.</p>
<p>Note: This code is from the libstdc++ shipped with g++-7. </p>

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00019">19</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67f42f6da26ee4f8591073a1054e2303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BOOST_CONSTEXPR T&amp;&amp; qi::fwd </td>
          <td>(</td>
          <td class="paramtype">typename std::remove_reference&lt; T &gt;::type &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00025">25</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acde1dffa366528f25db3597abb0b2fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1ObjectTypeInterface.html">ObjectTypeInterface</a>* qi::getDynamicTypeInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6a56d0b369a9a5eeb3655db91c684c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1EventLoop.html">EventLoop</a>* qi::getEventLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global eventloop, created on demand on first call. </p>

</div>
</div>
<a class="anchor" id="aa3ee2a95759c087e0cdadbe608a1ac59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_service&amp; qi::getIoService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the io_service used by the global event loop. </p>
<dl class="section return"><dt>Returns</dt><dd>io_service used by the global event loop. </dd></dl>

</div>
</div>
<a class="anchor" id="aa43ba1400740a437a2ef3e2f70a5525f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1EventLoop.html">EventLoop</a>* qi::getNetworkEventLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global network eventloop, created on demand on first call. </p>

</div>
</div>
<a class="anchor" id="ad7d0e709c6dd1b32ddd4d9a427926ea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::getRegisteredStruct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>matching <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> registered by <a class="el" href="namespaceqi.html#ae5acba1383706c293755c20935f7d613">registerStruct()</a> or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a28374f6240c824f5c32b7d3a30e6ba0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::getType </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime Type factory getter. Used by <a class="el" href="namespaceqi.html#a45c4fec4058dee00453ef20d1c544eec">typeOf&lt;T&gt;()</a> </p>

</div>
</div>
<a class="anchor" id="a5882f25a3446993872bf1203d8ac5243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyModule.html">AnyModule</a> qi::import </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find a module and import it, this is cross language, that's the main module entry point</p>
<p>this function dispatch to &lt;lang&gt; module factory, if the module is not already registered </p>

</div>
</div>
<a class="anchor" id="ac2d8256b364ab12d3b96d6bb3832b60e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyModule.html">AnyModule</a> qi::import </td>
          <td>(</td>
          <td class="paramtype">const ModuleInfo &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e094e4b1ee68b7e4890063f7848a5a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;N&gt; &gt; qi::incrRange </td>
          <td>(</td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preconditions: boundedRange(b, e) Incrementable N </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00190">190</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d75a3cdf9b7b89ac09dbc684f3c678b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;N&gt; &gt; qi::incrRange </td>
          <td>(</td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preconditions: boundedRange(N{}, e) Incrementable N </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00198">198</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21578104a134d3507d8152f05a99e3c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1IncrBoundedRange.html">IncrBoundedRange</a>&lt;N&gt; qi::incrRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic N. </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00205">205</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57822b00c360f76c573a0b4e57bfb5d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1IncrBoundedRangeAction.html">IncrBoundedRangeAction</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;N&gt;, <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;A&gt; &gt; qi::incrRange </td>
          <td>(</td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preconditions: boundedRange(b, e) Iterator N, Action&lt;N&gt; A </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00255">255</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6a8299efe2331d67dee28e2c3b953f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1IncrBoundedRangeAction.html">IncrBoundedRangeAction</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;N&gt;, <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;A&gt; &gt; qi::incrRange </td>
          <td>(</td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preconditions: boundedRange(N{}, e) Iterator N, Action&lt;N&gt; A </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00263">263</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a794f866008cc174c5c3bbfe1aa53854d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc , typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::invokeCatch </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>handleException</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...))
  </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes a procedure in a try-catch clause and delegates exception handling to a dedicated handler.</p>
<p>std::exceptions and boost::exceptions are passed as-is to the handler. In all other cases, the handler is called without parameter.</p>
<p>This function can be used for example to log the exception and rethrow, to translate the exception to a value (useful to compose functions in a purely functional manner), etc.</p>
<p>See <a class="el" href="structqi_1_1ExceptionValue.html">ExceptionValue</a>, <a class="el" href="structqi_1_1HandleExceptionAndRethrow.html">HandleExceptionAndRethrow</a>.</p>
<p>Note: The exception types are hardcoded instead of specifying them via a variadic list because, in a variadic template approach catching the exceptions E0, E1 and any exception would generate this kind of code: </p>
<div class="fragment"><div class="line">*  <span class="keywordflow">try</span> {</div>
<div class="line">*    <span class="keywordflow">try</span> {</div>
<div class="line">*      <span class="keywordflow">try</span> {</div>
<div class="line">*        <span class="keywordflow">return</span> f(args...);</div>
<div class="line">*      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> E0&amp; e0) {</div>
<div class="line">*        <span class="keywordflow">return</span> handleException(e0);</div>
<div class="line">*      }</div>
<div class="line">*    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> E1&amp; e1) {</div>
<div class="line">*      <span class="keywordflow">return</span> handleException(e1);</div>
<div class="line">*    }</div>
<div class="line">*  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">*    <span class="keywordflow">return</span> handleException();</div>
<div class="line">*  }</div>
<div class="line">* </div>
</div><!-- fragment --><p> which is not equivalent to this handwritten code: </p>
<div class="fragment"><div class="line">*   <span class="keywordflow">try</span> {</div>
<div class="line">*     <span class="keywordflow">return</span> f(args...);</div>
<div class="line">*   } <span class="keywordflow">catch</span> (<span class="keyword">const</span> E0&amp; e0) {</div>
<div class="line">*     <span class="keywordflow">return</span> handleException(e0);</div>
<div class="line">*   } <span class="keywordflow">catch</span> (<span class="keyword">const</span> E1&amp; e1) {</div>
<div class="line">*     <span class="keywordflow">return</span> handleException(e1);</div>
<div class="line">*   } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">*     <span class="keywordflow">return</span> handleException();</div>
<div class="line">*   }</div>
<div class="line">* </div>
</div><!-- fragment --><p> because if the exception handler rethrows the exception, the "catch all" clause will always be called. So it seems, there is no way in C++ to specify in a compile-time way a list of exceptions to catch...</p>
<p>PolymorphicProcedure&lt;Ret (const std::exception&amp;), Ret (const boost::exception&amp;), Ret ()&gt; Proc, Procedure&lt;Ret (Args...)&gt; F </p>

<p>Definition at line <a class="el" href="errorhandling_8hpp_source.html#l00133">133</a> of file <a class="el" href="errorhandling_8hpp_source.html">errorhandling.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af68bfc01c21c9742b95d9cd5dbfd383f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structqi_1_1ModuleInfo.html">ModuleInfo</a>&gt; qi::listModules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>list all available modules (cross language </p>

</div>
</div>
<a class="anchor" id="a90b4c5ca7029f9c9b94be4c92f0aa1d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void()&gt; qi::makeCanceler </td>
          <td>(</td>
          <td class="paramtype">Future&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l01044">1044</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04d6828dff16659a53da08c7de30956f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> qi::makeDynamicAnyObject </td>
          <td>(</td>
          <td class="paramtype">DynamicObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>destroyObject</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(GenericObject *)&gt;&#160;</td>
          <td class="paramname"><em>onDelete</em> = <code>boost::function&lt;&#160;void(GenericObject&#160;*)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a230889c807a35900df1fb6385a926a98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> qi::makeDynamicSharedAnyObject </td>
          <td>(</td>
          <td class="paramtype">DynamicObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make an AnyObject that shares its ref counter with <code>other</code> Note that <code>obj</code> will not be destroyed when the shared counter reaches 0. </p>

<p>Definition at line <a class="el" href="dynamicobject_8hpp_source.html#l00081">81</a> of file <a class="el" href="dynamicobject_8hpp_source.html">dynamicobject.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a631fd1daf49d80aa9abb8210efc13769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> qi::makeDynamicSharedAnyObjectImpl </td>
          <td>(</td>
          <td class="paramtype">DynamicObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; Empty &gt;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae09c8c0d171c2ef5e3b2c4db795d8db4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeFloatType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytelen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of kind float, bytelen can be 4 or 8 </dd></dl>

</div>
</div>
<a class="anchor" id="af824fdaacc150d8140e14cedebc08f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1FunctionTypeInterface.html">FunctionTypeInterface</a>* qi::makeFunctionTypeInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad14f72235d0dd750a72c972d59d6531a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt; T &gt; qi::makeFutureError </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to return a future with the error set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>the error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="future_8hxx_source.html#l00615">615</a> of file <a class="el" href="future_8hxx_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0677f9994ab898cc93a8131b83bd2102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> qi::makeGenericTuple </td>
          <td>(</td>
          <td class="paramtype">const AnyReferenceVector &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an allocated Tuple made from copies of </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f7d98cfcf8874b647ce4fbfbb0040ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AnyReference.html">AnyReference</a> qi::makeGenericTuplePtr </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TypeInterface * &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Tuple pointing to values as its storage </dd></dl>

</div>
</div>
<a class="anchor" id="a426b195e4c91c436ffe1a3230ec5f712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeIntType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>issigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of kind int, bytelen can be 0,1,2,4,8 </dd></dl>

</div>
</div>
<a class="anchor" id="a481997bd83b95542e6372d1d94456022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeKwArgsSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03e3b32ae885f36dc89d1f72f91878bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeListSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ada86c6a16b6970d55b47851227487f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeListType </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>elementType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of kind List that can contains elements of type elementType. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c033cfdd2ccfc485a907b540e081595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1StringTypeInterface.html#a69bcd8b478c65e82ac1151603733cb66">StringTypeInterface::ManagedRawString</a> qi::makeManagedString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stringtypeinterface_8hxx_source.html#l00125">125</a> of file <a class="el" href="stringtypeinterface_8hxx_source.html">stringtypeinterface.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a93205f8e788842061edc90c2a298a4f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1StringTypeInterface.html#a69bcd8b478c65e82ac1151603733cb66">StringTypeInterface::ManagedRawString</a> qi::makeManagedString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stringtypeinterface_8hxx_source.html#l00131">131</a> of file <a class="el" href="stringtypeinterface_8hxx_source.html">stringtypeinterface.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0e4e963b37472078c2a9d927b44ef97d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeMapSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84d0f507e9bcd84530c9650100c17a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeMapType </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>keyType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>ElementType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of kind Map with given key and element types </dd></dl>

</div>
</div>
<a class="anchor" id="a98ec8195dad170930fdfb6a976e87f4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Src &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1MoveAssign.html">MoveAssign</a>&lt;Dest, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;Src&gt; &gt; qi::makeMoveAssign </td>
          <td>(</td>
          <td class="paramtype">Src &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that performs type deduction for <code><a class="el" href="structqi_1_1MoveAssign.html">MoveAssign</a></code>. </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00354">354</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fc6dd0b5694ff4d27c7b027683040b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1MoveOnCopy.html">MoveOnCopy</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;T&gt;...&gt; qi::makeMoveOnCopy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to perform type deduction for constructing a <a class="el" href="classqi_1_1MoveOnCopy.html">MoveOnCopy</a>. </p>

<p>Definition at line <a class="el" href="moveoncopy_8hpp_source.html#l00157">157</a> of file <a class="el" href="moveoncopy_8hpp_source.html">moveoncopy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae119360c94e8f9f5c9f1ba9313317c79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a>&lt;<a class="el" href="namespaceqi_1_1detail.html#ab8df1459137c970236482a85c81ede7f">detail::Raw</a>&lt;T&gt;, <a class="el" href="namespaceqi_1_1detail.html#ab8df1459137c970236482a85c81ede7f">detail::Raw</a>&lt;T&gt;*&gt; qi::makeMutableStore </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to perform type-deduction for <code><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a></code>.</p>
<p>Type deduction proceeds this way:</p>
<ul>
<li>if a pointer of type <code>T*</code> is passed, the returned type is <code><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a>&lt;T, T*&gt;</code> containing the given pointer.</li>
<li>otherwise, a non-pointer object of type <code>T</code> is passed, and the returned type is <code><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a>&lt;T, T*&gt;</code> containing the given object.</li>
</ul>
<p>Example: Storing a value by address </p>
<div class="fragment"><div class="line">*  <span class="keywordtype">int</span> j = 0;</div>
<div class="line">*  <span class="keyword">auto</span> m = <a class="code" href="namespaceqi.html#ae119360c94e8f9f5c9f1ba9313317c79">makeMutableStore</a>(&amp;j);</div>
<div class="line">*  ++(*m);</div>
<div class="line">*  <span class="comment">// here, `j == 1`</span></div>
<div class="line">* </div>
</div><!-- fragment --><p>Example: Storing a value by value </p>
<div class="fragment"><div class="line">*  <span class="keywordtype">int</span> j = 0;</div>
<div class="line">*  <span class="keyword">auto</span> m = <a class="code" href="namespaceqi.html#ae119360c94e8f9f5c9f1ba9313317c79">makeMutableStore</a>(j); <span class="comment">// copy the value</span></div>
<div class="line">*  ++(*m);</div>
<div class="line">*  <span class="comment">// here, `j == 0`</span></div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="mutablestore_8hpp_source.html#l00203">203</a> of file <a class="el" href="mutablestore_8hpp_source.html">mutablestore.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a521d440f7a71f8bda469824ad8a46fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;T&gt;, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;T&gt;*&gt; qi::makeMutableStoreFwd </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to perform delayed perfect-forwarding in a generic context.</p>
<p>Example: Perfect-forwarding a parameter after capture in a lambda </p>
<div class="fragment"><div class="line">*  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">*  <span class="keywordtype">void</span> f(T&amp;&amp; t) {</div>
<div class="line">*    <span class="comment">// 1) Store `t` by address if it is an L-value, by value otherwise.</span></div>
<div class="line">*    <span class="keyword">auto</span> mut = <a class="code" href="namespaceqi.html#a521d440f7a71f8bda469824ad8a46fbf">makeMutableStoreFwd</a>(fwd&lt;T&gt;(t));</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// 2) Wrap `mut` to move it into the lambda.</span></div>
<div class="line">*    <span class="keyword">auto</span> moc = <a class="code" href="namespaceqi.html#a5fc6dd0b5694ff4d27c7b027683040b0">makeMoveOnCopy</a>(mut);</div>
<div class="line">* </div>
<div class="line">*    <a class="code" href="namespaceqi.html#ab575e2e142b7b0233d6fc65037d2953c">async</a>([=] {</div>
<div class="line">* </div>
<div class="line">*      <span class="comment">// 3) Get the value back and perfect-forward it to the next procedure.</span></div>
<div class="line">*      <span class="comment">//    `**moc` is a L-value ref so `fwd&lt;T&gt;(**moc)` works as expected.</span></div>
<div class="line">*      g(fwd&lt;T&gt;(**moc));</div>
<div class="line">*    });</div>
<div class="line">*  }</div>
<div class="line">* </div>
</div><!-- fragment --><p>If you just want to construct a <code><a class="el" href="classqi_1_1MutableStore.html">MutableStore</a></code> with type deduction, simply use <code>makeMutableStore</code>. </p>

<p>Definition at line <a class="el" href="mutablestore_8hpp_source.html#l00233">233</a> of file <a class="el" href="mutablestore_8hpp_source.html">mutablestore.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24a03dcb5873ecafec163c01ded08ccb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class...&gt; class PropertyType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::makeProxyProperty </td>
          <td>(</td>
          <td class="paramtype">PropertyType&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="proxyproperty_8hpp_source.html#l00048">48</a> of file <a class="el" href="proxyproperty_8hpp_source.html">proxyproperty.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0dbdca1386a4f383b1a8daba304a13d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class...&gt; class PropertyType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::makeProxyProperty </td>
          <td>(</td>
          <td class="paramtype">ProxyProperty&lt; T, PropertyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="proxyproperty_8hpp_source.html#l00054">54</a> of file <a class="el" href="proxyproperty_8hpp_source.html">proxyproperty.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4ab95a69a97a75ef18b2337ac5a5932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::makeProxySignal </td>
          <td>(</td>
          <td class="paramtype">SignalF&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="proxysignal_8hpp_source.html#l00045">45</a> of file <a class="el" href="proxysignal_8hpp_source.html">proxysignal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a748adf53e6743b399564d041658ad6ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::makeProxySignal </td>
          <td>(</td>
          <td class="paramtype">ProxySignal&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="proxysignal_8hpp_source.html#l00052">52</a> of file <a class="el" href="proxysignal_8hpp_source.html">proxysignal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19e80758d48f7fc287d29980eb0e6565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#ae3cc5a91e6d98c912baaa84d6ff3e54c">SessionPtr</a> qi::makeSession </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="session_8hpp_source.html#l00199">199</a> of file <a class="el" href="session_8hpp_source.html">session.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57e7b45e3cfcd1b27585b5776c268642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeTupleSignature </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classqi_1_1AnyReference.html">qi::AnyReference</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vgv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resolveDynamic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa0f39be2e53755f32bc54f278b92f6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeTupleSignature </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TypeInterface * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vgv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa258277993d928c87aed1a62bc8d900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeTupleSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7eaf3d66d510df1dd23529d3f4f20631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeTupleType </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TypeInterface * &gt; &amp;&#160;</td>
          <td class="paramname"><em>memberTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of kind Tuple with givent memberTypes </dd></dl>

</div>
</div>
<a class="anchor" id="a23e607036093eb12c791c880d865e5d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1StringTypeInterface.html">StringTypeInterface</a>* qi::makeTypeEquivalentString </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="stringtypeinterface_8hxx_source.html#l00170">170</a> of file <a class="el" href="stringtypeinterface_8hxx_source.html">stringtypeinterface.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad88d038b69d6ddd1416c07784d4c2854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeTypeOfKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqi.html#ae01d947882857905031a3773561d3d83">qi::TypeKind</a> &amp;&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of the specified Kind. This do not work for list, map and tuple. kind Int and Float will create the biggest possible type. use makeFloatType and makeIntType to be more specific. </dd></dl>

</div>
</div>
<a class="anchor" id="a67377d0f4a7dddc54912d96031b4b06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Signature.html">qi::Signature</a> qi::makeVarArgsSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqi_1_1Signature.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a537adf368dd07b2b5d5a248780f4f768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::makeVarArgsType </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>elementType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a Type of kind VarArgs that can contains elements of type elementType. </dd></dl>

</div>
</div>
<a class="anchor" id="aab97cd68b446e79163130ece29d2c5f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt;<a class="el" href="classqi_1_1AnyReference.html">AnyReference</a>&gt; qi::metaCall </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectThreadingModel&#160;</td>
          <td class="paramname"><em>objectThreadingModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetaCallType&#160;</td>
          <td class="paramname"><em>methodThreadingModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetaCallType&#160;</td>
          <td class="paramname"><em>callType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>manageable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>methodId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyFunction&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenericFunctionParameters &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noCloneFirst</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>callerId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqi_1_1os_1_1timeval.html">qi::os::timeval</a>&#160;</td>
          <td class="paramname"><em>postTimestamp</em> = <code><a class="el" href="structqi_1_1os_1_1timeval.html">qi::os::timeval</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a call honoring ThreadingModel requirements</p>
<p>Check the following rules in order:</p>
<ul>
<li>If methodThreadingModel is not auto, honor it, overriding callType</li>
<li>If el is set, force call in it (synchronously if we are in it).</li>
<li>If callType is set (not auto), honor it.</li>
<li>Be synchronous.</li>
</ul>
<p>When the call is finally made, if objectThreadingModel is SingleThread, acquire the object lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>context into which the call will be scheduled </td></tr>
    <tr><td class="paramname">objectThreadingModel</td><td>the threading model of the called object </td></tr>
    <tr><td class="paramname">methodThreadingModel</td><td>the threading model of the specific method </td></tr>
    <tr><td class="paramname">callType</td><td>the requested threading model </td></tr>
    <tr><td class="paramname">manageable</td><td>the object on which to make the call </td></tr>
    <tr><td class="paramname">methodId</td><td>the method id of the object to call </td></tr>
    <tr><td class="paramname">func</td><td>the function to call </td></tr>
    <tr><td class="paramname">params</td><td>the arguments of the call </td></tr>
    <tr><td class="paramname">noCloneFirst</td><td>whether the first argument of the call should be cloned or not </td></tr>
    <tr><td class="paramname">callerId</td><td>thread id of caller, for tracing purposes </td></tr>
    <tr><td class="paramname">postTimestamp</td><td>the time when the call was requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86d3fe036a58d21b7fe41fb71bf4cd95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::nullConverter </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="eventloop_8hxx_source.html#l00015">15</a> of file <a class="el" href="eventloop_8hxx_source.html">eventloop.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a93f54abf0f63a1de518ebaafbd3b699a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyiterator_8hxx_source.html#l00060">60</a> of file <a class="el" href="anyiterator_8hxx_source.html">anyiterator.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a621564f7183b228b46b58f1569bb563c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyvalue_8hxx_source.html#l00196">196</a> of file <a class="el" href="anyvalue_8hxx_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8034f21d05a022058fc33b5d6f544f3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares the url strings. </p>

<p>Definition at line <a class="el" href="url_8hpp_source.html#l00150">150</a> of file <a class="el" href="url_8hpp_source.html">url.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac398d2fe06ebe5fdef4da056f35be095"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="signature_8hpp_source.html#l00154">154</a> of file <a class="el" href="signature_8hpp_source.html">signature.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef6d91fe199c228cda7583edf00e5363"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyreference_8hxx_source.html#l00283">283</a> of file <a class="el" href="anyreference_8hxx_source.html">anyreference.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="abe00774a87836a58440771526eb26581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const TraceAnalyzer::FlowLink &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceAnalyzer::FlowLink &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="traceanalyzer_8hpp_source.html#l00050">50</a> of file <a class="el" href="traceanalyzer_8hpp_source.html">traceanalyzer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ecf9e30b3f2341c824fb4bd5493bbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator. Will compare the values within the <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a>. </p>

<p>Definition at line <a class="el" href="anyvalue_8hxx_source.html#l00231">231</a> of file <a class="el" href="anyvalue_8hxx_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="afe13c66dd9a2409ff4535a5673f71885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const MetaObject &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetaObject &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c0458e8f45de0e037c7cb9bfa56b31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a11e17bcab021ca6d6bbcdcd7a7401781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; qi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FutureState&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l00087">87</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f4e89c404bfea877211a60561db4f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="anyiterator_8hxx_source.html#l00055">55</a> of file <a class="el" href="anyiterator_8hxx_source.html">anyiterator.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ac9403cd278f0ecd3901d3995f3b713d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value equality operator. Will compare the values within. </p>

<p>Definition at line <a class="el" href="anyvalue_8hxx_source.html#l00236">236</a> of file <a class="el" href="anyvalue_8hxx_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae34013b6e2d0244f6863c17607be74a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the url strings. </p>

</div>
</div>
<a class="anchor" id="a6df69be73d369666577f9d4b2cd8dd78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa93b0cb5de04863592216daa6888214b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b1a7c27d89691523d3009a02285169c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::PromiseNoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqi_1_1Promise.html">qi::Promise</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function that does nothing on future cancelation</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>since 2.5: </dd></dl>

<p>Definition at line <a class="el" href="future__fwd_8hpp_source.html#l01010">1010</a> of file <a class="el" href="future__fwd_8hpp_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aceece21123bf061395fb61c01731a274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;typename detail::Accessor&lt;A&gt;::is_accessor, <a class="el" href="classqi_1_1PropertyBase.html">PropertyBase</a>*&gt;::type qi::propertyAccess </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="objecttypebuilder_8hxx_source.html#l00171">171</a> of file <a class="el" href="objecttypebuilder_8hxx_source.html">objecttypebuilder.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1f39390146087e0629f56a47773afee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::registerCppEmbeddedModule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>moduleName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(ModuleBuilder *)&gt;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>register a module into the module map </p>

</div>
</div>
<a class="anchor" id="a726e9946485acd3c5125ab71981d964b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::registerModuleFactory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleFactoryFunctor&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a module factory for a given language </p>

</div>
</div>
<a class="anchor" id="a32994dde8c5e2313e5a50cb83a87e138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proxy , typename Interface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool qi::registerProxyInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register <code><a class="el" href="classqi_1_1Proxy.html">Proxy</a></code> as a proxy class for interface <code>Interface</code>. Required to allow the typesystem to construct an Object&lt;Interface&gt; from an AnyObject. <a class="el" href="classqi_1_1Proxy.html">Proxy</a> must be constructible with an AnyObject as argument </p>
<dl class="section return"><dt>Returns</dt><dd>unused value, present to ease registration at static initialisation </dd></dl>

<p>Definition at line <a class="el" href="proxyregister_8hpp_source.html#l00142">142</a> of file <a class="el" href="proxyregister_8hpp_source.html">proxyregister.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5acba1383706c293755c20935f7d613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::registerStruct </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register type for signature -&gt; <a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> factory. </p>

</div>
</div>
<a class="anchor" id="a74b3c262e479a240240bf2ddd3cb0f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::registerType </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime Type factory setter. </p>

</div>
</div>
<a class="anchor" id="ace6d1120e34b4cc74c02accf512c3f6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1RepeatRange.html">RepeatRange</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;T&gt;, <a class="el" href="namespaceqi_1_1traits.html#afef90fea98a4e262ac81effaff969598">traits::RemoveCvRef</a>&lt;N&gt; &gt; qi::repeatRange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preconditions: boundedRange(N{}, end) Regular T, Iterator N </p>

<p>Definition at line <a class="el" href="range_8hpp_source.html#l00304">304</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a676caa123f59d84d4f0fe085f96e6e6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1Scoped.html">Scoped</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;T&gt;, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;F&gt; &gt; qi::scoped </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="structqi_1_1Scoped.html">Scoped</a> for the given value and function. Useful to do type deduction.</p>
<p>Regular T, FunctionObject&lt;U (T)&gt; F where U is not constrained </p>

<p>Definition at line <a class="el" href="scoped_8hpp_source.html#l00157">157</a> of file <a class="el" href="scoped_8hpp_source.html">scoped.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8149de1afdcf1e0dc403be71daa51b18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1Scoped.html">Scoped</a>&lt;void, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;F&gt; &gt; qi::scoped </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="structqi_1_1Scoped.html">Scoped</a> for the given function. Useful to do type deduction.</p>
<p>FunctionObject&lt;U (T)&gt; F where U is not constrained </p>

<p>Definition at line <a class="el" href="scoped_8hpp_source.html#l00167">167</a> of file <a class="el" href="scoped_8hpp_source.html">scoped.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9386f4efcbaab68069500a86674df8ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::scopedApplyAndRetract </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>retraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Scoped&lt;std::reference_wrapper&lt;T&gt;, traits::Decay&lt;G&gt;&gt;
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action&lt;T&gt; F, Action&lt;T&gt; G. </p>

<p>Definition at line <a class="el" href="scoped_8hpp_source.html#l00198">198</a> of file <a class="el" href="scoped_8hpp_source.html">scoped.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71fea5fdf4171f2492f5b5be826df500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::scopedApplyAndRetract </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Scoped&lt;std::reference_wrapper&lt;T&gt;, vs13::Retract&lt;traits::Decay&lt;F&gt;&gt;&gt;
  </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an action and applies its retraction on scope exit.</p>
<p>The retraction is obtained through the <code>IsomorphicAction</code> concept.</p>
<p>IsomorphicAction&lt;T&gt; F </p>

<p>Definition at line <a class="el" href="scoped_8hpp_source.html#l00216">216</a> of file <a class="el" href="scoped_8hpp_source.html">scoped.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addc353c7c828ba1e98e3340604475e49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::scopedIncrAndDecr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(scopedApplyAndRetract(value, Incr&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments a value and decrements it on scope exit.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> T::invoke_maybe(boost::function&lt;<span class="keywordtype">void</span>()&gt; f, <span class="keyword">const</span> boost::system::error_code&amp; erc)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!erc)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> _ = scopedIncrAndDecr&lt;Atomic&lt;uint64_t&gt;&gt;(_activeTask);</div>
<div class="line">    <span class="comment">// Here, `_activeTask` has been incremented.</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Here, `_activeTask` has been decremented.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>(Integral || BidirectionalIterator) T </p>

<p>Definition at line <a class="el" href="scoped_8hpp_source.html#l00288">288</a> of file <a class="el" href="scoped_8hpp_source.html">scoped.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abadde7a66bbf0a9b1b9b57e09d9a7fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::scopedSetAndRestore </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(scopedApplyAndRetract(
      value,
      makeMoveAssign&lt;T&gt;(fwd&lt;U&gt;(newValue)),
      makeMoveAssign&lt;T&gt;(std::move(value))))
  </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores a value on scope exit.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print(<span class="keyword">const</span> Element&amp; e)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> _ = <a class="code" href="namespaceqi.html#abadde7a66bbf0a9b1b9b57e09d9a7fcc">scopedSetAndRestore</a>(flags, flag_hex | flag_pretty);</div>
<div class="line">  <span class="comment">// Performs:</span></div>
<div class="line">  <span class="comment">//  auto oldFlags = flags;</span></div>
<div class="line">  <span class="comment">//  flags = flag_hex | flag_pretty;</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"><span class="comment">// On scope exit, performs:</span></div>
<div class="line"><span class="comment">//  flags = oldFlags;</span></div>
</div><!-- fragment --><p>Remark: Also works with move-only types.</p>
<p>Warning: As with <code>scoped</code> the return value must be stored on the stack. If it is not stored, the value is of course immediately restored.</p>
<p>With T t, U u, the following is valid: t = std::move(u); </p>

<p>Definition at line <a class="el" href="scoped_8hpp_source.html#l00249">249</a> of file <a class="el" href="scoped_8hpp_source.html">scoped.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ab708943448eb9763254b9a6470728e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; qi::scopelock </td>
          <td>(</td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00074">74</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3caa086a8287c6e24e93a33bbd83c6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;T&gt; qi::scopelock </td>
          <td>(</td>
          <td class="paramtype">boost::weak_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00080">80</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af844a26e7e6960b6c81ed6632d291a9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1AtomicFlagLock.html">AtomicFlagLock</a> qi::scopelock </td>
          <td>(</td>
          <td class="paramtype">std::atomic_flag &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>model ScopeLockable std::atomic_flag: </p>

<p>Definition at line <a class="el" href="atomic_8hpp_source.html#l00297">297</a> of file <a class="el" href="atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33a334ec73532dfe9ad81a52ab498c7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc , typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1ScopeLockProc.html">ScopeLockProc</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;Proc&gt;, <a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;M&gt; &gt; qi::scopeLockProc </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>mutLockable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to deduce types for <a class="el" href="structqi_1_1ScopeLockProc.html">ScopeLockProc</a>.</p>
<p>Procedure&lt;T (...)&gt; Proc, Mutable&lt;ScopeLockable&gt; M </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00692">692</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7e3524f08c9d697214c828d365b812d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1ScopeLockTransfo.html">ScopeLockTransfo</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;M&gt; &gt; qi::scopeLockTransfo </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>mutLockable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to deduce types for <a class="el" href="structqi_1_1ScopeLockTransfo.html">ScopeLockTransfo</a>.</p>
<p>Mutable&lt;ScopeLockable&gt; M </p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00743">743</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad68b84808e78bf348b4835101bbf1676"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::semiLift </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(compose(std::forward&lt;F&gt;(unit), std::forward&lt;Proc&gt;(p)))
  </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that transform the codomain (return type) of the given procedure into an "enriched" type.</p>
<p>This is related to monad theory (see below).</p>
<p>Example: Transforming a procedure of type (A -&gt; B) in a procedure of type (A -&gt; <a class="el" href="classqi_1_1Future.html">Future</a><b>): </p>
<div class="fragment"><div class="line"><span class="comment">// `proc` takes an `int` and returns a `bool`</span></div>
<div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespaceqi.html#ad68b84808e78bf348b4835101bbf1676">semiLift</a>(UnitFuture{}, proc);</div>
<div class="line">Future&lt;bool&gt; fut = f(i);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p></b></p>
<p><b></p>
<h1>Background on monads</h1>
<p></b></p>
<p><b></b></p>
<p><b>A monad can be viewed as an "enriched" type together with functions to go from and to the corresponding "base" type. In the above example, <code>int</code> is the base type and <code><a class="el" href="classqi_1_1Future.html">Future</a>&lt;int&gt;</code> is the enriched, monadic, type.</b></p>
<p><b>To lift is to map a function on base types to a function on the corresponding enriched types: </p>
<div class="fragment"><div class="line">enriched <span class="stringliteral">&quot;level&quot;</span>:  X&lt;int&gt; ---&gt; X&lt;bool&gt;</div>
<div class="line">                           ^</div>
<div class="line">                           | lift</div>
<div class="line">                           |</div>
<div class="line">base <span class="stringliteral">&quot;level&quot;</span>:      <span class="keywordtype">int</span>    ---&gt; <span class="keywordtype">bool</span></div>
</div><!-- fragment --><p> In the above case <code>X</code> is <code><a class="el" href="classqi_1_1Future.html">Future</a></code>.</b></p>
<p><b>Other examples for X are: std::optional, std::vector, etc.</b></p>
<p><b>Generally speaking, the enriched type (e.g. X&lt;int&gt;) gives access to a value of an underlying type (e.g. int). Thus, it can be viewed as a "container".</b></p>
<p><b>In our case, we have: </p>
<div class="fragment"><div class="line">enriched <span class="stringliteral">&quot;level&quot;</span>:       X&lt;bool&gt;</div>
<div class="line">                        ^    ^</div>
<div class="line">  <a class="code" href="namespaceqi.html#ad68b84808e78bf348b4835101bbf1676">semiLift</a>(proc, unit) /     | unit</div>
<div class="line">                      /      |</div>
<div class="line">base <span class="stringliteral">&quot;level&quot;</span>:      <span class="keywordtype">int</span> ---&gt; <span class="keywordtype">bool</span></div>
<div class="line">                       proc</div>
</div><!-- fragment --><p> This diagram commutes: all paths are equivalent.</b></p>
<p><b>That is we have, for all x: </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceqi.html#ad68b84808e78bf348b4835101bbf1676">semiLift</a>(proc, unit)(x) == (unit . proc)(x)</div>
</div><!-- fragment --><p> where <code>.</code> stands for the function composition (see <code>compose</code>).</b></p>
<p><b><code>unit</code> is a function that sends a "base" value to an "enriched", monadic value. Its name comes from the fact that it is a "unit" or "neutral element" for monadic composition.</b></p>
<p><b>This function is named <code>semiLift</code> because it partially "lifts" the procedure: only the codomain is enriched.</b></p>
<p><b>Procedure Proc </b></p>

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00231">231</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72f4518e1723f5b66a985e2fbd11fb52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;T&gt; &gt; qi::sharedPtr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a std::shared_ptr&lt;T&gt; with T deduced from the parameter. </p>

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00087">87</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a167afc34f376286d2e46424ae4941065"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;typename detail::Accessor&lt;A&gt;::is_accessor, <a class="el" href="classqi_1_1SignalBase.html">SignalBase</a>*&gt;::type qi::signalAccess </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="objecttypebuilder_8hxx_source.html#l00163">163</a> of file <a class="el" href="objecttypebuilder_8hxx_source.html">objecttypebuilder.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8199ee4e592ad4e5a704d44eefac588b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; qi::signatureSplit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fullSignature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a342cbb877923284a84ec54f51a4009c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepFor </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00017">17</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a74acfd43dea835f6752dad8fa47cc7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqi.html#a2b2a2e5db2d66c95b8b6f15f2bafbf59">qi::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks the execution of the current thread for at least <code>d</code>. </p>

</div>
</div>
<a class="anchor" id="ad62a281dc7248335ab2a69fab70adc09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepFor </td>
          <td>(</td>
          <td class="paramtype">const DurationType&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25f5e223a90ec2016534ef6d33d9729f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const SteadyClockTimePoint &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the execution of the current thread until <code>t</code> has been reached. </p>
<p>This is equivalent to sleepFor(t - SteadyClockTimePoint::now()) </p>

</div>
</div>
<a class="anchor" id="a58586cd571c328f307c91f3768d47ed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::time_point&lt; SteadyClock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00023">23</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad1cf1e23ac8f95d9729d5b3f0a9957cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const ClockTimePoint &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the execution of the current thread until <code>t</code> has been reached. </p>

</div>
</div>
<a class="anchor" id="aadf72cbd80cca5bd06955cdf5296a457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00029">29</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="abf082a7d6317673162dd6be89e877b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const SystemClockTimePoint &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the execution of the current thread until <code>t</code> has been reached. </p>
<p>Adjustments of the clock are taken into account. Thus the duration of the block might, but might not, be less or more than t - <a class="el" href="classqi_1_1SystemClock.html#ac81c05c9748622ad1d04e49129a2618c" title="Returns a time_point representing the current value of the clock. ">SystemClock::now()</a> </p>

</div>
</div>
<a class="anchor" id="a5c238426659012039786a3a9a1cea5d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qi::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::time_point&lt; SystemClock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00035">35</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5b47909071f18b24e7456faa433a50df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Url.html">Url</a> qi::specifyUrl </td>
          <td>(</td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>specification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>baseUrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use specified parts of the given URL to be set over the given base URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specification</td><td>An URL that may be incomplete, which specified parts must be kept. </td></tr>
    <tr><td class="paramname">baseUrl</td><td>A supposedly complete URL, which parts will be used to fill in the specified URL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5eeed22e4f35d2e93eac1fec0ff4dd48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qi::startEventLoop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the eventloop with nthread threads. Does nothing if already started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nthread</td><td>Set the minimum number of worker threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38b10163de67d05dffe73b58463f68bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> <a class="el" href="namespaceqi.html#a3834497c0f4e5f94c302ca438f1f976c">SteadyClockTimePoint</a> qi::steadyClockNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a time_point representing the current value of the clock. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00220">220</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55c8cbcb460492f02918d9f5a8cb3be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long qi::testAndSet </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cross-platform implementation of atomic Test-And-Set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>pointer to the value to test and set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (1) if cond is 0, false (0) otherwise. </dd></dl>

<p>Definition at line <a class="el" href="atomic_8hpp_source.html#l00033">33</a> of file <a class="el" href="atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe74a830e15fdc58d8a32a5ec1c38d32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::to_string </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::duration&lt; R, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00090">90</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ab1259c32b2756fc157487bdb049443e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::to_string </td>
          <td>(</td>
          <td class="paramtype">const DurationType&lt; R, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55c3096fbdc5499e98fb992f8b3a1ff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::to_string </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::time_point&lt; C, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hxx_source.html#l00099">99</a> of file <a class="el" href="clock_8hxx_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a82f62627a6f2a44b0d81ab2553827d00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt; <a class="el" href="classqi_1_1AnyValue.html">AnyValue</a> &gt; qi::toAnyValueFuture </td>
          <td>(</td>
          <td class="paramtype">Future&lt; T &gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="future_8hxx_source.html#l00705">705</a> of file <a class="el" href="future_8hxx_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a7719b3342ffcb84708136cfd6cb1c8ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1Future.html">Future</a>&lt;<a class="el" href="classqi_1_1AnyValue.html">AnyValue</a>&gt; qi::toAnyValueFuture </td>
          <td>(</td>
          <td class="paramtype">Future&lt; void &gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="future_8hxx_source.html#l00714">714</a> of file <a class="el" href="future_8hxx_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a890dc87043938975dac578ce19a0c971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::toISO8601String </td>
          <td>(</td>
          <td class="paramtype">const SystemClockTimePoint &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the date and time as a string in ISO 8601 format. The time is given up to millisecond precision, in UTC. The format does not include colon characters, to be suitable for inclusion in filenames on any filesystem. </p>
<p>For instance the string for a quarter past nine PM on April 3rd, 2001 is "2001-04-03T211500.000Z" </p>

</div>
</div>
<a class="anchor" id="a0992f93731c6e9ca683928547761c471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::tr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locale</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>context</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to translate </td></tr>
    <tr><td class="paramname">domain</td><td>Domain name </td></tr>
    <tr><td class="paramname">locale</td><td>Locale name </td></tr>
    <tr><td class="paramname">context</td><td>Context of the msg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated message </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9b0842d355f980ce85f11904a27b56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ARG0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;F&gt; qi::track </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; F &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ARG0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> instance. </p>
<dl class="section return"><dt>Returns</dt><dd>a function that, when called:<ul>
<li>If lock can be acquired, calls f</li>
<li>Else throws <a class="el" href="classqi_1_1PointerLockException.html">qi::PointerLockException</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a99cc706ceb17407798ebc096948fc43f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::track </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(trackWithFallback(detail::throwPointerLockException, std::forward&lt;F&gt;(f), std::forward&lt;T&gt;(toTrack)))
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00440">440</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a890339ae56ba90c3fde5eb7fd91679d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;F&gt; qi::track </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; F &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00465">465</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a98848ce746c8b0be72f3b3808ac58879"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::trackSilent </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(trackWithFallback(</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00447">447</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a431cbd0bdbc9dee42145337c2e3765d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;F&gt; qi::trackSilent </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; F &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00460">460</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="acfac69a3cb738aafb54c9220529d212f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1TrackSilentTransfo.html">TrackSilentTransfo</a>&lt;T&gt; qi::trackSilentTransfo </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper to deduce types to construct a <a class="el" href="structqi_1_1TrackSilentTransfo.html">TrackSilentTransfo</a>.</p>
<p><a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> T </p>

<p>Definition at line <a class="el" href="trackable_8hpp_source.html#l00172">172</a> of file <a class="el" href="trackable_8hpp_source.html">trackable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73c311c861d4adb37f2bde6cd0e5f2f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ARG0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;F&gt; qi::trackWithFallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; F &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ARG0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> instance. </p>
<dl class="section return"><dt>Returns</dt><dd>a function that, when called:<ul>
<li>If lock can be acquired, calls f</li>
<li>Else calls onFail </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afec0fdbbbf4a3e42952da2a43c42fa9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::trackWithFallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(detail::BindTransform&lt;T&gt;::wrap(std::forward&lt;T&gt;(toTrack), std::forward&lt;F&gt;(f), std::move(onFail)))
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00433">433</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a3c75972b852dbcbe852147732b2bf493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;F&gt; qi::trackWithFallback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; F &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trackable_8hxx_source.html#l00454">454</a> of file <a class="el" href="trackable_8hxx_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0e2280708fe591ee73844f207c610cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proc , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1TrackWithFallbackTransfo.html">TrackWithFallbackTransfo</a>&lt;<a class="el" href="namespaceqi_1_1traits.html#a856b64ee094b0ec03d2bd0f0bd8e0b9c">traits::Decay</a>&lt;Proc&gt;, T&gt; qi::trackWithFallbackTransfo </td>
          <td>(</td>
          <td class="paramtype">Proc &amp;&amp;&#160;</td>
          <td class="paramname"><em>fallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper to deduce types to construct a <a class="el" href="structqi_1_1TrackWithFallbackTransfo.html">TrackWithFallbackTransfo</a>.</p>
<p>Procedure&lt;void ()&gt; Proc, <a class="el" href="classqi_1_1Trackable.html" title="Object tracking by blocking destruction while shared pointers are present. ">Trackable</a> T </p>

<p>Definition at line <a class="el" href="trackable_8hpp_source.html#l00143">143</a> of file <a class="el" href="trackable_8hpp_source.html">trackable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa455773e2cc2e0cdf9b785615da4151f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string qi::trContext </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a message with a specific context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to translate </td></tr>
    <tr><td class="paramname">context</td><td>Context of the msg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated message </dd></dl>

</div>
</div>
<a class="anchor" id="afc29e0f4207ef96732cf0fb801ec75d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::tryLowerAtomicFlag </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverse operation of tryRaiseAtomicFlag. True if the atomic flag was successfully lowered (i.e. set to false). If it was already lowered, false is returned. Lemma tryLowerAtomicFlag.0: If the flag is up (true), <a class="el" href="namespaceqi.html#afc29e0f4207ef96732cf0fb801ec75d6">tryLowerAtomicFlag()</a> atomically lowers it (i.e. makes it false). </p>

<p>Definition at line <a class="el" href="atomic_8hpp_source.html#l00236">236</a> of file <a class="el" href="atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef52fccbce49beb8d9822a70fe379f47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::tryRaiseAtomicFlag </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if the atomic flag was successfully raised (i.e. set to true). If it was already raised, false is returned. Lemma tryRaiseAtomicFlag.0: If the flag is down (false), <a class="el" href="namespaceqi.html#aef52fccbce49beb8d9822a70fe379f47">tryRaiseAtomicFlag()</a> atomically raises it (i.e. makes it true). </p>

<p>Definition at line <a class="el" href="atomic_8hpp_source.html#l00223">223</a> of file <a class="el" href="atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d5d0e34c6e110a2b35788f4fdf9ce40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDispatcher &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TypeDispatcher&amp; qi::typeDispatch </td>
          <td>(</td>
          <td class="paramtype">TypeDispatcher &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyReference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="typedispatcher_8hxx_source.html#l00013">13</a> of file <a class="el" href="typedispatcher_8hxx_source.html">typedispatcher.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a81c3fd89490bba2596644ff2836f22a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dispatcher &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Dispatcher&amp; qi::typeDispatch </td>
          <td>(</td>
          <td class="paramtype">Dispatcher &amp;&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyReference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke one of the visitor functions in dispatcher based on kind(). Dispatcher must implement TypeDispatcher. </p>

</div>
</div>
<a class="anchor" id="a45c4fec4058dee00453ef20d1c544eec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a> * qi::typeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get type from a type. Will return a static TypeImpl&lt;T&gt; if T is not registered </p>

<p>Definition at line <a class="el" href="type_8hxx_source.html#l00094">94</a> of file <a class="el" href="type_8hxx_source.html">type.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa42acc117e914a07695eb02cd0a13aeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1TypeInterface.html">TypeInterface</a>* qi::typeOf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type from a value. No need to delete the result. </p>

<p>Definition at line <a class="el" href="detail_2typeinterface_8hpp_source.html#l00191">191</a> of file <a class="el" href="detail_2typeinterface_8hpp_source.html">typeinterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03f06858a9b60b22be750c329a7b9161"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename  = traits::EnableIf&lt;std::is_enum&lt;E&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qi::underlying </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> -&gt; traits::UnderlyingType&lt;E&gt;
  </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration E</p>
<p>This overload is only available for enum types through SFINAE because std::underlying_type has undefined behavior for non-enum types. </p>

<p>Definition at line <a class="el" href="flags_8hpp_source.html#l00022">22</a> of file <a class="el" href="flags_8hpp_source.html">flags.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afefc7d2d6bfea0ac920f877752234493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqi.html#a827eae44eb9f8ca4154e87014b3720ec">codecvt_type</a>&amp; qi::unicodeFacet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-8 facet object getter. </p>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 implementation for std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;</dd></dl>
<p>Return a facet object that can be used by stl (iostream, locale, ...) and std::locale compliant library like boost::filesystem.</p>
<p>This class allow conversion between UTF-8 (char) and UTF-16/UTF-32 (wchar). </p>

</div>
</div>
<a class="anchor" id="a221a33b40de86d6b6ac2550de54d45e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1FutureSync.html">qi::FutureSync</a>&lt;std::vector&lt;<a class="el" href="classqi_1_1Future.html">Future</a>&lt;T&gt; &gt; &gt; qi::waitForAll </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Future&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to wait on a vector of futures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>The vector of futures to wait on.</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">* This function will wait on all the futures of the given vector and return
* when they have all been set, either with an error or a valid value.
* </pre> 
<p>Definition at line <a class="el" href="futurebarrier_8hpp_source.html#l00237">237</a> of file <a class="el" href="futurebarrier_8hpp_source.html">futurebarrier.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cac1e0f4ab939ac0b4e9a281d610993"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqi_1_1FutureSync.html">qi::FutureSync</a>&lt; <a class="el" href="classqi_1_1Future.html">qi::Future</a>&lt;T&gt; &gt; qi::waitForFirst </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Future&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to wait for the first valid future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>The vector of futures to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first valid future, or an error.</dd></dl>
<pre class="fragment">* This function will wait on all the futures of the vector. It returns the
* first valid future that returns. If no future is valid, a future set with
* an error is returned.
* </pre> 
<p>Definition at line <a class="el" href="futurebarrier_8hpp_source.html#l00259">259</a> of file <a class="el" href="futurebarrier_8hpp_source.html">futurebarrier.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82d59e14f6a062febe8b365891879346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> <a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a> qi::wallClockNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a time_point representing the current value of the clock. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00226">226</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52e3526e66dd5ddc5e8fee467974575e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;T&gt; qi::weakPtr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weak_ptr&lt;T&gt; with T deduced from a shared_ptr&lt;T&gt; </p>

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00062">62</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf4c6998ed94e2df3993d0d787ed740a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::weak_ptr&lt;T&gt; qi::weakPtr </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utility_8hpp_source.html#l00068">68</a> of file <a class="el" href="utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a8ac8c843a70dad2461e2e18f3e6593c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int qi::JsonOption_Expand = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="jsoncodec_8hpp_source.html#l00019">19</a> of file <a class="el" href="jsoncodec_8hpp_source.html">jsoncodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d0c6e0eeb368ebee10e1f66ced08a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int qi::JsonOption_None = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="jsoncodec_8hpp_source.html#l00017">17</a> of file <a class="el" href="jsoncodec_8hpp_source.html">jsoncodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5ab4fea7eb9f2f2ed2d1deedc3fd996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int qi::JsonOption_PrettyPrint = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="jsoncodec_8hpp_source.html#l00018">18</a> of file <a class="el" href="jsoncodec_8hpp_source.html">jsoncodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adfddda083c8a79db85dde8042dda955e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqi_1_1Incr.html">Incr</a>&lt;T&gt; qi::retract(<a class="el" href="structqi_1_1Decr.html">Decr</a>&lt; T &gt;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="functional_8hpp_source.html#l00425">425</a> of file <a class="el" href="functional_8hpp_source.html">functional.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed7d2ac0e55865d84ff65749c4c4c7a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="api_8hpp.html#aa7f9e677e31e5208fa52fe4bbe899703">QITYPE_TEMPLATE_API</a> qi::TypeOfTemplate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type_8hxx_source.html#l00136">136</a> of file <a class="el" href="type_8hxx_source.html">type.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a00ef59cda7cb3b77ed04d3fa77d80512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> typedef <a class="el" href="classqi_1_1SystemClock.html">SystemClock</a> qi::WallClock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00209">209</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad096ee419913be83f1767644d3104975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macro_8hpp.html#aea06bc58307b46ea3a172b30dc9b6714">QI_API_DEPRECATED</a> typedef <a class="el" href="namespaceqi.html#a412ecc9dbc618e0f6816f9167f304f20">SystemClockTimePoint</a> qi::WallClockTimePoint</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System clock time point. </p>

<p>Definition at line <a class="el" href="clock_8hpp_source.html#l00216">216</a> of file <a class="el" href="clock_8hpp_source.html">clock.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->

<hr class="footer"/><address class="footer"><small>
Copyright Aldebaran Robotics
<!-- Generated on Tue May 15 2018 10:54:49 for libqi-api by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address> -->
</body>
</html>
