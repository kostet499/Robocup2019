<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>qi::concept Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div class="related">
  <ul>
    <!-- <li style="margin-right: 10px" class="right"> -->
    <!--   <a accesskey="I" title="General Index" href="genindex.html">index</a> -->
    <!-- </li> -->
    <!-- <li class="right"> -->
    <!--   <a accesskey="N" title="Whatâ€™s new?" href="news/whatsnew/index.html">next</a> | -->
    <!-- </li> -->
    <li><a href="../../index.html">Aldebaran documentation</a> |</li>
    <li><a href="../../ref/cpp-api.html">C++ Libraries</a> |</li>
    <li><a href="index.html">index</a></li>
  </ul>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqi-api
   &#160;<span id="projectnumber">2.8.2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceqi.html">qi</a></li><li class="navelem"><a class="el" href="namespaceqi_1_1concept.html">concept</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">qi::concept Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1>General definitions</h1>
<p>A <em>concept</em> is a conjunction of constraints on a type.</p>
<p>These constraints can be:</p>
<ul>
<li><em>syntactic</em> constraints ex: the expression "++a" must be defined</li>
<li><em>semantic</em> constraints ex: "--(++a) == a, forall a"</li>
<li><em>time and space algorithmic complexity</em> constraints ex: "*a" must be O(1) in time</li>
</ul>
<p>An algorithm is <em>generic</em> if it specifies, in terms of concepts, the minimal constraints for which it works.</p>
<p>A type that respects the constraints of a concept is said to <em>model</em> this concept.</p>
<p>Thus, the behavior of a generic algorithm is well defined for all its uses with types modeling the required concepts.</p>
<h1>Syntax</h1>
<p>As concepts are not yet part of the C++ language, they are specified here in terms of structured comments. The syntax used for their definition is as close as possible to the current proposal (N4630). This way when concepts are available in the language, it should be possible to make the switch with minimum effort.</p>
<p>Even in their current comment form, the user of these concepts is expected to include this file to allow the reader an easy access to the definitions.</p>
<p>The syntax is (between angle brackets are the variable parts): </p>
<div class="fragment"><div class="line">concept &lt;concept_name&gt;(&lt;type_variable&gt;) =</div>
<div class="line">     &lt;constraint0&gt;</div>
<div class="line">  &amp;&amp; &lt;constraint1&gt;</div>
<div class="line">  &amp;&amp; ...</div>
</div><!-- fragment --><h2>Example:</h2>
<div class="fragment"><div class="line">concept <a class="code" href="namespaceqi_1_1sock.html#afee5bb5f8807bdd3e6e1efdd205aa38f">Iterator</a>(I) =</div>
<div class="line">     Regular(I)</div>
<div class="line">  &amp;&amp; ValueType: <a class="code" href="namespaceqi_1_1sock.html#afee5bb5f8807bdd3e6e1efdd205aa38f">Iterator</a> -&gt; Regular</div>
<div class="line">  &amp;&amp; ++: I&amp; -&gt; <span class="keywordtype">void</span></div>
<div class="line">  &amp;&amp; *: I -&gt; ValueType&lt;I&gt;</div>
</div><!-- fragment --><p> This concept means that for a type I to be an Iterator:</p>
<ul>
<li>I must be Regular (this is another concept)</li>
<li>A type traits named "ValueType" must be defined. A type traits takes a type and "returns" another type at compile-time. Here, it takes a type that is an Iterator and return a type that is Regular. This means that anytime you have a type I that is an Iterator type, you can write "ValueType&lt;I&gt;" and get the type pointed by iterators of type I. For example, if I is an iterator on int, it is possible to write: <div class="fragment"><div class="line">ValueType&lt;I&gt; n = 0;</div>
</div><!-- fragment --> which is exactly the same as if you would have written directly: <div class="fragment"><div class="line"><span class="keywordtype">int</span> n = 0;</div>
</div><!-- fragment --></li>
<li>A "++" operator must be defined that changes the iterator in-place. For example, with an instance "it" of an Iterator type, it is possible to write: <div class="fragment"><div class="line">++it;</div>
</div><!-- fragment --></li>
<li>Finally, a "*" operation must be defined such that for example it is possible to write: <div class="fragment"><div class="line">ValueType&lt;I&gt; x = *it;</div>
</div><!-- fragment --></li>
</ul>
<h2>Example:</h2>
<div class="fragment"><div class="line">concept Semigroup(T) =</div>
<div class="line">     Regular(T)</div>
<div class="line">  &amp;&amp; *: T x T -&gt; T</div>
<div class="line">  &amp;&amp; associative(*)</div>
</div><!-- fragment --><p> This concept means that for a type T to be a Semigroup:</p>
<ul>
<li>T must be Regular (this is another concept)</li>
<li>T must have a function '*' defined, taking two instances of T and returning an instance of T, such that you can write: <div class="fragment"><div class="line">T c = a * b;</div>
</div><!-- fragment --></li>
<li>'*' must be associative, that is: <div class="fragment"><div class="line">(a * b) * c == a * (b * c) <span class="keywordflow">for</span> all a, b, c values of T</div>
</div><!-- fragment --></li>
</ul>
<h2>Notes</h2>
<p>Sometimes, a sentence or a real-usage example is clearer, so it is also possible to use a less formal syntax: </p>
<div class="fragment"><div class="line">concept NetSslSocket(S, C, I) =</div>
<div class="line">     NetSslContext(C)</div>
<div class="line">  &amp;&amp; NetIoService(I)</div>
<div class="line">  &amp;&amp; HandshakeSide&lt;S&gt;: NetHandshakeSide</div>
<div class="line">  &amp;&amp; Lowest&lt;S&gt;: NetLowestSocket</div>
<div class="line">  &amp;&amp; With I ioServiceLValue,</div>
<div class="line">          C sslContext,</div>
<div class="line">          HandshakeSide&lt;S&gt; handshakeSide,</div>
<div class="line">          NetHandler handler, the following are valid:</div>
<div class="line">       S sslSocket{ioServiceLValue, sslContext};</div>
<div class="line">    &amp;&amp; I&amp; io = sslSocket.get_io_service();</div>
<div class="line">    &amp;&amp; sslSocket.async_handshake(handshakeSide, handler)</div>
<div class="line">    &amp;&amp; Lowest&lt;S&gt;&amp; l = sslSocket.lowest_layer();</div>
<div class="line">    &amp;&amp; <span class="keyword">auto</span>&amp; n = sslSocket.next_layer();</div>
</div><!-- fragment --><h1>Core concept definitions</h1>
<h2>QuasiRegular</h2>
<div class="fragment"><div class="line">concept QuasiRegular(T) =</div>
<div class="line">    (forall a, b in T) T a = b; implies a == b</div>
<div class="line"> &amp;&amp; (forall a, b in T) a = b implies a == b</div>
<div class="line"> &amp;&amp; (forall a, b in T with a == b) modification on a implies a != b <span class="comment">// copies independence</span></div>
<div class="line"> &amp;&amp; equivalence(==)</div>
<div class="line"> &amp;&amp; totalOrdering(&lt;)</div>
</div><!-- fragment --><p> A QuasiRegular type is a Regular type without the default-constructibility. See Regular.</p>
<h2>Regular</h2>
<div class="fragment"><div class="line">concept Regular(T) =</div>
<div class="line">    QuasiRegular(T)</div>
<div class="line"> &amp;&amp; T() yields an <span class="keywordtype">object</span> in a partially-formed state.</div>
</div><!-- fragment --><p>definition: partially-formed state An object is in partially-formed state if it can only be assigned or destroyed. Any other operation is undefined. The main use is for default constructors. It allows them to possibly do nothing, for example no allocation, and so on, and be later assigned. It can be also useful for arrays, because they require default construction. Also, moved-from objects are typically in this state.</p>
<p>Informally, a Regular type behaves like a builtin type (e.g int) with respect to the construction, copy, assignment and equality. This greatly simplifies value manipulation and makes easier algorithm optimization by allowing substituting one expression by another (simpler, optimized) equal one.</p>
<p>More specifically, this concept ensures for example that two copies, either made via copy construction or assignment, are equal and independent. Copy independence means that modifying an object doesn't affect its copies.</p>
<h2>PseudoRegular</h2>
<div class="fragment"><div class="line">concept PseudoRegular(T) =</div>
<div class="line"> Same as Regular except that the runtime constraints are dropped.</div>
<div class="line"> This means that all the expressions required by Regular must be</div>
<div class="line"> valid (i.e. must compile), but <span class="keywordflow">for</span> example</div>
<div class="line"> T a = b; does not necessarily implies a == b anymore</div>
<div class="line"> (ditto <span class="keywordflow">for</span> other implications).</div>
</div><!-- fragment --><h2>Procedure</h2>
<div class="fragment"><div class="line">concept Procedure(T, Args..., Ret) =</div>
<div class="line">     Regular(T)</div>
<div class="line">  &amp;&amp; (): T&amp; x Args... -&gt; Ret</div>
<div class="line">  &amp;&amp; () is not necessarily regular</div>
</div><!-- fragment --><p> A Procedure is a type you can use as a function. There is no guarantee that calling several times an instance of a Procedure type will yield the same result (this is what is meant by "not necessarily regular"). For example, with an instance "proc" of a Procedure(Proc, int, char, bool) type, you can write: bool b = proc(5, 'z');</p>
<h2>Transformation</h2>
<div class="fragment"><div class="line">concept Transformation(F, A) =</div>
<div class="line">     Procedure(F, A, A)</div>
<div class="line">  &amp;&amp; () is regular</div>
</div><!-- fragment --><p> A transformation is a regular function taking a single argument and returning a value of the same type.</p>
<p>For example, "char toUpper(char)" is a transformation.</p>
<p>The notation "f^n" means that f is a transformation that is called n times.</p>
<p>For example, with an instance f of a Transformation type: </p>
<div class="fragment"><div class="line">f^3(x) means f(f(f(x))).</div>
</div><!-- fragment --><p> By definition, </p>
<div class="fragment"><div class="line">f^0(x) == x.</div>
</div><!-- fragment --><h2>Action</h2>
<div class="fragment"><div class="line">concept Action(F, A) =</div>
<div class="line">     Procedure(F, A&amp;, <span class="keywordtype">void</span>)</div>
<div class="line">  &amp;&amp; () is regular</div>
</div><!-- fragment --><p> An action is a regular function taking a value by reference and returning nothing. It is semantically equivalent to a transformation on T. For example, if "popping" a range means "removing its first element", you could write a transformation </p>
<div class="fragment"><div class="line">popTransfo: Rng -&gt; Rng</div>
</div><!-- fragment --><p> returning a new range without the first element and not modifying the original range, which would be equivalent to the action </p>
<div class="fragment"><div class="line">popAction: Rng&amp; -&gt; <span class="keywordtype">void</span></div>
</div><!-- fragment --><p> modifying the given range directly.</p>
<p>The benefit of an action is to avoid a potentially expensive copy, with the drawback of a somewhat more cumbersome writing.</p>
<p>For a real example, the Range concept defines "pop" as an action.</p>
<p>For convenience, this notation used for powers of transformation is extended to actions. For example, with an instance "a" of an Action type: </p>
<div class="fragment"><div class="line">a^3(x) means (a(x), a(x), a(x)) (i.e. three successive calls)</div>
</div><!-- fragment --><h2>IsomorphicAction</h2>
<div class="fragment"><div class="line">concept IsomorphicAction(F, A) =</div>
<div class="line">     Action(F, A)</div>
<div class="line">  &amp;&amp; <a class="code" href="namespaceqi.html#adfddda083c8a79db85dde8042dda955e">retract</a>: F -&gt; G where:</div>
<div class="line">        Action(G, A)</div>
<div class="line">     &amp;&amp; With g == <a class="code" href="namespaceqi.html#adfddda083c8a79db85dde8042dda955e">retract</a>(f):</div>
<div class="line">           (forall x in Arg) (f(x), g(x)) == x</div>
<div class="line">        &amp;&amp; (forall x in Arg) (g(x), f(x)) == x</div>
</div><!-- fragment --><p> This is an action that can be retracted, i.e. undone, in both directions. Another way to put it is that it is invertible.</p>
<h2>Function</h2>
<div class="fragment"><div class="line">concept <a class="code" href="namespaceqi_1_1traits.html#a095e9349180ac00cad15cdd78c91e521">Function</a>(F, Args..., Ret) =</div>
<div class="line">     Procedure(F, Args..., Ret)</div>
<div class="line">  &amp;&amp; () is regular</div>
</div><!-- fragment --><p> This is a mathematical function.</p>
<h2>RetractableFunction</h2>
<div class="fragment"><div class="line">concept RetractableFunction(F, Arg, Ret) =</div>
<div class="line">     <a class="code" href="namespaceqi_1_1traits.html#a095e9349180ac00cad15cdd78c91e521">Function</a>(F, Arg, Ret)</div>
<div class="line">  &amp;&amp; <a class="code" href="namespaceqi.html#adfddda083c8a79db85dde8042dda955e">retract</a>: F -&gt; G where:</div>
<div class="line">        <a class="code" href="namespaceqi_1_1traits.html#a095e9349180ac00cad15cdd78c91e521">Function</a>(G, Ret, Arg)</div>
<div class="line">     &amp;&amp; (forall x in Arg) <a class="code" href="namespaceqi.html#adfddda083c8a79db85dde8042dda955e">retract</a>(f)(f(x)) == x</div>
</div><!-- fragment --><p> This is a mathematical unary function that can be retracted, i.e. undone.</p>
<p>Warning: That does not mean that the other way can be undone, i.e. (forall y in Ret) f(retract(f)(y)) == y is false.</p>
<h2>Readable</h2>
<div class="fragment"><div class="line">concept Readable(T) =</div>
<div class="line">     Regular(T)</div>
<div class="line">  &amp;&amp; With T t, the following is valid:</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; value = *t;</div>
</div><!-- fragment --><p> A Readable is a type that you can dereference. It is only allowed to read the dereferenced value, not modifying it. Typical models are: const pointers, const iterators, const boost::optional, pointers, iterators, boost::optional</p>
<h2>Mutable</h2>
<div class="fragment"><div class="line">concept Mutable(T) =</div>
<div class="line">     Regular(T)</div>
<div class="line">  &amp;&amp; Readable(T)</div>
<div class="line">  &amp;&amp; With <span class="keyword">const</span> T t:</div>
<div class="line">    `*t = x` is well-formed and establishes `*t == x`</div>
</div><!-- fragment --><p> A Mutable is a type that you can dereference. The dereferenced value can be modified. Typical models are: pointers, iterators, boost::optional Note: Constness of a value of a Mutable type does not imply constness of the referenced value (same behavior as native pointers).</p>
<h2>Tuple</h2>
<div class="fragment"><div class="line">concept Tuple(T) =</div>
<div class="line">     Regular(T)</div>
<div class="line">  &amp;&amp; With T t, constexpr std::size_t I, the following is valid:</div>
<div class="line">       constexpr std::size_t N = std::tuple_size&lt;T&gt;::value;</div>
<div class="line">    &amp;&amp; <span class="keyword">auto</span>&amp; x = std::get&lt;I&gt;(t); <span class="comment">// for I in [0, N)</span></div>
</div><!-- fragment --><p> A Tuple is a heterogeneous container that can be unpacked. See <code>apply</code> for an example of unpacking. Typical models are: std::tuple, std::pair, std::array Note: Any user-defined type can be made to model this concept.</p>
<h2>ScopeLockable</h2>
<div class="fragment"><div class="line">concept ScopeLockable(T) =</div>
<div class="line">  With T&amp; t, the following is valid:</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (<span class="keyword">auto</span> lock = <a class="code" href="namespaceqi.html#af844a26e7e6960b6c81ed6632d291a9f">scopelock</a>(t))</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// In this scope, t is locked.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>A ScopeLockable ensures that a guarantee is true during the lifetime of the object acquired from the call to the scopelock function (often called a "lock", as in the example). The guarantee could be, for example, a safe mutually exclusive access to some data, or an acquisition and release of a resource, or another similarly symetric mechanism. Typical models are: std::mutex, std::recursive_mutex, std::weak_ptr&lt;T&gt;, std::atomic_flag, boost::synchronized_value&lt;T&gt;.</p>
<h1>Range concept definitions</h1>
<h2>Range</h2>
<div class="fragment"><div class="line">concept Range(R) =</div>
<div class="line">    Regular(R)</div>
<div class="line"> &amp;&amp; isEmpty: R -&gt; <span class="keywordtype">bool</span></div>
<div class="line"> &amp;&amp; pop: R -&gt; <span class="keywordtype">void</span></div>
<div class="line"> &amp;&amp; pop is not necessarily regular</div>
</div><!-- fragment --><p> In this basic concept, you can "iterate" through the range but not access the values. Which can be useful if you're only interested in advancing the front of the range.</p>
<p>The typical use is: </p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!isEmpty(myRange)) {</div>
<div class="line">  &lt;some code&gt;</div>
<div class="line">  pop(myRange);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that isEmpty is not guaranteed to ever return false, i.e. the range could be infinite. Also, pop being not necessarily regular, the traversal on a copy of a range is not guaranteed to yield the same result (e.g. useful for input streams).</p>
<h2>ForwardRange</h2>
<div class="fragment"><div class="line">concept ForwardRange(R) =</div>
<div class="line">    Range(R)</div>
<div class="line"> &amp;&amp; pop is regular (i.e. the range is multipass)</div>
</div><!-- fragment --><h2>ReadableRange</h2>
<div class="fragment"><div class="line">concept ReadableRange(R) =</div>
<div class="line">    Range(R)</div>
<div class="line"> &amp;&amp; <a class="code" href="namespaceqi.html#a78f7c49ded676ae47ef49ed3d148ccab">front</a>: R -&gt; U where Regular(U)</div>
</div><!-- fragment --><h2>ReadableForwardRange</h2>
<div class="fragment"><div class="line">concept ReadableForwardRange(R) =</div>
<div class="line">    ForwardRange(R)</div>
<div class="line"> &amp;&amp; ReadableRange(R)</div>
</div><!-- fragment --><h2>MutableForwardRange</h2>
<div class="fragment"><div class="line">concept MutableForwardRange(R) =</div>
<div class="line">    ReadableForwardRange(R)</div>
<div class="line"> &amp;&amp; (forall r in R where <a class="code" href="namespaceqi.html#a78f7c49ded676ae47ef49ed3d148ccab">front</a>(r) is defined) <a class="code" href="namespaceqi.html#a78f7c49ded676ae47ef49ed3d148ccab">front</a>(r) = x establishes <a class="code" href="namespaceqi.html#a78f7c49ded676ae47ef49ed3d148ccab">front</a>(r) == x</div>
</div><!-- fragment --> </div></div><!-- contents -->

<hr class="footer"/><address class="footer"><small>
Copyright Aldebaran Robotics
<!-- Generated on Tue May 15 2018 10:54:49 for libqi-api by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address> -->
</body>
</html>
