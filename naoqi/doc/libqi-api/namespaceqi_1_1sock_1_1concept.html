<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>qi::sock::concept Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div class="related">
  <ul>
    <!-- <li style="margin-right: 10px" class="right"> -->
    <!--   <a accesskey="I" title="General Index" href="genindex.html">index</a> -->
    <!-- </li> -->
    <!-- <li class="right"> -->
    <!--   <a accesskey="N" title="Whatâ€™s new?" href="news/whatsnew/index.html">next</a> | -->
    <!-- </li> -->
    <li><a href="../../index.html">Aldebaran documentation</a> |</li>
    <li><a href="../../ref/cpp-api.html">C++ Libraries</a> |</li>
    <li><a href="index.html">index</a></li>
  </ul>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqi-api
   &#160;<span id="projectnumber">2.8.2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceqi.html">qi</a></li><li class="navelem"><a class="el" href="namespaceqi_1_1sock.html">sock</a></li><li class="navelem"><a class="el" href="namespaceqi_1_1sock_1_1concept.html">concept</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">qi::sock::concept Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1>Concept definitions</h1>
<h2>NetErrorCode</h2>
<div class="fragment"><div class="line">*  concept NetErrorCode(E) =</div>
<div class="line">*    With E errorCode, the following is valid:</div>
<div class="line">*         <span class="keywordflow">if</span> (errorCode) {</div>
<div class="line">*           <span class="comment">// an error occurred</span></div>
<div class="line">*         }</div>
<div class="line">*      &amp;&amp; <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(E{}) == <span class="keyword">false</span></div>
<div class="line">*      &amp;&amp; Integral i = errorCode.value();</div>
<div class="line">*      &amp;&amp; std::string s = errorCode.message();</div>
<div class="line">*      &amp;&amp; E e = success&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = badAddress&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = networkUnreachable&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = ownerDead&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = operationAborted&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = hostNotFound&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = fault&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = messageSize&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = connectionRefused&lt;E&gt;();</div>
<div class="line">*      &amp;&amp; E e = shutdown&lt;E&gt;();</div>
<div class="line">* </div>
</div><!-- fragment --><p> Any network operation can result in an error. An error is convertible to a boolean: true means "error", false means "success". External functions are used to give access to common errors.</p>
<h2>NetTransferHandler</h2>
<div class="fragment"><div class="line">*  concept NetTransferHandler(H, E) =</div>
<div class="line">*       NetErrorCode(E)</div>
<div class="line">*    &amp;&amp; With H handler,</div>
<div class="line">*            E errorCode,</div>
<div class="line">*            std::size_t bytesTransferred, the following are valid:</div>
<div class="line">*        handler(errorCode, bytesTransfered)</div>
<div class="line">* </div>
</div><!-- fragment --><p> The handler (aka callback) called when an async read or async write completes (successfully or not). It gives access to an error code and the number of transfered bytes.</p>
<h2>NetHandler</h2>
<div class="fragment"><div class="line">*  concept NetHandler(H, E) =</div>
<div class="line">*       NetErrorCode(E)</div>
<div class="line">*    &amp;&amp; With H handler,</div>
<div class="line">*            E errorCode, the following are valid:</div>
<div class="line">*        handler(errorCode)</div>
<div class="line">* </div>
</div><!-- fragment --><p> A handler called with a single error code. Used for example when an async connect completes (successfully or not).</p>
<h2>NetEndpoint</h2>
<div class="fragment"><div class="line">*  concept NetEndpoint(P) =</div>
<div class="line">*    With p of type <span class="keyword">const</span> P, the following are valid:</div>
<div class="line">*         <span class="keywordtype">bool</span> b = p.address().is_v6();</div>
<div class="line">*      &amp;&amp; <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port = p.port();</div>
<div class="line">*      &amp;&amp; <span class="keyword">auto</span> x = p.protocol();</div>
<div class="line">*      &amp;&amp; std::string s = p.address().to_string();</div>
<div class="line">* </div>
</div><!-- fragment --><p> Allows you to get the address of the endpoint and know if the endpoint is IpV6.</p>
<h2>NetResolveHandler</h2>
<div class="fragment"><div class="line">*  concept NetResolveHandler(H, E, I) =</div>
<div class="line">*       NetErrorCode(E)</div>
<div class="line">*    &amp;&amp; <a class="code" href="namespaceqi_1_1sock.html#afee5bb5f8807bdd3e6e1efdd205aa38f">Iterator</a>(I)</div>
<div class="line">*    &amp;&amp; NetEndpoint(Value&lt;I&gt;)</div>
<div class="line">*    &amp;&amp; With H resolveHandler,</div>
<div class="line">*            E errorCode,</div>
<div class="line">*            I it, the following are valid:</div>
<div class="line">*         resolveHandler(errorCode, it)</div>
<div class="line">* </div>
</div><!-- fragment --><p> The handler called when an async resolve operation completes (successfully or not). The iterator gives access to a list of endpoints. The default-constructed value of the iterator represents the end. As long as the iterator is alive, the underlying endpoints also are, even if the originating resolver is destroyed.</p>
<h2>NetHandshakeSide</h2>
<div class="fragment"><div class="line">*  concept NetHandshakeSide(H) =</div>
<div class="line">*    The following are valid:</div>
<div class="line">*         H h = H::client;</div>
<div class="line">*      &amp;&amp; H h = H::server;</div>
<div class="line">* </div>
</div><!-- fragment --><p> Handshake is done both by the client and by the server with different roles. This allows you to differentiate them.</p>
<h2>NetEntry</h2>
<div class="fragment"><div class="line">*  concept NetEntry(E) =</div>
<div class="line">*    With e of type <span class="keyword">const</span> E, the following are valid:</div>
<div class="line">*         NetEndpoint endpoint = e.endpoint();</div>
<div class="line">* </div>
</div><!-- fragment --><p> Output of a URL resolver. Give access to an endpoint.</p>
<h2>NetShutdownMode</h2>
<div class="fragment"><div class="line">*  concept NetShutdownMode(M) =</div>
<div class="line">*    The following is valid:</div>
<div class="line">*      M m = M::shutdown_both;</div>
<div class="line">* </div>
</div><!-- fragment --><p> Shutdown mode used by the lowest layer of an SSL socket.</p>
<h2>NetOption</h2>
<div class="fragment"><div class="line">*  concept NetOption(O) =</div>
<div class="line">*    With <span class="keywordtype">bool</span> b, the following is valid:</div>
<div class="line">*      O option{b};</div>
<div class="line">* </div>
</div><!-- fragment --><h2>NetLowestSocket</h2>
<div class="fragment"><div class="line">*  concept NetLowestSocket(S, E, O) =</div>
<div class="line">*       NetErrorCode(E)</div>
<div class="line">*    &amp;&amp; NetOption(O)</div>
<div class="line">*    &amp;&amp; ShutdownMode&lt;S&gt;: NetShutdownMode</div>
<div class="line">*    &amp;&amp; Endpoint&lt;S&gt;: NetEndpoint</div>
<div class="line">*    &amp;&amp; With S socket,</div>
<div class="line">*            <span class="keyword">const</span> S const_socket,</div>
<div class="line">*            O noDelay,</div>
<div class="line">*            Endpoint&lt;S&gt; endpoint,</div>
<div class="line">*            NetHandler handler,</div>
<div class="line">*            ShutdownMode&lt;S&gt; shutdownMode,</div>
<div class="line">*            E errorCodeLValue, the following writings are valid:</div>
<div class="line">*         socket.set_option(noDelay)</div>
<div class="line">*      &amp;&amp; socket.async_connect(endpoint, handler)</div>
<div class="line">*      &amp;&amp; socket.shutdown(shutdownMode, errorCodeLValue)</div>
<div class="line">*      &amp;&amp; socket.cancel()</div>
<div class="line">*      &amp;&amp; socket.close(errorCodeLValue)</div>
<div class="line">*      &amp;&amp; Regular handle = socket.native_handle()</div>
<div class="line">*      &amp;&amp; Endpoint&lt;S&gt; e = const_socket.remote_endpoint()</div>
<div class="line">*      &amp;&amp; <span class="keywordtype">int</span> m = S::max_connections</div>
<div class="line">* </div>
</div><!-- fragment --><p> Lowest-layer of an SSL socket. It allows you to connect to an endpoint and close the connection.</p>
<h2>NetSslContextMethod</h2>
<div class="fragment"><div class="line">*  concept NetSslContextMethod(M) =</div>
<div class="line">*    The following is valid:</div>
<div class="line">*      M m = M::sslv23;</div>
<div class="line">* </div>
</div><!-- fragment --><p> The method to use for the SSL context.</p>
<h2>NetSslContext</h2>
<div class="fragment"><div class="line">*  concept NetSslContext(C) =</div>
<div class="line">*       Method&lt;C&gt;: NetSslContextMethod</div>
<div class="line">*    &amp;&amp; With Method&lt;C&gt; method, the following is valid:</div>
<div class="line">*        C sslContext(method);</div>
<div class="line">* </div>
</div><!-- fragment --><p> An SSL context used to construct an SSL socket.</p>
<h2>NetIoService</h2>
<div class="fragment"><div class="line">*  concept NetIoService(I) =</div>
<div class="line">*    With I io, Procedure&lt;T (ProcArgs...)&gt; proc the following is valid:</div>
<div class="line">*      Procedure&lt;void (ProcArgs...)&gt; proc2 = io.wrap(proc);</div>
<div class="line">*      proc2(procArgs...);</div>
<div class="line">*      which means that `wrap` returns a procedure accepting the same parameters</div>
<div class="line">*      as `proc` but returning `<span class="keywordtype">void</span>`.</div>
<div class="line">* </div>
</div><!-- fragment --><p> An io service wrap a procedure (typically a network handler) to strand it.</p>
<h2>NetSslSocket</h2>
<div class="fragment"><div class="line">*  concept NetSslSocket(S, O, C, V) =</div>
<div class="line">*       NetIoService(O)</div>
<div class="line">*    &amp;&amp; NetSslContext(C)</div>
<div class="line">*    &amp;&amp; Regular(V)</div>
<div class="line">*    &amp;&amp; HandshakeSide&lt;S&gt;: NetHandshakeSide</div>
<div class="line">*    &amp;&amp; Lowest&lt;S&gt;: NetLowestSocket</div>
<div class="line">*    &amp;&amp; With O ioServiceLValue,</div>
<div class="line">*            C sslContext,</div>
<div class="line">*            V sslVerifyMode,</div>
<div class="line">*            HandshakeSide&lt;S&gt; handshakeSide,</div>
<div class="line">*            NetHandler handler, the following are valid:</div>
<div class="line">*         S sslSocket{ioServiceLValue, sslContext};</div>
<div class="line">*      &amp;&amp; O&amp; io = sslSocket.get_io_service();</div>
<div class="line">*      &amp;&amp; sslSocket.set_verify_mode(sslVerifyMode)</div>
<div class="line">*      &amp;&amp; sslSocket.async_handshake(handshakeSide, handler)</div>
<div class="line">*      &amp;&amp; Lowest&lt;S&gt;&amp; l = sslSocket.lowest_layer();</div>
<div class="line">*      &amp;&amp; <span class="keyword">auto</span>&amp; n = sslSocket.next_layer();</div>
<div class="line">* </div>
</div><!-- fragment --><p> A socket that can send and receive data. The sending and receiving is done with external functions. To cipher data with SSL, a "SSL handshake" must be initially done. The socket can also send and receive data without SSL, by bypassing the SSL layer and directly using the "next-layer" socket. To open and close the connection, the "lowest-layer" socket must be used.</p>
<h2>NetAcceptor</h2>
<div class="fragment"><div class="line">*  concept NetAcceptor(A, P, O, S, I, E) =</div>
<div class="line">*       NetEndpoint(P)</div>
<div class="line">*    &amp;&amp; NetOption(O)</div>
<div class="line">*    &amp;&amp; NetSslSocket(S)</div>
<div class="line">*    &amp;&amp; NetIoService(I)</div>
<div class="line">*    &amp;&amp; NetErrorCode(E)</div>
<div class="line">*    &amp;&amp; With A acceptor,</div>
<div class="line">*            <span class="keyword">const</span> A const_acceptor,</div>
<div class="line">*            <span class="keyword">const</span> P endpoint,</div>
<div class="line">*            <span class="keyword">const</span> <span class="keywordtype">bool</span> reuse,</div>
<div class="line">*            S socket,</div>
<div class="line">*            <span class="keyword">const</span> NetHandler handler,</div>
<div class="line">*            E&amp; errorCode, the following are valid:</div>
<div class="line">*           I&amp; io = acceptor.get_io_service();</div>
<div class="line">*        &amp;&amp; acceptor.open(endpoint.protocol());</div>
<div class="line">*        &amp;&amp; <span class="keywordtype">bool</span> b = const_acceptor.is_open();</div>
<div class="line">*        &amp;&amp; acceptor.set_option(O{reuse});</div>
<div class="line">*        &amp;&amp; acceptor.bind(endpoint);</div>
<div class="line">*        &amp;&amp; acceptor.listen(errorCode);</div>
<div class="line">*        &amp;&amp; acceptor.async_accept(socket, handler);</div>
<div class="line">*        &amp;&amp; acceptor.close(errorCode);</div>
<div class="line">*        &amp;&amp; P localEp = const_acceptor.local_endpoint(errorCode);</div>
<div class="line">* </div>
</div><!-- fragment --><p> Asynchronously accepts incomming connections on a given endpoint and provides the associated socket.</p>
<h2>NetQueryFlag</h2>
<div class="fragment"><div class="line">*  concept NetQueryFlag(F) =</div>
<div class="line">*    The following is valid:</div>
<div class="line">*      F f = F::all_matching;</div>
<div class="line">* </div>
</div><!-- fragment --><p> <a class="el" href="classqi_1_1Flags.html">Flags</a> used by a resolver query.</p>
<h2>NetQuery</h2>
<div class="fragment"><div class="line">*  concept NetQuery(Q) =</div>
<div class="line">*       Flags&lt;Q&gt;: NetQueryFlag</div>
<div class="line">*    &amp;&amp; With std::string host, port,</div>
<div class="line">*            Flags&lt;Q&gt; flags, the following are valid:</div>
<div class="line">*         Q query{host, port};</div>
<div class="line">*      &amp;&amp; Q query{host, port, flags};</div>
<div class="line">* </div>
</div><!-- fragment --><p> A resolver query. <a class="el" href="classqi_1_1Flags.html">Flags</a> can optionally be set.</p>
<h2>NetResolver</h2>
<div class="fragment"><div class="line">*  concept NetResolver(R, O, E, S) =</div>
<div class="line">*       NetIoService(O)</div>
<div class="line">*    &amp;&amp; NetErrorCode(E)</div>
<div class="line">*    &amp;&amp; NetSslSocket(S)</div>
<div class="line">*    &amp;&amp; Query&lt;R&gt;: NetQuery</div>
<div class="line">*    &amp;&amp; Iterator&lt;R&gt;: SingularIterator on Endpoint&lt;Lowest&lt;S&gt;&gt;</div>
<div class="line">*    &amp;&amp; Entry&lt;R&gt;: NetEntry</div>
<div class="line">*    &amp;&amp; With O ioServiceLValue,</div>
<div class="line">*            Query&lt;R&gt; query,</div>
<div class="line">*            NetResolveHandler resolveHandler, the following are valid:</div>
<div class="line">*         R resolver{ioServiceLValue};</div>
<div class="line">*      &amp;&amp; resolver.async_resolve(query, resolveHandler)</div>
<div class="line">*      &amp;&amp; resolver.cancel();</div>
<div class="line">*      &amp;&amp; NetIoService&amp; io = resolver.get_io_service();</div>
<div class="line">*      &amp;&amp; If `resolver` is destroyed before `resolveHandler` has been called,</div>
<div class="line">*          `resolveHandler` must eventually be called with an error equal to</div>
<div class="line">*          `operationAborted&lt;E&gt;()`</div>
<div class="line">*      &amp;&amp; The iterator passed to `resolveHandler` must remain valid even <span class="keywordflow">if</span></div>
<div class="line">*          `resolver` is destroyed</div>
<div class="line">* </div>
</div><!-- fragment --><p> Asynchronously gets a list of endpoints for a given URL.</p>
<h2>Network</h2>
<div class="fragment"><div class="line">*  concept Network(N) =</div>
<div class="line">*       Acceptor&lt;N&gt;: NetAcceptor</div>
<div class="line">*    &amp;&amp; Resolver&lt;N&gt;: NetResolver</div>
<div class="line">*    &amp;&amp; SslContext&lt;N&gt;: NetSslContext</div>
<div class="line">*    &amp;&amp; SslSocket&lt;N&gt;: NetSslSocket</div>
<div class="line">*    &amp;&amp; SocketOptionNoDelay&lt;N&gt;: NetOption</div>
<div class="line">*    &amp;&amp; AcceptOptionReuseAddress&lt;N&gt;: NetOption</div>
<div class="line">*    &amp;&amp; ErrorCode&lt;N&gt;: NetErrorCode</div>
<div class="line">*    &amp;&amp; IoService&lt;N&gt;: NetIoService</div>
<div class="line">*    &amp;&amp; ConstBuffer&lt;N&gt;: Regular</div>
<div class="line">*    &amp;&amp; With Lowest&lt;SslSocket&lt;N&gt;&gt; lowest,</div>
<div class="line">*            decltype(s.native_handle()) handle,</div>
<div class="line">*            <span class="keywordtype">int</span> i,</div>
<div class="line">*            <span class="keywordtype">void</span>* data,</div>
<div class="line">*            <span class="keyword">const</span> <span class="keywordtype">void</span>* const_data,</div>
<div class="line">*            std::size_t maxSizeInBytes,</div>
<div class="line">*            SslSocket&lt;N&gt; sslSocketLValue,</div>
<div class="line">*            NetTransferHandler transferHandler, the following is valid:</div>
<div class="line">*         IoService&lt;N&gt;&amp; io = N::defaultIoService();</div>
<div class="line">*         Regular v = N::sslVerifyNone();</div>
<div class="line">*      &amp;&amp; N::setSocketNativeOptionsWindows(handle, i) if compiled on Windows</div>
<div class="line">*      &amp;&amp; N::setSocketNativeOptionsLinux(handle, i) if compiled on Linux</div>
<div class="line">*      &amp;&amp; N::setSocketNativeOptionsMacOs(handle) if compiled on MacOs</div>
<div class="line">*      &amp;&amp; MutableBufferSequence mutable_bufs = N::buffer(data, maxSizeInBytes);</div>
<div class="line">*          (MutableBufferSequence only constrained by the following)</div>
<div class="line">*      &amp;&amp; ConstBufferSequence const_bufs = N::buffer(const_data, maxSizeInBytes);</div>
<div class="line">*          (ConstBufferSequence only constrained by the following)</div>
<div class="line">*      &amp;&amp; N::async_read(sslSocketLValue, mutable_bufs, transferHandler)</div>
<div class="line">*      &amp;&amp; N::async_read(sslSocketLValue.next_layer(), mutable_bufs, transferHandler)</div>
<div class="line">*      &amp;&amp; N::async_write(sslSocketLValue, const_bufs, transferHandler)</div>
<div class="line">*      &amp;&amp; N::async_write(sslSocketLValue.next_layer(), const_bufs, transferHandler)</div>
<div class="line">* </div>
</div><!-- fragment --><p> Gives access to all types and functions handling low-level network operations:</p>
<ul>
<li>SSL socket</li>
<li>URL resolver</li>
<li>buffer creation</li>
<li>...</li>
</ul>
<p>Allows you to change the low-level network implementation. It has been designed to closely fit Boost.Asio, so as to incur no performance overhead. Another model is a mock for unit tests. </p>
</div></div><!-- contents -->

<hr class="footer"/><address class="footer"><small>
Copyright Aldebaran Robotics
<!-- Generated on Tue May 15 2018 10:54:50 for libqi-api by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address> -->
</body>
</html>
